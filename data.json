{
  "services": [
    {
      "id": 10,
      "status": "WAITING_DATA",
      "start_at": "2025-06-19T00:00:00.000-03:00",
      "end_at": "2025-06-20T23:59:59.999-03:00",
      "created_at": "2026-06-19T20:57:58.320-03:00",
      "updated_at": "2026-06-19T21:09:10.594-03:00",
      "platform": "ANDROID",
      "services": {
        "id": 0,
        "name": "Mobile Penetration Testing"
      },
      "assessment": {
        "status": "CREATED",
        "id": "dbae79d5-df69-4cab-a4e0-341fa544a19a",
        "name": null,
        "company": {
          "id": 1,
          "name": "Just Mobile Security"
        }
      },
      "scans": []
    },
    {
      "id": 9,
      "status": "IN PROGRESS",
      "start_at": "2025-06-16T00:00:00.000-03:00",
      "end_at": "2025-06-17T23:59:59.999-03:00",
      "created_at": "2025-06-16T20:57:58.320-03:00",
      "updated_at": "2025-06-16T21:09:10.594-03:00",
      "platform": "ANDROID",
      "services": {
        "id": 0,
        "name": "Mobile Penetration Testing"
      },
      "assessment": {
        "status": "IN PROGRESS",
        "id": "dbae79d5-df69-4cab-a4e0-341fa544a19a",
        "name": null,
        "company": {
          "id": 1,
          "name": "Just Mobile Security"
        }
      },
      "scans": [
        {
          "id": "48d0a90a-69c1-4c27-b09c-9bc9fd39f425",
          "aat_version": "0.1.0-beta-2",
          "scan_status": "ENQUEUED",
          "created_at": "2025-06-16T20:57:59.724-03:00",
          "updated_at": "2025-06-16T21:09:10.573-03:00",
          "type": "SAST",
          "app_id": "483a9065-1ab3-4a0a-8d7d-70e684b8815e",
          "assessment_service_id": 7,
          "app": {
            "id": "483a9065-1ab3-4a0a-8d7d-70e684b8815e",
            "name": "Fake App",
            "description": "com.fake.app.beta",
            "created_at": "2025-06-16T20:57:59.722-03:00",
            "updated_at": "2025-06-16T20:59:02.917-03:00",
            "version": null,
            "icon": {
              "url": "http://storage.fakedomain.com/bucket-storage/assessments/dbae79d5-df69-4cab-a4e0-341fa544a19a/service/7/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T012947Z&X-Amz-Expires=600&X-Amz-Signature=b6bfb8688bff45841aff2a0b52a1959fd0cdcc87118cd35404ed491e924170f8&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
              "name": "assessments/dbae79d5-df69-4cab-a4e0-341fa544a19a/service/7/icon.png",
              "extname": "png",
              "size": 5264,
              "mimeType": "image/png"
            }
          }
        }
      ]
    },
    {
      "id": 8,
      "status": "COMPLETED",
      "start_at": "2025-06-15T00:00:00.000-03:00",
      "end_at": "2025-06-16T23:59:59.999-03:00",
      "created_at": "2025-06-15T20:57:58.320-03:00",
      "updated_at": "2025-06-15T21:09:10.594-03:00",
      "platform": "ANDROID",
      "services": {
        "id": 0,
        "name": "Mobile Penetration Testing"
      },
      "assessment": {
        "status": "COMPLETED",
        "id": "dbae79d5-df69-4cab-a4e0-341fa544a19a",
        "name": null,
        "company": {
          "id": 1,
          "name": "Just Mobile Security"
        }
      },
      "scans": [
        {
          "id": "48d0a90a-69c1-4c27-b09c-9bc9fd39f425",
          "aat_version": "0.1.0-beta-2",
          "scan_status": "ABORTED_ERROR",
          "created_at": "2025-06-15T20:57:59.724-03:00",
          "updated_at": "2025-06-15T21:09:10.573-03:00",
          "type": "SAST",
          "app_id": "483a9065-1ab3-4a0a-8d7d-70e684b8815e",
          "assessment_service_id": 7,
          "app": {
            "id": "483a9065-1ab3-4a0a-8d7d-70e684b8815e",
            "name": "Fake App",
            "description": "com.fake.app.beta",
            "created_at": "2025-06-15T20:57:59.722-03:00",
            "updated_at": "2025-06-15T20:59:02.917-03:00",
            "version": null,
            "icon": {
              "url": "http://storage.fakedomain.com/bucket-storage/assessments/dbae79d5-df69-4cab-a4e0-341fa544a19a/service/7/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T012947Z&X-Amz-Expires=600&X-Amz-Signature=b6bfb8688bff45841aff2a0b52a1959fd0cdcc87118cd35404ed491e924170f8&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
              "name": "assessments/dbae79d5-df69-4cab-a4e0-341fa544a19a/service/7/icon.png",
              "extname": "png",
              "size": 5264,
              "mimeType": "image/png"
            }
          }
        }
      ]
    },
    {
      "id": 7,
      "status": "COMPLETED",
      "start_at": "2025-06-14T00:00:00.000-03:00",
      "end_at": "2025-06-15T23:59:59.999-03:00",
      "created_at": "2025-06-14T20:57:58.320-03:00",
      "updated_at": "2025-06-14T21:09:10.594-03:00",
      "platform": "ANDROID",
      "services": {
        "id": 0,
        "name": "Mobile Penetration Testing"
      },
      "assessment": {
        "status": "COMPLETED",
        "id": "dbae79d5-df69-4cab-a4e0-341fa544a19a",
        "name": null,
        "company": {
          "id": 1,
          "name": "Just Mobile Security"
        }
      },
      "scans": [
        {
          "id": "48d0a90a-69c1-4c27-b09c-9bc9fd39f425",
          "aat_version": "0.1.0-beta-2",
          "scan_status": "FINISHED",
          "created_at": "2025-06-14T20:57:59.724-03:00",
          "updated_at": "2025-06-14T21:09:10.573-03:00",
          "type": "SAST",
          "app_id": "483a9065-1ab3-4a0a-8d7d-70e684b8815e",
          "assessment_service_id": 7,
          "app": {
            "id": "483a9065-1ab3-4a0a-8d7d-70e684b8815e",
            "name": "Fake App",
            "description": "com.fake.app.beta",
            "created_at": "2025-06-14T20:57:59.722-03:00",
            "updated_at": "2025-06-14T20:59:02.917-03:00",
            "version": null,
            "icon": {
              "url": "http://storage.fakedomain.com/bucket-storage/assessments/dbae79d5-df69-4cab-a4e0-341fa544a19a/service/7/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T012947Z&X-Amz-Expires=600&X-Amz-Signature=b6bfb8688bff45841aff2a0b52a1959fd0cdcc87118cd35404ed491e924170f8&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
              "name": "assessments/dbae79d5-df69-4cab-a4e0-341fa544a19a/service/7/icon.png",
              "extname": "png",
              "size": 5264,
              "mimeType": "image/png"
            }
          }
        }
      ],
      "summary": {
        "appId": "483a9065-1ab3-4a0a-8d7d-70e684b8815e",
        "name": "Fake App",
        "description": "com.fake.app.beta",
        "platform": "ANDROID",
        "version": "",
        "createdAt": "2025-06-14T20:57:59.724-03:00",
        "finishedAt": "2025-06-14T21:09:10.573-03:00",
        "statusId": 5,
        "status": "Incomplete",
        "duration": {
          "days": 0,
          "hours": 0,
          "minutes": 11,
          "seconds": 10,
          "milliseconds": 849,
          "human": "11 minutes"
        },
        "file": {
          "name": "assessments/dbae79d5-df69-4cab-a4e0-341fa544a19a/service/7/fake_app_beta_v_3.20.0-BETA.apk",
          "size": "37.58 MB"
        },
        "icon": "http://storage.fakedomain.com/bucket-storage/assessments/dbae79d5-df69-4cab-a4e0-341fa544a19a/service/7/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T034210Z&X-Amz-Expires=600&X-Amz-Signature=fcf2f7b7dbde6c17492ced448579bc7bdcc66e55baf3879d30fefec6df8fec0f&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
        "start_date": "2025-06-14T00:00:00.000-03:00",
        "end_date": "2025-06-15T23:59:59.999-03:00"
      },
      "vulnerabilities": [
        {
          "vulnerabilityId": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
          "title": "SQL Injection",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team discovered potential SQL Injection (SQLi) vulnerabilities in the decompiled source code of the <b>Fake App</b> Android application, specifically in how the application handles SQL database operations. The critical findings include the use of methods such as insert, delete, query, execSQL, and rawQuery without proper input validation or parameterization. This opens up possible attack vectors if these database operations interact with external inputs. For example, if these methods are triggered via deeplinks, interceptable network communications, or manipulated within insecure WebViews, they could potentially be exploited remotely. Such vulnerabilities are particularly concerning as they could allow an attacker to inject malicious SQL queries to manipulate or exfiltrate data from the application’s local databases, posing significant risks to data integrity and security.</p>\n<p>The following code snippet shows the insecure implementation.</p>\n",
              "remediation": "<p>The assessment team recommends the following:</p>\n<ul>\n<li>Implement Parameterized Queries: Replace all raw SQL query constructions with parameterized queries to prevent SQL injection. This practice ensures that input values are treated as data, not executable code.\n</li>\n<li>Validate and Sanitize Inputs: Rigorously validate and sanitize all inputs, especially those obtained from external sources such as deeplinks, network communications, or WebViews. Ensure that inputs conform to expected formats and do not contain malicious SQL code.\n</li>\n<li>Secure WebViews: If the application uses WebViews, ensure they are configured securely. Disable JavaScript execution if not needed, and restrict interaction between the WebView and the application to minimize exposure to injection attacks.\n</li>\n<li>Review and Restrict Database Permissions: Restrict the database permissions to the minimum necessary for the application to function. This minimizes the potential damage from an SQL injection attack by limiting what an attacker can do within the database.</li>\n</ul>\n",
              "impact": "<p>An attacker could potentially execute unauthorized SQL commands, leading to data manipulation or exfiltration. This could result in the compromise of sensitive user data stored within the application&#39;s databases, such as personal details, credentials, financial information or disrupt application functionality. The ability to exploit these vulnerabilities remotely via methods like deeplinks or insecure WebViews significantly increases the severity of the threat, expanding the potential for widespread impact on users.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación halló una posible vulnerabilidad de inyección de SQL (SQLi) en el código fuente sin compilar de la aplicación Android <b>Fake App</b>, específicamente, en la manera en la que la aplicación maneja las operaciones de bases de datos de SQL. Estos hallazgos críticos incluyen el uso de métodos (como insert, delete, query, execSQL y rawQuery) sin una validación o parametrización apropiada de las entradas. Esto habilita posibles vectores de ataque si estas operaciones de base de datos interactúan con entradas externas. Por ejemplo, si estos métodos son activadios a través enlaces profundos o comunicaciones de red interceptables, o si se manipulan en vistas web inseguras, podrían explotarse de manera remota. Estas vulnerabilidades son particularmente preocupantes, ya que podrían permitirle a un atacante inyectar consultas SQL malintencionadas para manipular o extraer información de las bases de datos locales de la aplicación, lo cual implica un gran riesgo para la seguridad y la integridad de la información.</p>\n<p>El siguiente fragmento de código muestra la implementación segura.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda lo siguiente:</p>\n<ul>\n<li>Implementar consultas parametrizadas: reemplace todas las construcciones de consultas SQL sin formato con consultas parametrizadas para evitar la inyección de SQL. Esta práctica garantiza que los valores de entrada se traten como datos, y no como código ejecutable.\n</li>\n<li>Validar y desinfectar entradas: valide y desinfecte rigurosamente todas las entradas, especialmente aquellas obtenidas de fuentes externas, como enlaces profundos, comunicaciones de red o vistas web. Asegúrese de que las entradas se ajusten a los formatos esperados y no contengan código SQL malintencionado.\n</li>\n<li>Vistas web seguras: si la aplicación utiliza vistas web, asegúrese de que estén configurados de manera segura. Deshabilite la ejecución de JavaScript si no es necesario y restrinja la interacción entre las vistas web y la aplicación para minimizar la exposición a ataques de inyección.\n</li>\n<li>Revisar y restringir los permisos de la base de datos: mantenga los permisos de la base de datos al mínimo necesario para que la aplicación funcione. Esto minimiza el daño potencial de un ataque de inyección SQL al limitar lo que un atacante puede hacer dentro de la base de datos</li>\n</ul>\n",
              "impact": "<p>Un atacante podría ejecutar comandos SQL no autorizados, lo que llevaría a la manipulación o extracción de datos. Esto podría poner en peligro la información sensible de los usuarios almacenada en las bases de datos de la aplicación (como detalles personales, credenciales, información financiera) o interrumpir la funcionalidad de la aplicación. La capacidad de explotar estas vulnerabilidades de manera remota mediante enlaces profundos o vistas web inseguras aumenta significativamente la gravedad de la amenaza y amplía el potencial de un impacto generalizado en los usuarios.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "SQL injection | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sql-injection"
            },
            {
              "label": "V10: Code Quality Requirements - OWASP MASVS",
              "url": "https://mas.owasp.org/MASVS/10-MASVS-CODE/"
            },
            {
              "label": "MASVS-CODE-2.5: Security Control Verification Requirements | OWASP MASTG",
              "url": "https://mas.owasp.org/MASTG/tests/android/MASVS-CODE/MASTG-TEST-0025/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0086"
          },
          "evidences": [
            {
              "id": "d117a182-d5dd-42d7-90c7-dc878d9a7b79",
              "value": "public final synchronized long v(String table) {\n         long numberRows;\n         numberRows = 0;\n         SQLiteStatement statement = null;\n         try {\n             SQLiteDatabase db = getReadableDatabase();\n             String query = \"SELECT COUNT(*) FROM \" + table;\n             statement = db.compileStatement(query);\n             numberRows = statement.simpleQueryForLong();\n             statement.close();\n             close();\n         } catch (SQLiteException e) {\n             h.c.c(h.a, String.format(\"getNumberRows for %s failed\", table), e);\n             m();\n             if (statement != null) {\n                 statement.close();\n             }\n             close();\n             return numberRows;\n         } catch (StackOverflowError e2) {\n             h.c.c(h.a, String.format(\"getNumberRows for %s failed\", table), e2);\n             m();\n             if (statement != null) {\n                 statement.close();\n             }\n             close();\n             return numberRows;\n         }\n         return numberRows;\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/a/a/h.java",
              "file_line": [
                4023
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.501-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6165bb98-7a4f-43df-93d9-ea8434666398",
              "value": "public final void a(SQLiteDatabase db, long heapAnalysisId) {\n         q.g(db, \"db\");\n         i.a.a(db, heapAnalysisId);\n         db.execSQL(\"\\n      DELETE\\n      FROM leak\\n      WHERE NOT EXISTS (\\n      SELECT *\\n      FROM leak_trace lt\\n      WHERE leak.id = lt.leak_id)\\n    \");\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/b/h.java",
              "file_line": [
                68
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.906-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "30165cfc-73fe-4675-ac84-7c274a75131e",
              "value": "public final void b(SQLiteDatabase db) {\n         db.execSQL(\"DROP TABLE IF EXISTS heap_analysis\");\n         db.execSQL(\"DROP TABLE IF EXISTS leak\");\n         db.execSQL(\"DROP TABLE IF EXISTS leak_trace\");\n         onCreate(db);\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/b/j.java",
              "file_line": [
                62
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.955-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4cc04c7f-b265-42cd-9e93-62148a5eaa35",
              "value": "public final void a(b.b bVar) {\n         int i;\n         p pVar;\n         q.g(bVar, \"$receiver\");\n         h.b e = h.a.e(bVar.b(), j.c(((j.a) this).a));\n         if (e == null) {\n             bVar.a(k.a);\n             return;\n         }\n         if (j.d(((j.a) this).a) != null) {\n             Iterator it = e.a().iterator();\n             i = 0;\n             while (true) {\n                 if (it.hasNext()) {\n                     long c = ((h.c) it.next()).c();\n                     Long d = j.d(((j.a) this).a);\n                     if (d != null && c == d.longValue()) {\n                         break;\n                     }\n                     i++;\n                 } else {\n                     i = -1;\n                     break;\n                 }\n             }\n         } else {\n             i = 0;\n         }\n         if (i != -1) {\n             long c2 = ((h.c) e.a().get(i)).c();\n             d dVar = d.b;\n             SQLiteDatabase b = bVar.b();\n             Cursor rawQuery = b.rawQuery(\"\\n              SELECT\\n              object\\n              FROM heap_analysis\\n              WHERE id=\" + c2 + \"\\n              \", null);\n             q.c(rawQuery, \"db.rawQuery(\\n      \\\"\\\"\\\"\\n …          \\\"\\\"\\\", null\\n    )\");\n             try {\n                 if (rawQuery.moveToNext()) {\n                     b0 b0Var = b0.a;\n                     byte[] blob = rawQuery.getBlob(0);\n                     q.c(blob, \"cursor.getBlob(0)\");\n                     Object readObject = new ObjectInputStream(new ByteArrayInputStream(blob)).readObject();\n                     if (!(readObject instanceof p)) {\n                         readObject = null;\n                     }\n                     pVar = (p) readObject;\n                     if (pVar == null) {\n                         d.b.b(b, c2, (File) null);\n                     }\n                 } else {\n                     pVar = null;\n                 }\n                 rawQuery.close();\n                 if (pVar != null) {\n                     bVar.a(new j.a.a(this, e, i, pVar));\n                 } else {\n                     q.p();\n                     throw null;\n                 }\n             } catch (Throwable th) {\n                 try {\n                     throw th;\n                 } catch (Throwable th2) {\n                     try {\n                         rawQuery.close();\n                     } catch (Throwable th3) {\n                     }\n                     throw th2;\n                 }\n             }\n         } else {\n             bVar.a(l.a);\n         }\n         h.a.c(bVar.b(), j.c(((j.a) this).a));\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/c/j$a.java",
              "file_line": [
                252
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.042-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "31fb85c2-2bf4-40c8-aab6-175b20566350",
              "value": "public final void o0(SQLiteDatabase db) {\n         db.execSQL(\"DROP TABLE IF EXISTS store\");\n         db.execSQL(\"DROP TABLE IF EXISTS long_store\");\n         db.execSQL(\"DROP TABLE IF EXISTS events\");\n         db.execSQL(\"DROP TABLE IF EXISTS identifys\");\n         onCreate(db);\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/a/a/h.java",
              "file_line": [
                3538
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.531-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4a089eed-1d4c-475b-83a6-56321d9a8c51",
              "value": "private long getPageSize() {\n         return getDb().compileStatement(\"PRAGMA page_size\").simpleQueryForLong();\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java",
              "file_line": [
                242
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.681-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4ba1ed23-5bca-4e47-a180-78f1a546285d",
              "value": "public final void c(SQLiteDatabase db) {\n         m analysis;\n         boolean z;\n         m analysis2;\n         List all;\n         q.g(db, \"db\");\n         boolean z2 = false;\n         ThreadLocal a = a.a();\n         Object obj = a.get();\n         int i = 0;\n         if (obj == null) {\n             a.set(false);\n             obj = false;\n         }\n         int i2 = 1;\n         if (((Boolean) obj).booleanValue()) {\n             SQLiteDatabase $this$inTransaction = db;\n             Cursor $this$use$iv = $this$inTransaction.rawQuery(\"\\n              SELECT\\n              id,\\n              object\\n              FROM heap_analysis\\n              \", null);\n             q.c($this$use$iv, \"rawQuery(\\n        \\\"\\\"\\\"\\n  …        \\\"\\\"\\\", null\\n      )\");\n             Cursor cursor = $this$use$iv;\n             try {\n                 List all2 = new ArrayList();\n                 while (cursor.moveToNext()) {\n                     Cursor cursor2 = cursor;\n                     try {\n                         long id = cursor2.getLong(i);\n                         b0 b0Var = b0.a;\n                         byte[] byteArray$iv = cursor2.getBlob(i2);\n                         q.c(byteArray$iv, \"cursor.getBlob(1)\");\n                         ByteArrayInputStream inputStream$iv = new ByteArrayInputStream(byteArray$iv);\n                         try {\n                             try {\n                                 Object readObject = new ObjectInputStream(inputStream$iv).readObject();\n                                 z = z2;\n                                 try {\n                                     if (!(readObject instanceof m)) {\n                                         readObject = null;\n                                     }\n                                     analysis2 = (m) readObject;\n                                 } catch (Throwable th) {\n                                     ignored$iv = th;\n                                     a1 this_$iv$iv = a1.b;\n                                     a1.a logger$iv$iv = this_$iv$iv.a();\n                                     if (logger$iv$iv != null) {\n                                         logger$iv$iv.b(ignored$iv, \"Could not deserialize bytes, ignoring\");\n                                     }\n                                     analysis2 = null;\n                                     if (analysis2 == null) {\n                                     }\n                                     all2 = all;\n                                     cursor = cursor2;\n                                     z2 = z;\n                                     i = 0;\n                                     i2 = 1;\n                                 }\n                             } catch (Throwable th2) {\n                                 ignored$iv = th2;\n                                 z = z2;\n                             }\n                         } catch (Throwable th3) {\n                             ignored$iv = th3;\n                             z = z2;\n                         }\n                         if (analysis2 == null) {\n                             try {\n                                 all = all2;\n                                 all.add(r.a(Long.valueOf(id), analysis2));\n                             } catch (Throwable th4) {\n                                 e$iv = th4;\n                                 try {\n                                     throw e$iv;\n                                 } catch (Throwable e$iv) {\n                                     try {\n                                         $this$use$iv.close();\n                                     } catch (Throwable th5) {\n                                     }\n                                     throw e$iv;\n                                 }\n                             }\n                         } else {\n                             all = all2;\n                         }\n                         all2 = all;\n                         cursor = cursor2;\n                         z2 = z;\n                         i = 0;\n                         i2 = 1;\n                     } catch (Throwable th6) {\n                         e$iv = th6;\n                     }\n                 }\n                 List list = all2;\n                 List $this$forEach$iv = list;\n                 boolean z3 = false;\n                 try {\n                     Iterator it = $this$forEach$iv.iterator();\n                     while (it.hasNext()) {\n                         Object element$iv = it.next();\n                         l $dstr$id$_u24__u24 = (l) element$iv;\n                         long id2 = ((Number) $dstr$id$_u24__u24.a()).longValue();\n                         List $this$forEach$iv2 = $this$forEach$iv;\n                         StringBuilder sb = new StringBuilder();\n                         sb.append(\"id=\");\n                         boolean z4 = z3;\n                         Iterator it2 = it;\n                         sb.append(id2);\n                         SQLiteDatabase $this$inTransaction2 = $this$inTransaction;\n                         try {\n                             db.delete(\"heap_analysis\", sb.toString(), null);\n                             h.a.a(db, id2);\n                             $this$forEach$iv = $this$forEach$iv2;\n                             z3 = z4;\n                             it = it2;\n                             $this$inTransaction = $this$inTransaction2;\n                         } catch (Throwable th7) {\n                             e$iv = th7;\n                             throw e$iv;\n                         }\n                     }\n                     AsyncTask.SERIAL_EXECUTOR.execute(new d.c(list));\n                     t tVar = t.a;\n                     $this$use$iv.close();\n                 } catch (Throwable th8) {\n                     e$iv = th8;\n                 }\n             } catch (Throwable th9) {\n                 e$iv = th9;\n             }\n         } else {\n             try {\n                 a.a().set(true);\n                 db.beginTransaction();\n                 SQLiteDatabase $this$inTransaction3 = db;\n                 boolean z5 = false;\n                 Cursor $this$use$iv2 = $this$inTransaction3.rawQuery(\"\\n              SELECT\\n              id,\\n              object\\n              FROM heap_analysis\\n              \", null);\n                 q.c($this$use$iv2, \"rawQuery(\\n        \\\"\\\"\\\"\\n  …        \\\"\\\"\\\", null\\n      )\");\n                 try {\n                     ArrayList arrayList = new ArrayList();\n                     while ($this$use$iv2.moveToNext()) {\n                         SQLiteDatabase $this$inTransaction4 = $this$inTransaction3;\n                         try {\n                             long id3 = $this$use$iv2.getLong(0);\n                             b0 b0Var2 = b0.a;\n                             boolean z6 = z5;\n                             try {\n                                 byte[] byteArray$iv2 = $this$use$iv2.getBlob(1);\n                                 q.c(byteArray$iv2, \"cursor.getBlob(1)\");\n                                 ByteArrayInputStream inputStream$iv2 = new ByteArrayInputStream(byteArray$iv2);\n                                 try {\n                                     try {\n                                         Object readObject2 = new ObjectInputStream(inputStream$iv2).readObject();\n                                         if (!(readObject2 instanceof m)) {\n                                             readObject2 = null;\n                                         }\n                                         analysis = (m) readObject2;\n                                     } catch (Throwable th10) {\n                                         ignored$iv = th10;\n                                         a1 this_$iv$iv2 = a1.b;\n                                         a1.a logger$iv$iv2 = this_$iv$iv2.a();\n                                         if (logger$iv$iv2 != null) {\n                                             logger$iv$iv2.b(ignored$iv, \"Could not deserialize bytes, ignoring\");\n                                         }\n                                         analysis = null;\n                                         if (analysis == null) {\n                                         }\n                                         $this$inTransaction3 = $this$inTransaction4;\n                                         z5 = z6;\n                                     }\n                                 } catch (Throwable th11) {\n                                     ignored$iv = th11;\n                                 }\n                                 if (analysis == null) {\n                                     arrayList.add(r.a(Long.valueOf(id3), analysis));\n                                 }\n                                 $this$inTransaction3 = $this$inTransaction4;\n                                 z5 = z6;\n                             } catch (Throwable th12) {\n                                 e$iv = th12;\n                                 throw e$iv;\n                             }\n                         } catch (Throwable th13) {\n                             e$iv = th13;\n                             throw e$iv;\n                         }\n                     }\n                     Iterable $this$forEach$iv3 = arrayList;\n                     boolean z7 = false;\n                     for (Iterator it3 = $this$forEach$iv3.iterator(); it3.hasNext(); it3 = it3) {\n                         Object element$iv2 = it3.next();\n                         l $dstr$id$_u24__u242 = (l) element$iv2;\n                         long id4 = ((Number) $dstr$id$_u24__u242.a()).longValue();\n                         db.delete(\"heap_analysis\", \"id=\" + id4, null);\n                         h.a.a(db, id4);\n                         $this$forEach$iv3 = $this$forEach$iv3;\n                         z7 = z7;\n                     }\n                     AsyncTask.SERIAL_EXECUTOR.execute(new d.c(arrayList));\n                     t tVar2 = t.a;\n                     $this$use$iv2.close();\n                     db.setTransactionSuccessful();\n                 } catch (Throwable th14) {\n                     e$iv = th14;\n                 }\n             } finally {\n                 db.endTransaction();\n                 a.a().set(false);\n             }\n         }\n         e();\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/b/d.java",
              "file_line": [
                387
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.886-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b07ce8a0-aefd-4efe-b2e3-21f157c7ca70",
              "value": "public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n         q.g(db, \"db\");\n         if (oldVersion < 19) {\n             b(db);\n         } else if (oldVersion != 19) {\n             if (oldVersion == 23) {\n                 db.execSQL(\"ALTER TABLE heap_analysis ADD COLUMN dump_duration_millis INTEGER DEFAULT -1\");\n                 return;\n             }\n             throw new IllegalStateException(\"Database migration from \" + oldVersion + \" not supported\");\n         } else {\n             Cursor $this$use$iv = db.rawQuery(\"SELECT object FROM heap_analysis\", null);\n             q.c($this$use$iv, \"db.rawQuery(\\\"SELECT obje…ROM heap_analysis\\\", null)\");\n             try {\n                 List allAnalysis = p.H(p.x(n.i(new j.b($this$use$iv)), j.c.a));\n                 $this$use$iv.close();\n                 b(db);\n                 ThreadLocal a = a.a();\n                 boolean z = a.get();\n                 if (z == null) {\n                     z = false;\n                     a.set(false);\n                 }\n                 if (((Boolean) z).booleanValue()) {\n                     for (Object element$iv : allAnalysis) {\n                         m it = (m) element$iv;\n                         d.b.d(db, it);\n                     }\n                     ContentValues $this$apply = new ContentValues();\n                     $this$apply.put(\"is_read\", (Integer) 1);\n                     t tVar = t.a;\n                     db.update(\"leak\", $this$apply, null, null);\n                     return;\n                 }\n                 try {\n                     a.a().set(true);\n                     db.beginTransaction();\n                     for (Object element$iv2 : allAnalysis) {\n                         m it2 = (m) element$iv2;\n                         d.b.d(db, it2);\n                     }\n                     ContentValues $this$apply2 = new ContentValues();\n                     $this$apply2.put(\"is_read\", (Integer) 1);\n                     t tVar2 = t.a;\n                     db.update(\"leak\", $this$apply2, null, null);\n                     db.setTransactionSuccessful();\n                 } finally {\n                     db.endTransaction();\n                     a.a().set(Boolean.valueOf(false));\n                 }\n             } catch (Throwable e$iv) {\n                 try {\n                     throw e$iv;\n                 } catch (Throwable e$iv2) {\n                     try {\n                         $this$use$iv.close();\n                     } catch (Throwable th) {\n                     }\n                     throw e$iv2;\n                 }\n             }\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/b/j.java",
              "file_line": [
                650
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.988-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e7840186-8561-4bda-82e4-7799602d6b1c",
              "value": "public void onCreate(SQLiteDatabase db) {\n         db.execSQL(\"CREATE TABLE IF NOT EXISTS store (key TEXT PRIMARY KEY NOT NULL, value TEXT);\");\n         db.execSQL(\"CREATE TABLE IF NOT EXISTS long_store (key TEXT PRIMARY KEY NOT NULL, value INTEGER);\");\n         db.execSQL(\"CREATE TABLE IF NOT EXISTS events (id INTEGER PRIMARY KEY AUTOINCREMENT, event TEXT);\");\n         db.execSQL(\"CREATE TABLE IF NOT EXISTS identifys (id INTEGER PRIMARY KEY AUTOINCREMENT, event TEXT);\");\n         f.e eVar = ((h) this).g;\n         if (eVar != null && ((h) this).f) {\n             try {\n                 try {\n                     ((h) this).f = false;\n                     eVar.a(db);\n                 } catch (SQLiteException e) {\n                     h.c.c(h.a, String.format(\"databaseReset callback failed during onCreate\", new Object[0]), e);\n                 }\n             } finally {\n                 ((h) this).f = true;\n             }\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/a/a/h.java",
              "file_line": [
                3569
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.592-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0ebd64f7-b783-4889-8c04-e89128029e65",
              "value": "private long getPageCount() {\n         return getDb().compileStatement(\"PRAGMA page_count\").simpleQueryForLong();\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java",
              "file_line": [
                221
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.653-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d221f867-f776-49b3-aa44-ad7c99bb534f",
              "value": "public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n         db.execSQL(\"DROP TABLE events\");\n         db.execSQL(\"DROP TABLE event_metadata\");\n         db.execSQL(\"DROP TABLE transport_contexts\");\n         db.execSQL(\"DROP TABLE IF EXISTS event_payloads\");\n         onCreate(db, newVersion);\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/datatransport/runtime/scheduling/persistence/SchemaManager.java",
              "file_line": [
                424
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.732-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4a080659-31e5-4a6b-b015-0e9d336bf114",
              "value": "public final void zzW(String str, long j, long j2, zzkm zzkmVar) {\n         Cursor cursor;\n         Cursor cursor2;\n         String str2;\n         Cursor cursor3;\n         String str3;\n         String str4;\n         String[] strArr;\n         Preconditions.checkNotNull(zzkmVar);\n         zzg();\n         zzY();\n         Cursor cursor4 = null;\n         r3 = null;\n         r3 = null;\n         r3 = null;\n         String str5 = null;\n         try {\n             try {\n                 SQLiteDatabase zzh = zzh();\n                 if (TextUtils.isEmpty(null)) {\n                     int i = (j2 > (-1L) ? 1 : (j2 == (-1L) ? 0 : -1));\n                     String[] strArr2 = i != 0 ? new String[]{String.valueOf(j2), String.valueOf(j)} : new String[]{String.valueOf(j)};\n                     str2 = i != 0 ? \"rowid <= ? and \" : \"\";\n                     StringBuilder sb = new StringBuilder(str2.length() + 148);\n                     sb.append(\"select app_id, metadata_fingerprint from raw_events where \");\n                     sb.append(str2);\n                     sb.append(\"app_id in (select app_id from apps where config_fetched_time >= ?) order by rowid limit 1;\");\n                     cursor = zzh.rawQuery(sb.toString(), strArr2);\n                     try {\n                         if (!cursor.moveToFirst()) {\n                             cursor.close();\n                             return;\n                         }\n                         str5 = cursor.getString(0);\n                         String string = cursor.getString(1);\n                         cursor.close();\n                         cursor3 = cursor;\n                         str3 = string;\n                     } catch (SQLiteException e) {\n                         e = e;\n                         ((zzgl) this).zzs.zzay().zzd().zzc(\"Data loss. Error selecting raw event. appId\", zzei.zzn(str5), e);\n                         if (cursor == null) {\n                         }\n                     } catch (Throwable th) {\n                         th = th;\n                         cursor4 = cursor;\n                         if (cursor4 != null) {\n                         }\n                         throw th;\n                     }\n                 } else {\n                     int i2 = (j2 > (-1L) ? 1 : (j2 == (-1L) ? 0 : -1));\n                     String[] strArr3 = i2 != 0 ? new String[]{null, String.valueOf(j2)} : new String[]{null};\n                     str2 = i2 != 0 ? \" and rowid <= ?\" : \"\";\n                     StringBuilder sb2 = new StringBuilder(str2.length() + 84);\n                     sb2.append(\"select metadata_fingerprint from raw_events where app_id = ?\");\n                     sb2.append(str2);\n                     sb2.append(\" order by rowid limit 1;\");\n                     cursor = zzh.rawQuery(sb2.toString(), strArr3);\n                     try {\n                         if (!cursor.moveToFirst()) {\n                             cursor.close();\n                             return;\n                         }\n                         String string2 = cursor.getString(0);\n                         cursor.close();\n                         cursor3 = cursor;\n                         str3 = string2;\n                     } catch (SQLiteException e2) {\n                         e = e2;\n                         ((zzgl) this).zzs.zzay().zzd().zzc(\"Data loss. Error selecting raw event. appId\", zzei.zzn(str5), e);\n                         if (cursor == null) {\n                             cursor.close();\n                             return;\n                         }\n                         return;\n                     }\n                 }\n                 try {\n                     Cursor query = zzh.query(\"raw_events_metadata\", new String[]{\"metadata\"}, \"app_id = ? and metadata_fingerprint = ?\", new String[]{str5, str3}, null, null, \"rowid\", \"2\");\n                     try {\n                         if (!query.moveToFirst()) {\n                             ((zzgl) this).zzs.zzay().zzd().zzb(\"Raw event metadata record is missing. appId\", zzei.zzn(str5));\n                             query.close();\n                             return;\n                         }\n                         try {\n                             try {\n                                 zzfy zzaA = zzkp.zzl(zzfy.zzu(), query.getBlob(0)).zzaA();\n                                 if (query.moveToNext()) {\n                                     ((zzgl) this).zzs.zzay().zzk().zzb(\"Get multiple raw event metadata records, expected one. appId\", zzei.zzn(str5));\n                                 }\n                                 query.close();\n                                 Preconditions.checkNotNull(zzaA);\n                                 zzkmVar.zza = zzaA;\n                                 if (j2 != -1) {\n                                     str4 = \"app_id = ? and metadata_fingerprint = ? and rowid <= ?\";\n                                     strArr = new String[]{str5, str3, String.valueOf(j2)};\n                                 } else {\n                                     str4 = \"app_id = ? and metadata_fingerprint = ?\";\n                                     strArr = new String[]{str5, str3};\n                                 }\n                                 cursor = zzh.query(\"raw_events\", new String[]{\"rowid\", \"name\", \"timestamp\", \"data\"}, str4, strArr, null, null, \"rowid\", null);\n                                 try {\n                                     if (!cursor.moveToFirst()) {\n                                         ((zzgl) this).zzs.zzay().zzk().zzb(\"Raw event data disappeared while in transaction. appId\", zzei.zzn(str5));\n                                         cursor.close();\n                                         return;\n                                     }\n                                     do {\n                                         long j3 = cursor.getLong(0);\n                                         try {\n                                             zzfn zzl = zzkp.zzl(zzfo.zze(), cursor.getBlob(3));\n                                             zzl.zzi(cursor.getString(1));\n                                             zzl.zzm(cursor.getLong(2));\n                                             if (!zzkmVar.zza(j3, zzl.zzaA())) {\n                                                 cursor.close();\n                                                 return;\n                                             }\n                                         } catch (IOException e3) {\n                                             ((zzgl) this).zzs.zzay().zzd().zzc(\"Data loss. Failed to merge raw event. appId\", zzei.zzn(str5), e3);\n                                         }\n                                     } while (cursor.moveToNext());\n                                     cursor.close();\n                                 } catch (SQLiteException e4) {\n                                     e = e4;\n                                     ((zzgl) this).zzs.zzay().zzd().zzc(\"Data loss. Error selecting raw event. appId\", zzei.zzn(str5), e);\n                                     if (cursor == null) {\n                                     }\n                                 } catch (Throwable th2) {\n                                     th = th2;\n                                     cursor4 = cursor;\n                                     if (cursor4 != null) {\n                                         cursor4.close();\n                                     }\n                                     throw th;\n                                 }\n                             } catch (IOException e5) {\n                                 ((zzgl) this).zzs.zzay().zzd().zzc(\"Data loss. Failed to merge raw event metadata. appId\", zzei.zzn(str5), e5);\n                                 query.close();\n                             }\n                         } catch (SQLiteException e6) {\n                             e = e6;\n                             cursor = query;\n                             ((zzgl) this).zzs.zzay().zzd().zzc(\"Data loss. Error selecting raw event. appId\", zzei.zzn(str5), e);\n                             if (cursor == null) {\n                             }\n                         } catch (Throwable th3) {\n                             th = th3;\n                             cursor4 = query;\n                             if (cursor4 != null) {\n                             }\n                             throw th;\n                         }\n                     } catch (SQLiteException e7) {\n                         e = e7;\n                     } catch (Throwable th4) {\n                         th = th4;\n                     }\n                 } catch (SQLiteException e8) {\n                     e = e8;\n                     cursor = cursor3;\n                 } catch (Throwable th5) {\n                     th = th5;\n                     cursor4 = cursor3;\n                 }\n             } catch (Throwable th6) {\n                 th = th6;\n                 cursor4 = cursor2;\n             }\n         } catch (SQLiteException e9) {\n             e = e9;\n             cursor = null;\n         } catch (Throwable th7) {\n             th = th7;\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/measurement/internal/zzaj.java",
              "file_line": [
                4415
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.789-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "99710eb2-83e6-4f8f-913d-2752cbe73923",
              "value": "public synchronized long E() {\n         long timestamp;\n         String tName = b.b.g.b();\n         Cursor cursor = null;\n         timestamp = 0;\n         try {\n             try {\n                 SQLiteDatabase db = ((b) this).r.getReadableDatabase();\n                 cursor = db.query(tName, null, null, null, null, null, \"created_at DESC\", \"1\");\n                 if (cursor != null) {\n                     try {\n                         if (cursor.moveToFirst()) {\n                             timestamp = cursor.getLong(cursor.getColumnIndex(\"created_at\"));\n                         }\n                     } catch (SQLiteException e) {\n                         e = e;\n                         c0 C = C();\n                         C.u(\"Could not fetch records out of database \" + tName + \".\", e);\n                         ((b) this).r.close();\n                         if (cursor != null) {\n                             cursor.close();\n                         }\n                         return timestamp;\n                     } catch (Throwable th) {\n                         th = th;\n                         ((b) this).r.close();\n                         if (cursor != null) {\n                             cursor.close();\n                         }\n                         throw th;\n                     }\n                 }\n                 ((b) this).r.close();\n                 if (cursor != null) {\n                     cursor.close();\n                 }\n             } catch (Throwable th2) {\n                 th = th2;\n             }\n         } catch (SQLiteException e2) {\n             e = e2;\n         }\n         return timestamp;\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/j0/b.java",
              "file_line": [
                1382
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.143-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1611bb26-814f-4509-af30-8a1624f6b240",
              "value": "private long ensureTransportContext(SQLiteDatabase db, TransportContext transportContext) {\n         Long existingId = getTransportContextId(db, transportContext);\n         if (existingId != null) {\n             return existingId.longValue();\n         }\n         ContentValues record = new ContentValues();\n         record.put(\"backend_name\", transportContext.getBackendName());\n         record.put(\"priority\", Integer.valueOf(PriorityMapping.toInt(transportContext.getPriority())));\n         record.put(\"next_request_ms\", (Integer) 0);\n         if (transportContext.getExtras() != null) {\n             record.put(\"extras\", Base64.encodeToString(transportContext.getExtras(), 0));\n         }\n         return db.insert(\"transport_contexts\", null, record);\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java",
              "file_line": [
                204
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.290-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e0ecca52-6573-495f-bb13-322df5b15e46",
              "value": "public final synchronized long U(String table, long n) {\n         long nthEventId;\n         nthEventId = -1;\n         SQLiteStatement statement = null;\n         try {\n             try {\n                 SQLiteDatabase db = getReadableDatabase();\n                 String query = \"SELECT id FROM \" + table + \" LIMIT 1 OFFSET \" + (n - 1);\n                 statement = db.compileStatement(query);\n                 nthEventId = -1;\n             } catch (Throwable th) {\n                 th = th;\n             }\n         } catch (SQLiteException e) {\n             e = e;\n         } catch (StackOverflowError e2) {\n             e = e2;\n         }\n         try {\n             nthEventId = statement.simpleQueryForLong();\n         } catch (SQLiteDoneException e3) {\n             h.c.h(h.a, e3);\n         } catch (SQLiteException e4) {\n             e = e4;\n             h.c.c(h.a, String.format(\"getNthEventId from %s failed\", table), e);\n             m();\n             if (statement != null) {\n                 statement.close();\n             }\n             close();\n             return nthEventId;\n         } catch (StackOverflowError e5) {\n             e = e5;\n             h.c.c(h.a, String.format(\"getNthEventId from %s failed\", table), e);\n             m();\n             if (statement != null) {\n                 statement.close();\n             }\n             close();\n             return nthEventId;\n         } catch (Throwable th2) {\n             th = th2;\n             if (statement != null) {\n                 statement.close();\n             }\n             close();\n             throw th;\n         }\n         if (statement != null) {\n             statement.close();\n         }\n         close();\n         return nthEventId;\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/a/a/h.java",
              "file_line": [
                1151
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.487-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9d3aafa1-12a5-452a-a765-83a1e9f545e6",
              "value": "public long getNextCallTime(TransportContext transportContext) {\n         return ((Long) SQLiteEventStore.tryWithCursor(getDb().rawQuery(\"SELECT next_request_ms FROM transport_contexts WHERE backend_name = ? and priority = ?\", new String[]{transportContext.getBackendName(), String.valueOf(PriorityMapping.toInt(transportContext.getPriority()))}), n.a)).longValue();\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java",
              "file_line": [
                2514
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.704-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7b3d8f32-f6f1-44f7-9711-51cc830a42f3",
              "value": "public final Bundle zzi(String str) {\n         Cursor cursor;\n         zzg();\n         zzY();\n         Cursor cursor2 = null;\n         try {\n             cursor = zzh().rawQuery(\"select parameters from default_event_params where app_id=?\", new String[]{str});\n         } catch (SQLiteException e) {\n             e = e;\n             cursor = null;\n         } catch (Throwable th) {\n             th = th;\n         }\n         try {\n             if (!cursor.moveToFirst()) {\n                 ((zzgl) this).zzs.zzay().zzj().zza(\"Default event parameters not found\");\n                 cursor.close();\n                 return null;\n             }\n             try {\n                 zzfo zzaA = zzkp.zzl(zzfo.zze(), cursor.getBlob(0)).zzaA();\n                 ((zzkc) this).zzf.zzu();\n                 List<zzfs> zzi = zzaA.zzi();\n                 Bundle bundle = new Bundle();\n                 for (zzfs zzfsVar : zzi) {\n                     String zzg = zzfsVar.zzg();\n                     if (zzfsVar.zzu()) {\n                         bundle.putDouble(zzg, zzfsVar.zza());\n                     } else if (zzfsVar.zzv()) {\n                         bundle.putFloat(zzg, zzfsVar.zzb());\n                     } else if (zzfsVar.zzy()) {\n                         bundle.putString(zzg, zzfsVar.zzh());\n                     } else if (zzfsVar.zzw()) {\n                         bundle.putLong(zzg, zzfsVar.zzd());\n                     }\n                 }\n                 cursor.close();\n                 return bundle;\n             } catch (IOException e2) {\n                 ((zzgl) this).zzs.zzay().zzd().zzc(\"Failed to retrieve default event parameters. appId\", zzei.zzn(str), e2);\n                 cursor.close();\n                 return null;\n             }\n         } catch (SQLiteException e3) {\n             e = e3;\n             try {\n                 ((zzgl) this).zzs.zzay().zzd().zzb(\"Error selecting default event parameters\", e);\n                 if (cursor != null) {\n                     cursor.close();\n                 }\n                 return null;\n             } catch (Throwable th2) {\n                 th = th2;\n                 cursor2 = cursor;\n                 if (cursor2 != null) {\n                     cursor2.close();\n                 }\n                 throw th;\n             }\n         } catch (Throwable th3) {\n             th = th3;\n             cursor2 = cursor;\n             if (cursor2 != null) {\n             }\n             throw th;\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/measurement/internal/zzaj.java",
              "file_line": [
                5672
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.831-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2dba1550-e580-4504-80da-7b0f3f7650c7",
              "value": "if (r14 == null) goto L64;\n      */\n     \n     public final zzfo zza(String str, zzfo zzfoVar) {\n         Cursor cursor;\n         Cursor cursor2;\n         Pair pair;\n         Object obj;\n         String zzh = zzfoVar.zzh();\n         List zzi = zzfoVar.zzi();\n         ((zzkc) ((zzv) this).zza).zzf.zzu();\n         Long l = (Long) zzkp.zzD(zzfoVar, \"_eid\");\n         if (l != null) {\n             if (zzh.equals(\"_ep\")) {\n                 Preconditions.checkNotNull(l);\n                 ((zzkc) ((zzv) this).zza).zzf.zzu();\n                 String str2 = (String) zzkp.zzD(zzfoVar, \"_en\");\n                 if (TextUtils.isEmpty(str2)) {\n                     ((zzgl) ((zzv) this).zza).zzs.zzay().zzh().zzb(\"Extra parameter without an event name. eventId\", l);\n                     return null;\n                 }\n                 if (((zzv) this).zzb == null || ((zzv) this).zzc == null || l.longValue() != ((zzv) this).zzc.longValue()) {\n                     zzaj zzi2 = ((zzkc) ((zzv) this).zza).zzf.zzi();\n                     zzi2.zzg();\n                     zzi2.zzY();\n                     try {\n                         cursor2 = zzi2.zzh().rawQuery(\"select main_event, children_to_process from main_event_params where app_id=? and event_id=?\", new String[]{str, String.valueOf(l)});\n                         try {\n                             if (cursor2.moveToFirst()) {\n                                 try {\n                                     pair = Pair.create(zzkp.zzl(zzfo.zze(), cursor2.getBlob(0)).zzaA(), Long.valueOf(cursor2.getLong(1)));\n                                     cursor2.close();\n                                 } catch (IOException e) {\n                                     ((zzgl) zzi2).zzs.zzay().zzd().zzd(\"Failed to merge main event. appId, eventId\", zzei.zzn(str), l, e);\n                                     cursor2.close();\n                                     pair = null;\n                                     if (pair != null) {\n                                     }\n                                     ((zzgl) ((zzv) this).zza).zzs.zzay().zzh().zzc(\"Extra parameter without existing main event. eventName, eventId\", str2, l);\n                                     return null;\n                                 }\n                             } else {\n                                 ((zzgl) zzi2).zzs.zzay().zzj().zza(\"Main event not found\");\n                                 cursor2.close();\n                                 pair = null;\n                             }\n                         } catch (SQLiteException e2) {\n                             e = e2;\n                             try {\n                                 ((zzgl) zzi2).zzs.zzay().zzd().zzb(\"Error selecting main event\", e);\n                             } catch (Throwable th) {\n                                 th = th;\n                                 cursor = cursor2;\n                                 if (cursor != null) {\n                                     cursor.close();\n                                 }\n                                 throw th;\n                             }\n                         } catch (Throwable th2) {\n                             th = th2;\n                             cursor = cursor2;\n                             if (cursor != null) {\n                             }\n                             throw th;\n                         }\n                     } catch (SQLiteException e3) {\n                         e = e3;\n                         cursor2 = null;\n                     } catch (Throwable th3) {\n                         th = th3;\n                         cursor = null;\n                     }\n                     if (pair != null || (obj = pair.first) == null) {\n                         ((zzgl) ((zzv) this).zza).zzs.zzay().zzh().zzc(\"Extra parameter without existing main event. eventName, eventId\", str2, l);\n                         return null;\n                     }\n                     ((zzv) this).zzb = (zzfo) obj;\n                     ((zzv) this).zzd = ((Long) pair.second).longValue();\n                     ((zzkc) ((zzv) this).zza).zzf.zzu();\n                     ((zzv) this).zzc = (Long) zzkp.zzD(((zzv) this).zzb, \"_eid\");\n                 }\n                 long j = ((zzv) this).zzd - 1;\n                 ((zzv) this).zzd = j;\n                 if (j <= 0) {\n                     zzaj zzi3 = ((zzkc) ((zzv) this).zza).zzf.zzi();\n                     zzi3.zzg();\n                     ((zzgl) zzi3).zzs.zzay().zzj().zzb(\"Clearing complex main event info. appId\", str);\n                     try {\n                         zzi3.zzh().execSQL(\"delete from main_event_params where app_id=?\", new String[]{str});\n                     } catch (SQLiteException e4) {\n                         ((zzgl) zzi3).zzs.zzay().zzd().zzb(\"Error clearing complex main event\", e4);\n                     }\n                 } else {\n                     ((zzkc) ((zzv) this).zza).zzf.zzi().zzL(str, l, ((zzv) this).zzd, ((zzv) this).zzb);\n                 }\n                 ArrayList arrayList = new ArrayList();\n                 for (zzfs zzfsVar : ((zzv) this).zzb.zzi()) {\n                     ((zzkc) ((zzv) this).zza).zzf.zzu();\n                     if (zzkp.zzC(zzfoVar, zzfsVar.zzg()) == null) {\n                         arrayList.add(zzfsVar);\n                     }\n                 }\n                 if (arrayList.isEmpty()) {\n                     ((zzgl) ((zzv) this).zza).zzs.zzay().zzh().zzb(\"No unique parameters in main event. eventName\", str2);\n                 } else {\n                     arrayList.addAll(zzi);\n                     zzi = arrayList;\n                 }\n                 zzh = str2;\n             } else {\n                 ((zzv) this).zzc = l;\n                 ((zzv) this).zzb = zzfoVar;\n                 ((zzkc) ((zzv) this).zza).zzf.zzu();\n                 Object zzD = zzkp.zzD(zzfoVar, \"_epc\");\n                 long longValue = ((Long) (zzD != null ? zzD : 0L)).longValue();\n                 ((zzv) this).zzd = longValue;\n                 if (longValue <= 0) {\n                     ((zzgl) ((zzv) this).zza).zzs.zzay().zzh().zzb(\"Complex event with zero extra param count. eventName\", zzh);\n                 } else {\n                     ((zzkc) ((zzv) this).zza).zzf.zzi().zzL(str, (Long) Preconditions.checkNotNull(l), ((zzv) this).zzd, zzfoVar);\n                 }\n             }\n         }\n         zzfn zzbv = zzfoVar.zzbv();\n         zzbv.zzi(zzh);\n         zzbv.zzg();\n         zzbv.zzd(zzi);\n         return zzbv.zzaA();\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/measurement/internal/zzv.java",
              "file_line": [
                191
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.855-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9e6ab4cc-cf86-48bf-b44a-0ceb756052ae",
              "value": "public final long b(SQLiteDatabase db, long heapAnalysisId, e0 leak) {\n         q.g(db, \"db\");\n         q.g(leak, \"leak\");\n         ContentValues values = new ContentValues();\n         values.put(\"signature\", leak.c());\n         values.put(\"short_description\", leak.b());\n         values.put(\"is_library_leak\", Integer.valueOf(leak instanceof j0 ? 1 : 0));\n         values.put(\"is_read\", (Integer) 0);\n         db.insertWithOnConflict(\"leak\", null, values, 4);\n         Cursor $this$use$iv = db.rawQuery(\"SELECT id from leak WHERE signature = '\" + leak.c() + \"' LIMIT 1\", null);\n         q.c($this$use$iv, \"db.rawQuery(\\\"SELECT id f…gnature}' LIMIT 1\\\", null)\");\n         try {\n             if ($this$use$iv.moveToFirst()) {\n                 long leakId = $this$use$iv.getLong(0);\n                 $this$use$iv.close();\n                 Iterable $this$forEachIndexed$iv = leak.a();\n                 int index = 0;\n                 for (Object item$iv : $this$forEachIndexed$iv) {\n                     int index$iv = index + 1;\n                     if (index >= 0) {\n                         f0 leakTrace = (f0) item$iv;\n                         i.a.b(db, leakId, heapAnalysisId, index, leakTrace.b().b());\n                         index = index$iv;\n                     } else {\n                         o.s();\n                         throw null;\n                     }\n                 }\n                 return leakId;\n             }\n             throw new IllegalStateException(\"No id found for leak with signature '\" + leak.c() + '\\'');\n         } catch (Throwable e$iv) {\n             try {\n                 throw e$iv;\n             } catch (Throwable e$iv2) {\n                 try {\n                     $this$use$iv.close();\n                 } catch (Throwable th) {\n                 }\n                 throw e$iv2;\n             }\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/b/h.java",
              "file_line": [
                179
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.921-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e67b7dee-0592-4b53-89a3-756311a52ce0",
              "value": "public void onCreate(SQLiteDatabase db) {\n         q.g(db, \"db\");\n         db.execSQL(\"CREATE TABLE heap_analysis\\n        (\\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\\n        created_at_time_millis INTEGER,\\n        dump_duration_millis INTEGER DEFAULT -1,\\n        leak_count INTEGER DEFAULT 0,\\n        exception_summary TEXT DEFAULT NULL,\\n        object BLOB\\n        )\");\n         db.execSQL(\"\\n        CREATE TABLE leak\\n        (\\n        id INTEGER PRIMARY KEY,\\n        signature TEXT UNIQUE,\\n        short_description TEXT,\\n        is_library_leak INTEGER,\\n        is_read INTEGER\\n        )\");\n         db.execSQL(\"\\n        CREATE INDEX leak_signature\\n        on leak (signature)\\n    \");\n         db.execSQL(\"\\n        CREATE TABLE leak_trace\\n        (\\n        id INTEGER PRIMARY KEY,\\n        heap_analysis_id REFERENCES heap_analysis(id),\\n        leak_id REFERENCES leak(id),\\n        class_simple_name TEXT,\\n        leak_trace_index INTEGER\\n        )\");\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/b/j.java",
              "file_line": [
                92
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.968-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "a3d95343-8ec2-4157-b7a8-f531ff041260",
              "value": "public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n         if (oldVersion > newVersion) {\n             h.c.b(h.a, \"onUpgrade() with invalid oldVersion and newVersion\");\n             o0(db);\n         } else if (newVersion <= 1) {\n         } else {\n             switch (oldVersion) {\n                 case 1:\n                     db.execSQL(\"CREATE TABLE IF NOT EXISTS store (key TEXT PRIMARY KEY NOT NULL, value TEXT);\");\n                     if (newVersion <= 2) {\n                         return;\n                     }\n                     break;\n                 case 2:\n                     break;\n                 case 3:\n                     return;\n                 default:\n                     g gVar = h.c;\n                     String str = h.a;\n                     gVar.b(str, \"onUpgrade() with unknown oldVersion \" + oldVersion);\n                     o0(db);\n                     return;\n             }\n             db.execSQL(\"CREATE TABLE IF NOT EXISTS identifys (id INTEGER PRIMARY KEY AUTOINCREMENT, event TEXT);\");\n             db.execSQL(\"CREATE TABLE IF NOT EXISTS long_store (key TEXT PRIMARY KEY NOT NULL, value INTEGER);\");\n             if (newVersion <= 3) {\n             }\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/a/a/h.java",
              "file_line": [
                3734
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.625-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e958fc6b-e69a-4df6-a984-33096b2f298d",
              "value": "public void onConfigure(SQLiteDatabase db) {\n         ((SchemaManager) this).configured = true;\n         db.rawQuery(\"PRAGMA busy_timeout=0;\", new String[0]).close();\n         db.setForeignKeyConstraintsEnabled(true);\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/datatransport/runtime/scheduling/persistence/SchemaManager.java",
              "file_line": [
                386
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.759-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0d9b934a-1acb-4d76-9b17-e8ae2a5a59e9",
              "value": "public final h.b e(SQLiteDatabase db, String signature) {\n         q.g(db, \"db\");\n         q.g(signature, \"signature\");\n         boolean z = true;\n         Cursor $this$use$iv = db.rawQuery(\"\\n          SELECT\\n          lt.leak_trace_index\\n          , lt.heap_analysis_id\\n          , lt.class_simple_name\\n          , h.created_at_time_millis\\n          , l.short_description\\n          , l.is_read\\n          , l.is_library_leak\\n          FROM leak_trace lt\\n          LEFT JOIN leak l on lt.leak_id = l.id\\n          LEFT JOIN heap_analysis h ON lt.heap_analysis_id = h.id\\n          WHERE l.signature = ?\\n          ORDER BY h.created_at_time_millis DESC\\n          \", new String[]{signature});\n         q.c($this$use$iv, \"db.rawQuery(\\n      \\\"\\\"\\\"\\n … arrayOf(signature)\\n    )\");\n         h.b bVar = null;\n         try {\n             if ($this$use$iv.moveToFirst()) {\n                 List leakTraces = new ArrayList();\n                 String string = $this$use$iv.getString(4);\n                 q.c(string, \"cursor.getString(4)\");\n                 boolean z2 = $this$use$iv.getInt(5) == 0;\n                 if ($this$use$iv.getInt(6) != 1) {\n                     z = false;\n                 }\n                 h.b leakProjection = new h.b(string, z2, z, leakTraces);\n                 t.B(leakTraces, p.x(n.h($this$use$iv, new h.d($this$use$iv)), new h.e($this$use$iv)));\n                 bVar = leakProjection;\n             }\n             $this$use$iv.close();\n             return bVar;\n         } catch (Throwable e$iv) {\n             try {\n                 throw e$iv;\n             } catch (Throwable e$iv2) {\n                 try {\n                     $this$use$iv.close();\n                 } catch (Throwable th) {\n                 }\n                 throw e$iv2;\n             }\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/b/h.java",
              "file_line": [
                855
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.940-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4829d7e5-559d-4ef8-a7ac-9313ea0083b5",
              "value": "public final void a(b.b bVar) {\n         q.g(bVar, \"$receiver\");\n         d dVar = d.b;\n         SQLiteDatabase b = bVar.b();\n         long c = e.c(((e.c) this).a);\n         p pVar = null;\n         Cursor rawQuery = b.rawQuery(\"\\n              SELECT\\n              object\\n              FROM heap_analysis\\n              WHERE id=\" + c + \"\\n              \", null);\n         q.c(rawQuery, \"db.rawQuery(\\n      \\\"\\\"\\\"\\n …          \\\"\\\"\\\", null\\n    )\");\n         try {\n             if (rawQuery.moveToNext()) {\n                 b0 b0Var = b0.a;\n                 byte[] blob = rawQuery.getBlob(0);\n                 q.c(blob, \"cursor.getBlob(0)\");\n                 Object readObject = new ObjectInputStream(new ByteArrayInputStream(blob)).readObject();\n                 if (!(readObject instanceof p)) {\n                     readObject = null;\n                 }\n                 p pVar2 = (p) readObject;\n                 if (pVar2 == null) {\n                     d.b.b(b, c, (File) null);\n                 }\n                 pVar = pVar2;\n             }\n             rawQuery.close();\n             if (pVar == null) {\n                 bVar.a(f.a);\n                 return;\n             }\n             bVar.a(new e.c.a(this, pVar, h.a.f(bVar.b(), j.g0.p.J(j.g0.p.x(pVar.f(), g.a))), pVar.c().exists()));\n         } catch (Throwable th) {\n             try {\n                 throw th;\n             } catch (Throwable th2) {\n                 try {\n                     rawQuery.close();\n                 } catch (Throwable th3) {\n                 }\n                 throw th2;\n             }\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/c/e$c.java",
              "file_line": [
                104
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.029-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7256f010-a038-4191-9999-5f3b2d53bad4",
              "value": "public Cursor h0(SQLiteDatabase db, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit) {\n         return db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/a/a/h.java",
              "file_line": [
                2664
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.079-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b33d1754-6ea3-4b0e-91e7-c0f1cef5b922",
              "value": "public synchronized JSONObject y(b.b table, int limit) {\n         String tName = table.b();\n         Cursor cursor = null;\n         String lastId = null;\n         JSONArray events = new JSONArray();\n         try {\n             try {\n                 SQLiteDatabase db = ((b) this).r.getReadableDatabase();\n                 cursor = db.query(tName, null, null, null, null, null, \"created_at ASC\", String.valueOf(limit));\n                 while (cursor.moveToNext()) {\n                     try {\n                         if (cursor.isLast()) {\n                             lastId = cursor.getString(cursor.getColumnIndex(\"_id\"));\n                         }\n                         try {\n                             JSONObject j = new JSONObject(cursor.getString(cursor.getColumnIndex(\"data\")));\n                             events.put(j);\n                         } catch (JSONException e) {\n                         }\n                     } catch (SQLiteException e2) {\n                         e = e2;\n                         c0 C = C();\n                         C.u(\"Could not fetch records out of database \" + tName + \".\", e);\n                         lastId = null;\n                         ((b) this).r.close();\n                         if (cursor != null) {\n                             cursor.close();\n                         }\n                         if (lastId != null) {\n                         }\n                         return null;\n                     } catch (Throwable th) {\n                         th = th;\n                         ((b) this).r.close();\n                         if (cursor != null) {\n                             cursor.close();\n                         }\n                         throw th;\n                     }\n                 }\n                 ((b) this).r.close();\n                 cursor.close();\n             } catch (SQLiteException e3) {\n                 e = e3;\n             }\n             if (lastId != null) {\n                 try {\n                     JSONObject ret = new JSONObject();\n                     ret.put(lastId, events);\n                     return ret;\n                 } catch (JSONException e4) {\n                 }\n             }\n             return null;\n         } catch (Throwable th2) {\n             th = th2;\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/j0/b.java",
              "file_line": [
                4399
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.164-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d0a88b1c-4c8c-470d-b534-744fff2282bc",
              "value": "public synchronized void I(String id) {\n         if (id == null) {\n             return;\n         }\n         String tableName = b.b.c.b();\n         try {\n             SQLiteDatabase db = ((b) this).r.getWritableDatabase();\n             db.delete(tableName, \"_id = ?\", new String[]{id});\n             ((b) this).r.close();\n         } catch (SQLiteException e) {\n             c0 C = C();\n             C.r(\"Error removing user profile from \" + tableName + \" Recreating DB\");\n             ((b) this).r.f();\n             ((b) this).r.close();\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/j0/b.java",
              "file_line": [
                2311
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.211-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b8baf36b-ecee-440b-9362-a9f10a86e916",
              "value": "public synchronized void L() {\n         b.a aVar;\n         if (!q()) {\n             C().r(\"There is not enough space left on the device to store data, data discarded\");\n             return;\n         }\n         String tableName = b.b.g.b();\n         try {\n             SQLiteDatabase db = ((b) this).r.getWritableDatabase();\n             ContentValues cv = new ContentValues();\n             cv.put(\"created_at\", Long.valueOf(System.currentTimeMillis()));\n             db.insert(tableName, null, cv);\n             aVar = ((b) this).r;\n         } catch (SQLiteException e) {\n             c0 C = C();\n             C.r(\"Error adding data to table \" + tableName + \" Recreating DB\");\n             ((b) this).r.f();\n             aVar = ((b) this).r;\n         }\n         aVar.close();\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/j0/b.java",
              "file_line": [
                2948
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.256-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ad2a2a35-6ebb-4b2a-90a4-adbba4873a6e",
              "value": "public final void a(b.b bVar) {\n         q.g(bVar, \"$receiver\");\n         d dVar = d.b;\n         SQLiteDatabase b = bVar.b();\n         long b2 = l.r.g0.c.b.b(((b.a) this).a);\n         n nVar = null;\n         Cursor rawQuery = b.rawQuery(\"\\n              SELECT\\n              object\\n              FROM heap_analysis\\n              WHERE id=\" + b2 + \"\\n              \", null);\n         q.c(rawQuery, \"db.rawQuery(\\n      \\\"\\\"\\\"\\n …          \\\"\\\"\\\", null\\n    )\");\n         try {\n             if (rawQuery.moveToNext()) {\n                 b0 b0Var = b0.a;\n                 byte[] blob = rawQuery.getBlob(0);\n                 q.c(blob, \"cursor.getBlob(0)\");\n                 Object readObject = new ObjectInputStream(new ByteArrayInputStream(blob)).readObject();\n                 if (!(readObject instanceof n)) {\n                     readObject = null;\n                 }\n                 n nVar2 = (n) readObject;\n                 if (nVar2 == null) {\n                     d.b.b(b, b2, (File) null);\n                 }\n                 nVar = nVar2;\n             }\n             rawQuery.close();\n             if (nVar == null) {\n                 bVar.a(c.a);\n             } else {\n                 bVar.a(new b.a.a(this, nVar, nVar.c().exists()));\n             }\n         } catch (Throwable th) {\n             try {\n                 throw th;\n             } catch (Throwable th2) {\n                 try {\n                     rawQuery.close();\n                 } catch (Throwable th3) {\n                 }\n                 throw th2;\n             }\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/c/b$a.java",
              "file_line": [
                104
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.007-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "84b31c0e-a3ef-4855-a2f4-63282b15f85e",
              "value": "public final void a(b.b $this$executeOnDb) {\n         p pVar;\n         q.g($this$executeOnDb, \"$receiver\");\n         d dVar = d.b;\n         SQLiteDatabase db$iv = $this$executeOnDb.b();\n         long id$iv = ((j.d.a) this).b;\n         Cursor $this$use$iv$iv = db$iv.rawQuery(\"\\n              SELECT\\n              object\\n              FROM heap_analysis\\n              WHERE id=\" + id$iv + \"\\n              \", null);\n         q.c($this$use$iv$iv, \"db.rawQuery(\\n      \\\"\\\"\\\"\\n …          \\\"\\\"\\\", null\\n    )\");\n         try {\n             if ($this$use$iv$iv.moveToNext()) {\n                 try {\n                     b0 b0Var = b0.a;\n                     byte[] byteArray$iv$iv = $this$use$iv$iv.getBlob(0);\n                     q.c(byteArray$iv$iv, \"cursor.getBlob(0)\");\n                     ByteArrayInputStream inputStream$iv$iv = new ByteArrayInputStream(byteArray$iv$iv);\n                     try {\n                         try {\n                             Object readObject = new ObjectInputStream(inputStream$iv$iv).readObject();\n                             try {\n                                 if (!(readObject instanceof p)) {\n                                     readObject = null;\n                                 }\n                                 pVar = (p) readObject;\n                             } catch (Throwable th) {\n                                 ignored$iv$iv = th;\n                                 try {\n                                     a1 this_$iv$iv$iv = a1.b;\n                                     a1.a logger$iv$iv$iv = this_$iv$iv$iv.a();\n                                     if (logger$iv$iv$iv != null) {\n                                         try {\n                                             logger$iv$iv$iv.b(ignored$iv$iv, \"Could not deserialize bytes, ignoring\");\n                                         } catch (Throwable th2) {\n                                             ignored$iv$iv = th2;\n                                             try {\n                                                 throw ignored$iv$iv;\n                                             } catch (Throwable e$iv$iv) {\n                                                 try {\n                                                     $this$use$iv$iv.close();\n                                                 } catch (Throwable th3) {\n                                                 }\n                                                 throw e$iv$iv;\n                                             }\n                                         }\n                                     }\n                                     pVar = null;\n                                     if (pVar == null) {\n                                     }\n                                     $this$use$iv$iv.close();\n                                     if (pVar != null) {\n                                     }\n                                 } catch (Throwable th4) {\n                                     ignored$iv$iv = th4;\n                                     throw ignored$iv$iv;\n                                 }\n                             }\n                         } catch (Throwable th5) {\n                             ignored$iv$iv = th5;\n                         }\n                     } catch (Throwable th6) {\n                         ignored$iv$iv = th6;\n                     }\n                     if (pVar == null) {\n                         d.b.b(db$iv, id$iv, (File) null);\n                     }\n                 } catch (Throwable th7) {\n                     ignored$iv$iv = th7;\n                 }\n             } else {\n                 pVar = null;\n             }\n             $this$use$iv$iv.close();\n             if (pVar != null) {\n                 q.p();\n                 throw null;\n             }\n             p newSelectedHeapAnalysis = pVar;\n             $this$executeOnDb.a(new j.d.a.a(this, newSelectedHeapAnalysis));\n         } catch (Throwable th8) {\n             ignored$iv$iv = th8;\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/c/j$d$a.java",
              "file_line": [
                126
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.059-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "212d2ca8-f913-4fd6-a664-c90ed4483a6e",
              "value": "public synchronized long p(String table, String key) {\n         long result;\n         result = -1;\n         try {\n             try {\n                 SQLiteDatabase db = getWritableDatabase();\n                 result = db.delete(table, \"key=?\", new String[]{key});\n                 close();\n             } catch (SQLiteException e) {\n                 h.c.c(h.a, String.format(\"deleteKey from %s failed\", table), e);\n                 m();\n                 close();\n             }\n         } catch (StackOverflowError e2) {\n             h.c.c(h.a, String.format(\"deleteKey from %s failed\", table), e2);\n             m();\n             close();\n         }\n         return result;\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/a/a/h.java",
              "file_line": [
                3810
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.128-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "71a41cd6-800c-4281-af3b-41d3ce1d1cef",
              "value": "public synchronized void K(String id, long ttl) {\n         b.a aVar;\n         if (id == null) {\n             return;\n         }\n         if (!q()) {\n             C().r(\"There is not enough space left on the device to store data, data discarded\");\n             return;\n         }\n         String tableName = b.b.f.b();\n         if (ttl <= 0) {\n             ttl = System.currentTimeMillis() + 345600000;\n         }\n         try {\n             SQLiteDatabase db = ((b) this).r.getWritableDatabase();\n             ContentValues cv = new ContentValues();\n             cv.put(\"data\", id);\n             cv.put(\"created_at\", Long.valueOf(ttl));\n             cv.put(\"isRead\", (Integer) 0);\n             db.insert(tableName, null, cv);\n             ((b) this).s = true;\n             c0.n(\"Stored PN - \" + id + \" with TTL - \" + ttl);\n             aVar = ((b) this).r;\n         } catch (SQLiteException e) {\n             c0 C = C();\n             C.r(\"Error adding data to table \" + tableName + \" Recreating DB\");\n             ((b) this).r.f();\n             aVar = ((b) this).r;\n         }\n         aVar.close();\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/j0/b.java",
              "file_line": [
                2747
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.238-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b995be77-6403-484a-a919-813ad8f78568",
              "value": "public final synchronized void j0(String table, long id) {\n         try {\n             try {\n                 SQLiteDatabase db = getWritableDatabase();\n                 db.delete(table, \"id = \" + id, null);\n                 close();\n             } catch (StackOverflowError e) {\n                 h.c.c(h.a, String.format(\"removeEvent from %s failed\", table), e);\n                 m();\n                 close();\n             }\n         } catch (SQLiteException e2) {\n             h.c.c(h.a, String.format(\"removeEvent from %s failed\", table), e2);\n             m();\n             close();\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/a/a/h.java",
              "file_line": [
                2736
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.093-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0110ef96-873a-4dd2-b5f1-a6661a94d6b4",
              "value": "public final void a(SQLiteDatabase db, long heapAnalysisId) {\n         q.g(db, \"db\");\n         db.delete(\"leak_trace\", \"heap_analysis_id=\" + heapAnalysisId, null);\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/b/i.java",
              "file_line": [
                63
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.341-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ba9a963d-233e-40fc-8238-f0a94e78835b",
              "value": "public final synchronized void l0(String table, long maxId) {\n         try {\n             try {\n                 SQLiteDatabase db = getWritableDatabase();\n                 db.delete(table, \"id <= \" + maxId, null);\n                 close();\n             } catch (StackOverflowError e) {\n                 h.c.c(h.a, String.format(\"removeEvents from %s failed\", table), e);\n                 m();\n                 close();\n             }\n         } catch (SQLiteException e2) {\n             h.c.c(h.a, String.format(\"removeEvents from %s failed\", table), e2);\n             m();\n             close();\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/a/a/h.java",
              "file_line": [
                2927
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.108-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e7749b81-1580-42db-b69c-da98cf618e22",
              "value": "public synchronized void H(b.b table) {\n         String tName = table.b();\n         try {\n             SQLiteDatabase db = ((b) this).r.getWritableDatabase();\n             db.delete(tName, null, null);\n             ((b) this).r.close();\n         } catch (SQLiteException e) {\n             c0 C = C();\n             C.r(\"Error removing all events from table \" + tName + \" Recreating DB\");\n             v();\n             ((b) this).r.close();\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/j0/b.java",
              "file_line": [
                2164
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.192-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "04483567-15c8-4ed9-bd0e-fe7c39aac12c",
              "value": "public final void r(b.b table, long expiration) {\n         long time = (System.currentTimeMillis() - expiration) / 1000;\n         String tName = table.b();\n         try {\n             try {\n                 SQLiteDatabase db = ((b) this).r.getWritableDatabase();\n                 db.delete(tName, \"created_at <= \" + time, null);\n             } catch (SQLiteException e) {\n                 c0 C = C();\n                 C.u(\"Error removing stale event records from \" + tName + \". Recreating DB.\", e);\n                 v();\n             }\n         } finally {\n             ((b) this).r.close();\n         }\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/j0/b.java",
              "file_line": [
                3851
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.224-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1149cd9c-5991-4855-ac44-b3fe83b84f9d",
              "value": "public final void b(SQLiteDatabase db, long heapAnalysisId, File heapDumpFile) {\n         q.g(db, \"db\");\n         if (heapDumpFile != null) {\n             AsyncTask.SERIAL_EXECUTOR.execute(new d.b(heapDumpFile));\n         }\n         ThreadLocal a = a.a();\n         boolean z = a.get();\n         if (z == null) {\n             z = false;\n             a.set(false);\n         }\n         if (!((Boolean) z).booleanValue()) {\n             try {\n                 a.a().set(true);\n                 db.beginTransaction();\n                 db.delete(\"heap_analysis\", \"id=\" + heapAnalysisId, null);\n                 h.a.a(db, heapAnalysisId);\n                 t tVar = t.a;\n                 db.setTransactionSuccessful();\n             } finally {\n                 db.endTransaction();\n                 a.a().set(false);\n             }\n         } else {\n             db.delete(\"heap_analysis\", \"id=\" + heapAnalysisId, null);\n             h.a.a(db, heapAnalysisId);\n         }\n         e();\n     }",
              "vulnerability_id": "a74473ad-c78d-43b9-8c60-d26f92bf642e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/b/d.java",
              "file_line": [
                166
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.318-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
          "title": "External Result Receiver",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The vulnerability known as &quot;External Result Receiver&quot; in Android involves a significant security risk where exported components improperly handle ResultReceiver objects passed via intents. This issue allows external entities to send intents with ResultReceiver objects to the <b>Fake App</b> application, which could then be manipulated to execute unintended actions or retrieve sensitive information. The core vulnerability arises from the application&#39;s exported components, which do not adequately validate or restrict the incoming ResultReceiver objects, potentially leading to unauthorized access or control over the application&#39;s internal states and functionalities. This vulnerability underscores the need for strict validation and limitation of exported components in handling intent-based communications. \nThe following code snippet shows the insecure implementation</p>\n",
              "remediation": "<p>The assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Restrict Component Exportation: Modify the application's manifest to ensure that components intended to receive ResultReceiver objects are not exported unless absolutely necessary. Use the android:exported=false attribute to prevent unintended external access.\n</li>\n<li>Implement Intent Validation: Enhance the validation process for incoming intents within the application. Verify any ResultReceiver received through intents to ensure it originates from a trusted source, and confirm that its usage aligns with secure and intended operational parameters.</li>\n</ul>\n",
              "impact": "<p>An attacker can exploit the &quot;External Result Receiver&quot; vulnerability to execute unintended actions within the application or access sensitive information by manipulating ResultReceiver objects sent via intents. This could lead to unauthorized actions being performed, such as altering application data or behavior, which might compromise the app’s functionality and user data security. The ability to intercept and modify these communications also raises concerns about the integrity and confidentiality of the data processed by the application, potentially leading to further security breaches within the system.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>La vulnerabilidad conocida como &quot;External Result Receiver&quot; en Android implica un riesgo de seguridad significativo, ya que los componentes importados controlan inadecuadamente los objetos ResultReceiver que se envían a través de las intenciones. Este problema permite que entidades externas envíen intenciones con objetos ResultReceiver a la aplicación <b>Fake App</b>, que luego podrían manipularse para llevar a cabo acciones no deseadas o recuperar información sensible. La vulnerabilidad surge de los componentes exportados de la aplicación, que no validan o limitan adecuadamente los objetos ResultReceiver entrantes. Esto podría facilitar el acceso no autorizado y la pérdida de control de los estados y funcionamientos internos de la aplicación. Esta vulnerabilidad resalta la necesidad de una validación y limitación estrictas de los componentes exportados en la comunicación basada en intenciones.\nEl siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Restringir la exportación de componentes: modifique el manifiesto de la aplicación para garantizar que los componentes destinados a recibir objetos ResultReceiver no se exporten a menos que sea absolutamente necesario. Utilice el atributo android:exported=false para evitar el acceso externo no deseado.\n</li>\n<li>Implementar la validación de intenciones: mejore el proceso de validación de intenciones entrantes dentro de la aplicación. Verifique cualquier ResultReceiver recibido a través de intenciones para asegurarse de que provenga de una fuente confiable y confirmar que su uso se alinea con los parámetros operativos seguros previstos.</li>\n</ul>\n",
              "impact": "<p>Un atacante puede aprovechar la vulnerabilidad &quot;External Result Receiver&quot; para llevar a cabo acciones no deseadas dentro de la aplicación o acceder a información sensible manipulando objetos ResultReceiver enviados mediante intenciones. Esto podría dar lugar a que se realicen acciones no autorizadas, como alterar los datos o el comportamiento de la aplicación, y podría comprometer la funcionalidad de la aplicación y la seguridad de los datos de los usuarios. La capacidad de interceptar y modificar estas comunicaciones pone en riesgo la integridad y confidencialidad de los datos procesados por la aplicación y puede generar más violaciones de seguridad dentro del sistema.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "ResultReceiver | Android Developers",
              "url": "https://developer.android.com/reference/android/os/ResultReceiver#send(int,%20android.os.Bundle)"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0084"
          },
          "evidences": [
            {
              "id": "4f206474-1f51-4f33-96cd-7ab103487193",
              "value": "public boolean g(Intent mediaButtonEvent) {\n         MediaSessionCompat.d impl;\n         KeyEvent keyEvent;\n         if (Build.VERSION.SDK_INT >= 27 || (impl = (MediaSessionCompat.d) ((MediaSessionCompat.c) this).b.get()) == null || ((MediaSessionCompat.c) this).c == null || (keyEvent = (KeyEvent) mediaButtonEvent.getParcelableExtra(\"android.intent.extra.KEY_EVENT\")) == null || keyEvent.getAction() != 0) {\n             return false;\n         }\n         MediaSessionManager.RemoteUserInfo remoteUserInfo = impl.f();\n         int keyCode = keyEvent.getKeyCode();\n         switch (keyCode) {\n             case 79:\n             case 85:\n                 if (keyEvent.getRepeatCount() > 0) {\n                     a(remoteUserInfo);\n                 } else if (((MediaSessionCompat.c) this).d) {\n                     ((MediaSessionCompat.c) this).c.removeMessages(1);\n                     ((MediaSessionCompat.c) this).d = false;\n                     PlaybackStateCompat state = impl.b();\n                     long validActions = state == null ? 0L : state.b();\n                     if ((32 & validActions) != 0) {\n                         y();\n                     }\n                 } else {\n                     ((MediaSessionCompat.c) this).d = true;\n                     MediaSessionCompat.c.a aVar = ((MediaSessionCompat.c) this).c;\n                     aVar.sendMessageDelayed(aVar.obtainMessage(1, remoteUserInfo), ViewConfiguration.getDoubleTapTimeout());\n                 }\n                 return true;\n             default:\n                 a(remoteUserInfo);\n                 return false;\n         }\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaSessionCompat$c.java",
              "file_line": [
                420
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.613-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "29a5a205-96cf-4040-b915-3e2fbefefa9f",
              "value": "public boolean onActivityResult(int resultCode, Intent data) {\n         if (data.hasExtra(\"error\")) {\n             FacebookRequestError error = data.getParcelableExtra(\"error\");\n             ((DeviceShareDialog.1) this).val$callback.onError(error.getException());\n             return true;\n         }\n         ((DeviceShareDialog.1) this).val$callback.onSuccess(new DeviceShareDialog.Result());\n         return true;\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/share/DeviceShareDialog$1.java",
              "file_line": [
                60
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.796-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8a6eb048-4367-4762-b9e7-161ca37d171a",
              "value": "public static KeyEvent handleIntent(MediaSessionCompat mediaSessionCompat, Intent intent) {\n         if (mediaSessionCompat == null || intent == null || !\"android.intent.action.MEDIA_BUTTON\".equals(intent.getAction()) || !intent.hasExtra(\"android.intent.extra.KEY_EVENT\")) {\n             return null;\n         }\n         KeyEvent ke = (KeyEvent) intent.getParcelableExtra(\"android.intent.extra.KEY_EVENT\");\n         MediaControllerCompat mediaController = mediaSessionCompat.b();\n         mediaController.a(ke);\n         return ke;\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/media/session/MediaButtonReceiver.java",
              "file_line": [
                383
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.677-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "64af15bc-aff3-4993-8e30-051a1aa1375b",
              "value": "public static String getCreatorPackageName(Intent intent) {\n         PendingIntent pendingIntent = (PendingIntent) intent.getParcelableExtra(\"androidx.browser.browseractions.APP_ID\");\n         if (pendingIntent != null) {\n             return pendingIntent.getCreatorPackage();\n         }\n         return null;\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/browser/browseractions/BrowserActionsIntent.java",
              "file_line": [
                144
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.628-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3ed77bbc-9f61-4578-862c-c0c09f397d21",
              "value": "public void onReceive(Context context, Intent intent) {\n         if (\"com.facebook.sdk.ACTION_CURRENT_PROFILE_CHANGED\".equals(intent.getAction())) {\n             Profile oldProfile = intent.getParcelableExtra(\"com.facebook.sdk.EXTRA_OLD_PROFILE\");\n             Profile newProfile = intent.getParcelableExtra(\"com.facebook.sdk.EXTRA_NEW_PROFILE\");\n             ((ProfileTracker.ProfileBroadcastReceiver) this).this$0.onCurrentProfileChanged(oldProfile, newProfile);\n         }\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/ProfileTracker$ProfileBroadcastReceiver.java",
              "file_line": [
                67
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.733-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5504fd96-c79b-4d09-afc2-7438b0ce6400",
              "value": "public boolean onActivityResult(int resultCode, Intent data) {\n         if (data != null && data.hasExtra(\"error\")) {\n             FacebookRequestError error = data.getParcelableExtra(\"error\");\n             ((FriendFinderDialog.2) this).val$callback.onError(error.getException());\n             return true;\n         }\n         ((FriendFinderDialog.2) this).val$callback.onSuccess(new FriendFinderDialog.Result());\n         return true;\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/gamingservices/FriendFinderDialog$2.java",
              "file_line": [
                62
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.750-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3e45e95c-9f20-44da-9bb2-c965f5d61e27",
              "value": "public void onActivityResult(int requestCode, int resultCode, Intent data) {\n         super.onActivityResult(requestCode, resultCode, data);\n         switch (requestCode) {\n             case 10:\n                 if (resultCode == 0) {\n                     Log.d(CardIOActivity.b, \"ignoring onActivityResult(RESULT_CANCELED) caused only when Camera Permissions are Denied in Android 23\");\n                     return;\n                 } else if (resultCode == CardIOActivity.RESULT_CARD_INFO || resultCode == CardIOActivity.RESULT_ENTRY_CANCELED || ((CardIOActivity) this).z) {\n                     if (data != null && data.hasExtra(\"io.card.payment.scanResult\")) {\n                         String str = CardIOActivity.b;\n                         Log.v(str, \"EXTRA_SCAN_RESULT: \" + data.getParcelableExtra(\"io.card.payment.scanResult\"));\n                     } else {\n                         Log.d(CardIOActivity.b, \"no data in EXTRA_SCAN_RESULT\");\n                     }\n                     u(resultCode, data);\n                     return;\n                 } else {\n                     RelativeLayout relativeLayout = ((CardIOActivity) this).v;\n                     if (relativeLayout != null) {\n                         relativeLayout.setVisibility(0);\n                         return;\n                     }\n                     return;\n                 }\n             default:\n                 return;\n         }\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/io/card/payment/CardIOActivity.java",
              "file_line": [
                1281
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.890-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "15343fa6-d6bc-4bfe-a78b-d598f69c7114",
              "value": "public void c(String command, Bundle extras, ResultReceiver cb) {\n         try {\n             if (command.equals(\"android.support.v4.media.session.command.GET_EXTRA_BINDER\")) {\n                 MediaSessionCompat.e impl = (MediaSessionCompat.e) ((MediaSessionCompat.c.b) this).a.b.get();\n                 if (impl != null) {\n                     Bundle result = new Bundle();\n                     MediaSessionCompat.Token token = impl.a();\n                     b extraBinder = token.c();\n                     BundleCompat.putBinder(result, \"android.support.v4.media.session.EXTRA_BINDER\", extraBinder == null ? null : extraBinder.asBinder());\n                     Bundle token2Bundle = token.d();\n                     result.putBundle(\"android.support.v4.media.session.SESSION_TOKEN2_BUNDLE\", token2Bundle);\n                     cb.send(0, result);\n                 }\n             } else if (command.equals(\"android.support.v4.media.session.command.ADD_QUEUE_ITEM\")) {\n                 MediaSessionCompat.c cVar = ((MediaSessionCompat.c.b) this).a;\n                 extras.getParcelable(\"android.support.v4.media.session.command.ARGUMENT_MEDIA_DESCRIPTION\");\n                 cVar.b();\n             } else if (command.equals(\"android.support.v4.media.session.command.ADD_QUEUE_ITEM_AT\")) {\n                 MediaSessionCompat.c cVar2 = ((MediaSessionCompat.c.b) this).a;\n                 extras.getParcelable(\"android.support.v4.media.session.command.ARGUMENT_MEDIA_DESCRIPTION\");\n                 extras.getInt(\"android.support.v4.media.session.command.ARGUMENT_INDEX\");\n                 cVar2.c();\n             } else if (command.equals(\"android.support.v4.media.session.command.REMOVE_QUEUE_ITEM\")) {\n                 MediaSessionCompat.c cVar3 = ((MediaSessionCompat.c.b) this).a;\n                 extras.getParcelable(\"android.support.v4.media.session.command.ARGUMENT_MEDIA_DESCRIPTION\");\n                 cVar3.q();\n             } else if (command.equals(\"android.support.v4.media.session.command.REMOVE_QUEUE_ITEM_AT\")) {\n                 MediaSessionCompat.e impl2 = (MediaSessionCompat.e) ((MediaSessionCompat.c.b) this).a.b.get();\n                 if (impl2 != null) {\n                     Objects.requireNonNull(impl2);\n                 }\n             } else {\n                 ((MediaSessionCompat.c.b) this).a.d();\n             }\n         } catch (BadParcelableException e) {\n             Log.e(\"MediaSessionCompat\", \"Could not unparcel the extra data.\");\n         }\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaSessionCompat$c$b.java",
              "file_line": [
                149
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.593-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "40d6da0e-b77c-4368-9b51-0c4162fa586e",
              "value": "public void onConnected() {\n         try {\n             MediaControllerCompat mediaController = new MediaControllerCompat(((MediaButtonReceiver.MediaButtonConnectionCallback) this).mContext, ((MediaButtonReceiver.MediaButtonConnectionCallback) this).mMediaBrowser.c());\n             KeyEvent ke = (KeyEvent) ((MediaButtonReceiver.MediaButtonConnectionCallback) this).mIntent.getParcelableExtra(\"android.intent.extra.KEY_EVENT\");\n             mediaController.a(ke);\n         } catch (RemoteException e) {\n             Log.e(\"MediaButtonReceiver\", \"Failed to create a media controller\", e);\n         }\n         finish();\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/media/session/MediaButtonReceiver$MediaButtonConnectionCallback.java",
              "file_line": [
                93
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.647-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e8201bfa-7cfb-4737-a47a-ee86000bde94",
              "value": "public Fragment getFragment() {\n         Intent intent = getIntent();\n         FragmentManager manager = getSupportFragmentManager();\n         Fragment fragment = manager.findFragmentByTag(FacebookActivity.FRAGMENT_TAG);\n         if (fragment == null) {\n             if (\"FacebookDialogFragment\".equals(intent.getAction())) {\n                 FacebookDialogFragment dialogFragment = new FacebookDialogFragment();\n                 dialogFragment.setRetainInstance(true);\n                 dialogFragment.show(manager, FacebookActivity.FRAGMENT_TAG);\n                 return dialogFragment;\n             } else if (\"DeviceShareDialogFragment\".equals(intent.getAction())) {\n                 DeviceShareDialogFragment dialogFragment2 = new DeviceShareDialogFragment();\n                 dialogFragment2.setRetainInstance(true);\n                 dialogFragment2.setShareContent(intent.getParcelableExtra(\"content\"));\n                 dialogFragment2.show(manager, FacebookActivity.FRAGMENT_TAG);\n                 return dialogFragment2;\n             } else if (\"ReferralFragment\".equals(intent.getAction())) {\n                 ReferralFragment referralFragment = new ReferralFragment();\n                 referralFragment.setRetainInstance(true);\n                 manager.beginTransaction().add(R.id.com_facebook_fragment_container, referralFragment, FacebookActivity.FRAGMENT_TAG).commit();\n                 return referralFragment;\n             } else {\n                 LoginFragment loginFragment = new LoginFragment();\n                 loginFragment.setRetainInstance(true);\n                 manager.beginTransaction().add(R.id.com_facebook_fragment_container, loginFragment, FacebookActivity.FRAGMENT_TAG).commit();\n                 return loginFragment;\n             }\n         }\n         return fragment;\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/FacebookActivity.java",
              "file_line": [
                196
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.711-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b4e04a4c-5202-41f2-b47a-227fbf3ba713",
              "value": "private void finishActivity(int resultCode, Intent data) {\n         if (((DeviceShareDialogFragment) this).currentRequestState != null) {\n             DeviceRequestsHelper.cleanUpAdvertisementService(((DeviceShareDialogFragment) this).currentRequestState.getUserCode());\n         }\n         FacebookRequestError error = data.getParcelableExtra(\"error\");\n         if (error != null) {\n             Toast.makeText(getContext(), error.getErrorMessage(), 0).show();\n         }\n         if (isAdded()) {\n             FragmentActivity activity = getActivity();\n             activity.setResult(resultCode, data);\n             activity.finish();\n         }\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/share/internal/DeviceShareDialogFragment.java",
              "file_line": [
                138
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.822-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ce959a59-fee8-43fc-afe0-d11f078e993d",
              "value": "public void onReceive(Context context, Intent intent) {\n         SdkDependencyProvider sdkDependencyProvider = SdkDependencyProvider.INSTANCE;\n         if (!sdkDependencyProvider.isInitialized()) {\n             a.e(\"DeepLinkingBroadcastReceiver\", \"Cannot use Support SDK without initializing Zendesk. Call Zendesk.INSTANCE.init(...) and Support.INSTANCE.init(Zendesk)\", new Object[0]);\n             return;\n         }\n         sdkDependencyProvider.provideSupportSdkComponent().inject(this);\n         Intent requestIntent = (Intent) intent.getParcelableExtra(\"extra_request_intent\");\n         List<Intent> backStackActivities = intent.getParcelableArrayListExtra(\"extra_follow_up_activities\");\n         ((DeepLinkingBroadcastReceiver) this).deepLinkHelper.deepLinkToRequest(requestIntent, context, backStackActivities);\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/zendesk/support/DeepLinkingBroadcastReceiver.java",
              "file_line": [
                74
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.966-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d9024a6b-bc51-4c79-8579-d33e5b9e73ef",
              "value": "public void onReceive(Context context, Intent intent) {\n         if (\"com.facebook.sdk.ACTION_CURRENT_ACCESS_TOKEN_CHANGED\".equals(intent.getAction())) {\n             Utility.logd(AccessTokenTracker.access$100(), \"AccessTokenChanged\");\n             AccessToken oldAccessToken = intent.getParcelableExtra(\"com.facebook.sdk.EXTRA_OLD_ACCESS_TOKEN\");\n             AccessToken newAccessToken = intent.getParcelableExtra(\"com.facebook.sdk.EXTRA_NEW_ACCESS_TOKEN\");\n             ((AccessTokenTracker.CurrentAccessTokenBroadcastReceiver) this).this$0.onCurrentAccessTokenChanged(oldAccessToken, newAccessToken);\n         }\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/AccessTokenTracker$CurrentAccessTokenBroadcastReceiver.java",
              "file_line": [
                79
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.694-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "43b4f49f-5fe2-4bb9-97c9-278fa6cc0979",
              "value": "public boolean onActivityResult(int resultCode, Intent data) {\n         if (data != null && data.hasExtra(\"error\")) {\n             FacebookRequestError error = data.getParcelableExtra(\"error\");\n             ((GamingGroupIntegration.1) this).val$callback.onError(error.getException());\n             return true;\n         }\n         ((GamingGroupIntegration.1) this).val$callback.onSuccess(new GamingGroupIntegration.Result());\n         return true;\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/gamingservices/GamingGroupIntegration$1.java",
              "file_line": [
                62
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.775-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "58b92501-3684-4baa-bfd4-b05595b4b868",
              "value": "private final void zza(Message message) {\n         if (message != null) {\n             Object obj = message.obj;\n             if (obj instanceof Intent) {\n                 Intent intent = (Intent) obj;\n                 intent.setExtrasClassLoader(new zza.zza());\n                 if (intent.hasExtra(\"google.messenger\")) {\n                     zza parcelableExtra = intent.getParcelableExtra(\"google.messenger\");\n                     if (parcelableExtra instanceof zza) {\n                         ((Rpc) this).zzj = parcelableExtra;\n                     }\n                     if (parcelableExtra instanceof Messenger) {\n                         ((Rpc) this).zzi = (Messenger) parcelableExtra;\n                     }\n                 }\n                 Intent intent2 = (Intent) message.obj;\n                 String action = intent2.getAction();\n                 if (!\"com.google.android.c2dm.intent.REGISTRATION\".equals(action)) {\n                     if (Log.isLoggable(\"Rpc\", 3)) {\n                         String valueOf = String.valueOf(action);\n                         Log.d(\"Rpc\", valueOf.length() != 0 ? \"Unexpected response action: \".concat(valueOf) : new String(\"Unexpected response action: \"));\n                         return;\n                     }\n                     return;\n                 }\n                 String stringExtra = intent2.getStringExtra(\"registration_id\");\n                 if (stringExtra == null) {\n                     stringExtra = intent2.getStringExtra(\"unregistered\");\n                 }\n                 if (stringExtra == null) {\n                     String stringExtra2 = intent2.getStringExtra(\"error\");\n                     if (stringExtra2 == null) {\n                         String valueOf2 = String.valueOf(intent2.getExtras());\n                         StringBuilder sb = new StringBuilder(String.valueOf(valueOf2).length() + 49);\n                         sb.append(\"Unexpected response, no error or registration id \");\n                         sb.append(valueOf2);\n                         Log.w(\"Rpc\", sb.toString());\n                         return;\n                     }\n                     if (Log.isLoggable(\"Rpc\", 3)) {\n                         String valueOf3 = String.valueOf(stringExtra2);\n                         Log.d(\"Rpc\", valueOf3.length() != 0 ? \"Received InstanceID error \".concat(valueOf3) : new String(\"Received InstanceID error \"));\n                     }\n                     if (stringExtra2.startsWith(\"|\")) {\n                         String[] split = stringExtra2.split(\"\\\\|\");\n                         if (split.length <= 2 || !\"ID\".equals(split[1])) {\n                             String valueOf4 = String.valueOf(stringExtra2);\n                             Log.w(\"Rpc\", valueOf4.length() != 0 ? \"Unexpected structured response \".concat(valueOf4) : new String(\"Unexpected structured response \"));\n                             return;\n                         }\n                         String str = split[2];\n                         String str2 = split[3];\n                         if (str2.startsWith(\":\")) {\n                             str2 = str2.substring(1);\n                         }\n                         zza(str, intent2.putExtra(\"error\", str2).getExtras());\n                         return;\n                     }\n                     synchronized (((Rpc) this).zzd) {\n                         for (int i = 0; i < ((Rpc) this).zzd.size(); i++) {\n                             zza((String) ((Rpc) this).zzd.keyAt(i), intent2.getExtras());\n                         }\n                     }\n                     return;\n                 }\n                 Matcher matcher = Pattern.compile(\"\\\\|ID\\\\|([^|]+)\\\\|:?+(.*)\").matcher(stringExtra);\n                 if (!matcher.matches()) {\n                     if (Log.isLoggable(\"Rpc\", 3)) {\n                         String valueOf5 = String.valueOf(stringExtra);\n                         Log.d(\"Rpc\", valueOf5.length() != 0 ? \"Unexpected response string: \".concat(valueOf5) : new String(\"Unexpected response string: \"));\n                         return;\n                     }\n                     return;\n                 }\n                 String group = matcher.group(1);\n                 String group2 = matcher.group(2);\n                 if (group != null) {\n                     Bundle extras = intent2.getExtras();\n                     extras.putString(\"registration_id\", group2);\n                     zza(group, extras);\n                     return;\n                 }\n                 return;\n             }\n         }\n         Log.w(\"Rpc\", \"Dropping invalid message\");\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/cloudmessaging/Rpc.java",
              "file_line": [
                371
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.852-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "cb0e29d7-9946-4318-812d-094434013fa5",
              "value": "public void onCreate(Bundle savedInstanceState) {\n         int i;\n         int i2;\n         String str;\n         RelativeLayout container;\n         String str2;\n         super.onCreate(savedInstanceState);\n         if (getIntent().getExtras() == null) {\n             onBackPressed();\n             return;\n         }\n         boolean booleanExtra = getIntent().getBooleanExtra(\"io.card.payment.keepApplicationTheme\", false);\n         ((DataEntryActivity) this).y = booleanExtra;\n         a.f(this, booleanExtra);\n         ((DataEntryActivity) this).z = new TextView(this).getTextColors().getDefaultColor();\n         a.d();\n         ((DataEntryActivity) this).x = \"12dip\";\n         b.c(getIntent());\n         int paddingPx = c.h(\"4dip\", this);\n         RelativeLayout container2 = new RelativeLayout(this);\n         if (!((DataEntryActivity) this).y) {\n             container2.setBackgroundColor(i.a.a.p.b.i);\n         }\n         ScrollView scrollView = new ScrollView(this);\n         int i3 = ((DataEntryActivity) this).a;\n         ((DataEntryActivity) this).a = i3 + 1;\n         scrollView.setId(i3);\n         RelativeLayout.LayoutParams scrollParams = new RelativeLayout.LayoutParams(-1, -2);\n         scrollParams.addRule(10);\n         container2.addView(scrollView, scrollParams);\n         LinearLayout wrapperLayout = new LinearLayout(this);\n         wrapperLayout.setOrientation(1);\n         scrollView.addView(wrapperLayout, -1, -1);\n         LinearLayout mainLayout = new LinearLayout(this);\n         mainLayout.setOrientation(1);\n         LinearLayout.LayoutParams mainParams = new LinearLayout.LayoutParams(-1, -1);\n         ((DataEntryActivity) this).v = getIntent().getParcelableExtra(\"io.card.payment.scanResult\");\n         ((DataEntryActivity) this).w = getIntent().getBooleanExtra(\"debug_autoAcceptResult\", false);\n         if (((DataEntryActivity) this).v != null) {\n             ((DataEntryActivity) this).f = new i.a.a.b(((DataEntryActivity) this).v.cardNumber);\n             ((DataEntryActivity) this).s = new ImageView(this);\n             LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(-1, -2);\n             ((DataEntryActivity) this).s.setPadding(0, 0, 0, paddingPx);\n             cardParams.weight = 1.0f;\n             ((DataEntryActivity) this).s.setImageBitmap(CardIOActivity.f);\n             mainLayout.addView(((DataEntryActivity) this).s, cardParams);\n             c.d(((DataEntryActivity) this).s, (String) null, (String) null, (String) null, \"8dip\");\n             i = -1;\n             i2 = -2;\n         } else {\n             TextView textView = new TextView(this);\n             ((DataEntryActivity) this).c = textView;\n             textView.setTextSize(24.0f);\n             if (!((DataEntryActivity) this).y) {\n                 ((DataEntryActivity) this).c.setTextColor(i.a.a.p.b.e);\n             }\n             mainLayout.addView(((DataEntryActivity) this).c);\n             c.e(((DataEntryActivity) this).c, (String) null, (String) null, (String) null, \"8dip\");\n             c.c(((DataEntryActivity) this).c, -2, -2);\n             LinearLayout numberLayout = new LinearLayout(this);\n             numberLayout.setOrientation(1);\n             c.e(numberLayout, (String) null, \"4dip\", (String) null, \"4dip\");\n             TextView numberLabel = new TextView(this);\n             c.e(numberLabel, ((DataEntryActivity) this).x, (String) null, (String) null, (String) null);\n             numberLabel.setText(b.a(i.a.a.o.c.u));\n             if (!((DataEntryActivity) this).y) {\n                 numberLabel.setTextColor(i.a.a.p.b.t);\n             }\n             numberLayout.addView(numberLabel, -2, -2);\n             EditText editText = new EditText(this);\n             ((DataEntryActivity) this).d = editText;\n             int i4 = ((DataEntryActivity) this).b;\n             ((DataEntryActivity) this).b = i4 + 1;\n             editText.setId(i4);\n             ((DataEntryActivity) this).d.setMaxLines(1);\n             ((DataEntryActivity) this).d.setImeOptions(6);\n             ((DataEntryActivity) this).d.setTextAppearance(getApplicationContext(), 16842816);\n             ((DataEntryActivity) this).d.setInputType(3);\n             ((DataEntryActivity) this).d.setHint(\"1234 5678 1234 5678\");\n             if (!((DataEntryActivity) this).y) {\n                 ((DataEntryActivity) this).d.setHintTextColor(-3355444);\n             }\n             TextWatcher bVar = new i.a.a.b();\n             ((DataEntryActivity) this).f = bVar;\n             ((DataEntryActivity) this).d.addTextChangedListener(bVar);\n             ((DataEntryActivity) this).d.addTextChangedListener(this);\n             ((DataEntryActivity) this).d.setFilters(new InputFilter[]{new DigitsKeyListener(), ((DataEntryActivity) this).f});\n             i = -1;\n             i2 = -2;\n             numberLayout.addView(((DataEntryActivity) this).d, -1, -2);\n             mainLayout.addView(numberLayout, -1, -1);\n         }\n         LinearLayout optionLayout = new LinearLayout(this);\n         LinearLayout.LayoutParams optionLayoutParam = new LinearLayout.LayoutParams(i, i2);\n         c.e(optionLayout, (String) null, \"4dip\", (String) null, \"4dip\");\n         optionLayout.setOrientation(0);\n         boolean requireExpiry = getIntent().getBooleanExtra(\"io.card.payment.requireExpiry\", false);\n         boolean requireCVV = getIntent().getBooleanExtra(\"io.card.payment.requireCVV\", false);\n         boolean requirePostalCode = getIntent().getBooleanExtra(\"io.card.payment.requirePostalCode\", false);\n         if (requireExpiry) {\n             LinearLayout expiryLayout = new LinearLayout(this);\n             container = container2;\n             str = \"4dip\";\n             str2 = \"8dip\";\n             LinearLayout.LayoutParams expiryLayoutParam = new LinearLayout.LayoutParams(0, -1, 1.0f);\n             expiryLayout.setOrientation(1);\n             TextView expiryLabel = new TextView(this);\n             if (!((DataEntryActivity) this).y) {\n                 expiryLabel.setTextColor(i.a.a.p.b.t);\n             }\n             expiryLabel.setText(b.a(i.a.a.o.c.q));\n             c.e(expiryLabel, ((DataEntryActivity) this).x, (String) null, (String) null, (String) null);\n             expiryLayout.addView(expiryLabel, -2, -2);\n             EditText editText2 = new EditText(this);\n             ((DataEntryActivity) this).g = editText2;\n             int i5 = ((DataEntryActivity) this).b;\n             ((DataEntryActivity) this).b = i5 + 1;\n             editText2.setId(i5);\n             ((DataEntryActivity) this).g.setMaxLines(1);\n             ((DataEntryActivity) this).g.setImeOptions(6);\n             ((DataEntryActivity) this).g.setTextAppearance(getApplicationContext(), 16842816);\n             ((DataEntryActivity) this).g.setInputType(3);\n             ((DataEntryActivity) this).g.setHint(b.a(i.a.a.o.c.r));\n             if (!((DataEntryActivity) this).y) {\n                 ((DataEntryActivity) this).g.setHintTextColor(-3355444);\n             }\n             if (((DataEntryActivity) this).v != null) {\n                 CreditCard creditCard = ((DataEntryActivity) this).v;\n                 ((DataEntryActivity) this).h = new d(creditCard.expiryMonth, creditCard.expiryYear);\n             } else {\n                 ((DataEntryActivity) this).h = new d();\n             }\n             if (((DataEntryActivity) this).h.d()) {\n                 ((DataEntryActivity) this).g.setText(((DataEntryActivity) this).h.getValue());\n             }\n             ((DataEntryActivity) this).g.addTextChangedListener(((DataEntryActivity) this).h);\n             ((DataEntryActivity) this).g.addTextChangedListener(this);\n             ((DataEntryActivity) this).g.setFilters(new InputFilter[]{new DateKeyListener(), ((DataEntryActivity) this).h});\n             expiryLayout.addView(((DataEntryActivity) this).g, -1, -2);\n             optionLayout.addView(expiryLayout, expiryLayoutParam);\n             c.d(expiryLayout, (String) null, (String) null, (requireCVV || requirePostalCode) ? str : null, (String) null);\n         } else {\n             str = \"4dip\";\n             container = container2;\n             str2 = \"8dip\";\n             ((DataEntryActivity) this).h = new i.a.a.a();\n         }\n         if (requireCVV) {\n             LinearLayout cvvLayout = new LinearLayout(this);\n             LinearLayout.LayoutParams cvvLayoutParam = new LinearLayout.LayoutParams(0, -1, 1.0f);\n             cvvLayout.setOrientation(1);\n             TextView cvvLabel = new TextView(this);\n             if (!((DataEntryActivity) this).y) {\n                 cvvLabel.setTextColor(i.a.a.p.b.t);\n             }\n             c.e(cvvLabel, ((DataEntryActivity) this).x, (String) null, (String) null, (String) null);\n             cvvLabel.setText(b.a(i.a.a.o.c.l));\n             cvvLayout.addView(cvvLabel, -2, -2);\n             EditText editText3 = new EditText(this);\n             ((DataEntryActivity) this).j = editText3;\n             int i6 = ((DataEntryActivity) this).b;\n             ((DataEntryActivity) this).b = i6 + 1;\n             editText3.setId(i6);\n             ((DataEntryActivity) this).j.setMaxLines(1);\n             ((DataEntryActivity) this).j.setImeOptions(6);\n             ((DataEntryActivity) this).j.setTextAppearance(getApplicationContext(), 16842816);\n             ((DataEntryActivity) this).j.setInputType(3);\n             ((DataEntryActivity) this).j.setHint(\"123\");\n             if (!((DataEntryActivity) this).y) {\n                 ((DataEntryActivity) this).j.setHintTextColor(-3355444);\n             }\n             int length = 4;\n             if (((DataEntryActivity) this).v != null) {\n                 CardType type = CardType.fromCardNumber(((DataEntryActivity) this).f.getValue());\n                 length = type.cvvLength();\n             }\n             ((DataEntryActivity) this).l = new e(length);\n             ((DataEntryActivity) this).j.setFilters(new InputFilter[]{new DigitsKeyListener(), ((DataEntryActivity) this).l});\n             ((DataEntryActivity) this).j.addTextChangedListener(((DataEntryActivity) this).l);\n             ((DataEntryActivity) this).j.addTextChangedListener(this);\n             cvvLayout.addView(((DataEntryActivity) this).j, -1, -2);\n             optionLayout.addView(cvvLayout, cvvLayoutParam);\n             c.d(cvvLayout, requireExpiry ? str : null, (String) null, requirePostalCode ? str : null, (String) null);\n         } else {\n             ((DataEntryActivity) this).l = new i.a.a.a();\n         }\n         if (requirePostalCode) {\n             LinearLayout postalCodeLayout = new LinearLayout(this);\n             LinearLayout.LayoutParams postalCodeLayoutParam = new LinearLayout.LayoutParams(0, -1, 1.0f);\n             postalCodeLayout.setOrientation(1);\n             TextView zipLabel = new TextView(this);\n             if (!((DataEntryActivity) this).y) {\n                 zipLabel.setTextColor(i.a.a.p.b.t);\n             }\n             c.e(zipLabel, ((DataEntryActivity) this).x, (String) null, (String) null, (String) null);\n             zipLabel.setText(b.a(i.a.a.o.c.n));\n             postalCodeLayout.addView(zipLabel, -2, -2);\n             boolean postalCodeNumericOnly = getIntent().getBooleanExtra(\"io.card.payment.restrictPostalCodeToNumericOnly\", false);\n             EditText editText4 = new EditText(this);\n             ((DataEntryActivity) this).n = editText4;\n             int i7 = ((DataEntryActivity) this).b;\n             ((DataEntryActivity) this).b = i7 + 1;\n             editText4.setId(i7);\n             ((DataEntryActivity) this).n.setMaxLines(1);\n             ((DataEntryActivity) this).n.setImeOptions(6);\n             ((DataEntryActivity) this).n.setTextAppearance(getApplicationContext(), 16842816);\n             if (postalCodeNumericOnly) {\n                 ((DataEntryActivity) this).n.setInputType(3);\n             } else {\n                 ((DataEntryActivity) this).n.setInputType(1);\n             }\n             if (!((DataEntryActivity) this).y) {\n                 ((DataEntryActivity) this).n.setHintTextColor(-3355444);\n             }\n             TextWatcher gVar = new g(20);\n             ((DataEntryActivity) this).p = gVar;\n             ((DataEntryActivity) this).n.addTextChangedListener(gVar);\n             ((DataEntryActivity) this).n.addTextChangedListener(this);\n             postalCodeLayout.addView(((DataEntryActivity) this).n, -1, -2);\n             optionLayout.addView(postalCodeLayout, postalCodeLayoutParam);\n             c.d(postalCodeLayout, (requireExpiry || requireCVV) ? str : null, (String) null, (String) null, (String) null);\n         } else {\n             ((DataEntryActivity) this).p = new i.a.a.a();\n         }\n         mainLayout.addView(optionLayout, optionLayoutParam);\n         c(mainLayout);\n         wrapperLayout.addView(mainLayout, mainParams);\n         c.d(mainLayout, \"16dip\", \"20dip\", \"16dip\", \"20dip\");\n         LinearLayout buttonLayout = new LinearLayout(this);\n         int i8 = ((DataEntryActivity) this).a;\n         ((DataEntryActivity) this).a = i8 + 1;\n         buttonLayout.setId(i8);\n         RelativeLayout.LayoutParams buttonLayoutParam = new RelativeLayout.LayoutParams(-1, -2);\n         buttonLayoutParam.addRule(12);\n         buttonLayout.setPadding(0, paddingPx, 0, 0);\n         buttonLayout.setBackgroundColor(0);\n         scrollParams.addRule(2, buttonLayout.getId());\n         ((DataEntryActivity) this).t = new Button(this);\n         LinearLayout.LayoutParams doneParam = new LinearLayout.LayoutParams(-1, -2, 1.0f);\n         ((DataEntryActivity) this).t.setText(b.a(i.a.a.o.c.j));\n         ((DataEntryActivity) this).t.setOnClickListener(new DataEntryActivity.a(this));\n         ((DataEntryActivity) this).t.setEnabled(false);\n         buttonLayout.addView(((DataEntryActivity) this).t, doneParam);\n         c.f(((DataEntryActivity) this).t, true, this, ((DataEntryActivity) this).y);\n         c.e(((DataEntryActivity) this).t, \"5dip\", (String) null, \"5dip\", (String) null);\n         String str3 = str2;\n         c.d(((DataEntryActivity) this).t, str3, str3, str3, str3);\n         if (!((DataEntryActivity) this).y) {\n             ((DataEntryActivity) this).t.setTextSize(16.0f);\n         }\n         ((DataEntryActivity) this).u = new Button(this);\n         LinearLayout.LayoutParams cancelParam = new LinearLayout.LayoutParams(-1, -2, 1.0f);\n         ((DataEntryActivity) this).u.setText(b.a(i.a.a.o.c.a));\n         ((DataEntryActivity) this).u.setOnClickListener(new DataEntryActivity.b(this));\n         buttonLayout.addView(((DataEntryActivity) this).u, cancelParam);\n         c.f(((DataEntryActivity) this).u, false, this, ((DataEntryActivity) this).y);\n         c.e(((DataEntryActivity) this).u, \"5dip\", (String) null, \"5dip\", (String) null);\n         c.d(((DataEntryActivity) this).u, str, str3, str3, str3);\n         if (!((DataEntryActivity) this).y) {\n             ((DataEntryActivity) this).u.setTextSize(16.0f);\n         }\n         RelativeLayout container3 = container;\n         container3.addView(buttonLayout, buttonLayoutParam);\n         a.c(this);\n         setContentView(container3);\n         Drawable icon = null;\n         boolean usePayPalActionBarIcon = getIntent().getBooleanExtra(\"io.card.payment.intentSenderIsPayPal\", true);\n         if (usePayPalActionBarIcon) {\n             icon = getResources().getDrawable(R.drawable.cio_ic_paypal_monogram);\n         }\n         if (requireExpiry && ((DataEntryActivity) this).h.a()) {\n             afterTextChanged(((DataEntryActivity) this).g.getEditableText());\n         }\n         a.i(this, ((DataEntryActivity) this).c, b.a(i.a.a.o.c.v), \"card.io - \", icon);\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/io/card/payment/DataEntryActivity.java",
              "file_line": [
                1159
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.930-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "188bb9f5-6fbd-410b-8c71-affd157e0404",
              "value": "public void onActivityResult(int requestCode, int resultCode, Intent data) {\n         super.onActivityResult(requestCode, resultCode, data);\n         if (requestCode == e.a.intValue()) {\n             if (data != null && data.hasExtra(\"io.card.payment.scanResult\")) {\n                 CreditCard scanResult = data.getParcelableExtra(\"io.card.payment.scanResult\");\n                 ((PayActivity) this).l.setText(scanResult.cardNumber);\n                 ((PayActivity) this).l.setText(i.a(scanResult.cardNumber, \"-\", 4));\n                 ((PayActivity) this).j.setText(scanResult.cardholderName);\n                 if (scanResult.isExpiryValid()) {\n                     ((PayActivity) this).n.setText(i.b(scanResult.expiryMonth));\n                     ((PayActivity) this).p.setText(i.c(scanResult.expiryYear));\n                 }\n                 String str = scanResult.cvv;\n                 if (str != null) {\n                     ((PayActivity) this).q.setText(str);\n                 }\n             }\n         } else if (requestCode == e.b.intValue()) {\n             if (resultCode == 2) {\n                 H();\n             } else if (resultCode == 1) {\n                 H();\n             } else if (resultCode == 17) {\n                 String raw_pay_response = data.getStringExtra(\"raw_pay_response\");\n                 try {\n                     ((PayActivity) this).B = new JSONObject(raw_pay_response);\n                     R();\n                 } catch (Exception e) {\n                     L(raw_pay_response);\n                 }\n             }\n         }\n     }",
              "vulnerability_id": "de5fe2a4-bdbd-4480-85f2-8964e07ac78f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                2272
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.873-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "04a6ce42-6151-4285-b74d-7899418b87b4",
          "title": "Content Provider Leak",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Fake App</b> implements a Content Provider that may allow unauthorized access or data manipulation. Content Providers enable structured data sharing between applications, but if not properly configured, they can expose sensitive data or allow unintended modifications.</p>\n<p>Improper permission handling, insecure URI grants, or unintended data exposure could lead to unauthorized access, affecting both data confidentiality and integrity. This issue may be further exploited if the application lacks proper validation when processing external requests.</p>\n",
              "remediation": "<p>The assessment team recommends ensuring that Content Providers are not unintentionally exposed by explicitly setting android:exported=&quot;false&quot; in the application&#39;s manifest for components that should not be accessed externally. If external access is required, appropriate permissions must be enforced using android:permission, android:readPermission, and android:writePermission.</p>\n<p>Additionally, developers should validate and sanitize all incoming data to prevent unauthorized access or modifications. When granting URI permissions, the use of FLAG_GRANT_READ_URI_PERMISSION and FLAG_GRANT_WRITE_URI_PERMISSION should be restricted to trusted applications. Finally, avoid reflecting attacker-controlled data in result intents, as this could be leveraged to manipulate application behavior.</p>\n",
              "impact": "<p>An attacker could exploit this issue to:</p>\n<ul>\n<li>Access sensitive data stored in the Content Provider, potentially exposing confidential user information.</li>\n<li>Modify or delete records, impacting data integrity and application functionality.</li>\n<li>Gain unauthorized privileges by exploiting weak URI permissions or permission misconfigurations.</li>\n<li>Manipulate application behavior, potentially leading to unintended actions or privilege escalation.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Fake App</b> implementa un Proveedor de contenido que puede permitir el acceso no autorizado o la manipulación de datos. Los proveedores de contenido permiten compartir datos estructurados entre aplicaciones, pero si no se configuran correctamente, pueden exponer datos confidenciales o permitir modificaciones no deseadas.</p>\n<p>La gestión inadecuada de permisos, las concesiones de URI inseguras o la exposición no intencionada de los datos podrían provocar un acceso no autorizado, lo que afectaría tanto a la confidencialidad como a la integridad de los datos. Este problema puede explotarse aún más si la aplicación carece de una validación adecuada al procesar solicitudes externas.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda garantizar que los proveedores de contenido no queden expuestos involuntariamente configurando explícitamente android:exported=&quot;false&quot; en el manifiesto de la aplicación para los componentes a los que no se debe acceder externamente. Si se requiere acceso externo, se deben aplicar los permisos adecuados mediante android:permission, android:readPermission y android:writePermission.</p>\n<p>Además, los desarrolladores deben validar y desinfectar todos los datos entrantes para evitar modificaciones o accesos no autorizados. Al otorgar permisos URI, el uso de FLAG_GRANT_READ_URI_PERMISSION y FLAG_GRANT_WRITE_URI_PERMISSION debe restringirse a aplicaciones confiables. Por último, evite reflejar datos controlados por el atacante en los resultados, ya que esto podría aprovecharse para manipular el comportamiento de la aplicación.</p>\n",
              "impact": "<p>Un atacante podría aprovechar este problema para:</p>\n<ul>\n<li>Acceder a datos confidenciales almacenados en el Proveedor de contenido, exponiendo potencialmente información confidencial del usuario.</li>\n<li>Modificar o eliminar registros, lo que afecta la integridad de los datos y la funcionalidad de la aplicación.</li>\n<li>Obtenga privilegios no autorizados explotando permisos de URI débiles o configuraciones incorrectas de permisos.</li>\n<li>Manipular el comportamiento de las aplicaciones, lo que podría provocar acciones no deseadas o una escalada de privilegios.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#content-providers"
            },
            {
              "label": "Getting a Result from an Activity | Android Developers",
              "url": "https://developer.android.com/training/basics/intents/result?hl=es-419"
            },
            {
              "label": "Content Provider Basics | Android Developers",
              "url": "https://developer.android.com/guide/topics/providers/content-provider-basics?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0064"
          },
          "evidences": [
            {
              "id": "982eec40-1da7-48f5-a136-8176b49987ed",
              "value": "private void onCompleteWebFallbackDialog(Bundle values) {\n         FragmentActivity fragmentActivity = getActivity();\n         Intent resultIntent = new Intent();\n         resultIntent.putExtras(values == null ? new Bundle() : values);\n         fragmentActivity.setResult(-1, resultIntent);\n         fragmentActivity.finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/FacebookDialogFragment.java",
              "file_line": [
                126
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.167-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b8e0e675-ec78-4ac6-98e6-2f0c440707c7",
              "value": "private void handlePassThroughError() {\n         Intent requestIntent = getIntent();\n         Bundle errorResults = NativeProtocol.getMethodArgumentsFromIntent(requestIntent);\n         FacebookException exception = NativeProtocol.getExceptionFromErrorData(errorResults);\n         Intent resultIntent = NativeProtocol.createProtocolResultIntent(getIntent(), (Bundle) null, exception);\n         setResult(0, resultIntent);\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/FacebookActivity.java",
              "file_line": [
                88
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.128-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1747a6ef-c038-4299-8969-a95de76a160a",
              "value": "public final void I(String reason) {\n         Intent errorIntent = new Intent();\n         errorIntent.putExtra(\"transaction_error_reason\", reason);\n         setResult(3, errorIntent);\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                901
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.354-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "fdaed402-2ab6-4b12-920d-c13c14ead170",
              "value": "private void sendResult(int resultCode, Intent resultIntent) {\n         LocalBroadcastManager.getInstance(this).unregisterReceiver(((CustomTabMainActivity) this).redirectReceiver);\n         if (resultIntent == null) {\n             setResult(resultCode, NativeProtocol.createProtocolResultIntent(getIntent(), (Bundle) null, (FacebookException) null));\n         } else {\n             String responseURL = resultIntent.getStringExtra(CustomTabMainActivity.EXTRA_URL);\n             Bundle results = responseURL != null ? CustomTabMainActivity.parseResponseUri(responseURL) : new Bundle();\n             Intent nativeProtocolResultIntent = NativeProtocol.createProtocolResultIntent(getIntent(), results, (FacebookException) null);\n             setResult(resultCode, nativeProtocolResultIntent != null ? nativeProtocolResultIntent : resultIntent);\n         }\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/CustomTabMainActivity.java",
              "file_line": [
                292
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.082-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "643b29d0-5683-4e1b-b3c3-3ef634f7ade2",
              "value": "public void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n         String str = CustomTabActivity.CUSTOM_TAB_REDIRECT_ACTION;\n         if (str.equals(getIntent().getAction())) {\n             setResult(0);\n             finish();\n         } else if (savedInstanceState == null) {\n             String action = getIntent().getStringExtra(CustomTabMainActivity.EXTRA_ACTION);\n             Bundle parameters = getIntent().getBundleExtra(CustomTabMainActivity.EXTRA_PARAMS);\n             String chromePackage = getIntent().getStringExtra(CustomTabMainActivity.EXTRA_CHROME_PACKAGE);\n             CustomTab customTab = new CustomTab(action, parameters);\n             boolean couldOpenCustomTab = customTab.openCustomTab(this, chromePackage);\n             ((CustomTabMainActivity) this).shouldCloseCustomTab = false;\n             if (!couldOpenCustomTab) {\n                 setResult(0, getIntent().putExtra(CustomTabMainActivity.NO_ACTIVITY_EXCEPTION, true));\n                 finish();\n                 return;\n             }\n             ((CustomTabMainActivity) this).redirectReceiver = new CustomTabMainActivity.1(this);\n             LocalBroadcastManager.getInstance(this).registerReceiver(((CustomTabMainActivity) this).redirectReceiver, new IntentFilter(str));\n         }\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/CustomTabMainActivity.java",
              "file_line": [
                428
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.104-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5706dfbb-bc68-4286-86bd-3fe7a46e7cff",
              "value": "public void onResume() {\n         super.onResume();\n         if (((InitSecureConnectionActivity) this).handshake == null && !((InitSecureConnectionActivity) this).isValidatedState) {\n             if (SdkUtils.haveNetworkConnection(this)) {\n                 InitSecureConnectionActivity.Handshake handshake = new InitSecureConnectionActivity.Handshake(this, (InitSecureConnectionActivity.1) null);\n                 ((InitSecureConnectionActivity) this).handshake = handshake;\n                 handshake.execute(new String[0]);\n                 return;\n             }\n             Resources resources = getResources();\n             int i = R.string.pf_no_connection;\n             Toast.makeText((Context) this, (CharSequence) resources.getString(i), 1).show();\n             Serializable failedToInitConnectionResponse = Utils.getFailedToInitConnectionResponse(getResources().getString(i), ((FortActivity) this).merchantFortRequest.getRequestMap());\n             Intent intent = getIntent();\n             intent.putExtra(\"sdkResp\", failedToInitConnectionResponse);\n             setResult(-1, intent);\n             finish();\n         }\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/payfort/fort/android/sdk/activities/InitSecureConnectionActivity.java",
              "file_line": [
                382
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.296-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "45f65ffd-e340-4cfd-b811-c6eee7c16b67",
              "value": "public final void N() {\n         if (((PayActivity) this).A == PayActivity.e.a) {\n             Intent canceledIntent = new Intent();\n             setResult(1, canceledIntent);\n             finish();\n         }\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                1107
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.456-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f2012f38-d1bf-415e-a09c-6a4ea11880e7",
              "value": "private void onCompleteWebDialog(Bundle values, FacebookException error) {\n         FragmentActivity fragmentActivity = getActivity();\n         Intent resultIntent = NativeProtocol.createProtocolResultIntent(fragmentActivity.getIntent(), values, error);\n         int resultCode = error == null ? -1 : 0;\n         fragmentActivity.setResult(resultCode, resultIntent);\n         fragmentActivity.finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/FacebookDialogFragment.java",
              "file_line": [
                83
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.146-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "770b8322-addc-40d5-9bb5-3d45d47f0451",
              "value": "public static void finishShareToMessenger(Activity activity, ShareToMessengerParams shareToMessengerParams) {\n         Intent originalIntent = activity.getIntent();\n         Set<String> categories = originalIntent.getCategories();\n         if (categories == null) {\n             activity.setResult(0, null);\n             activity.finish();\n         } else if (categories.contains(\"com.facebook.orca.category.PLATFORM_THREAD_20150314\")) {\n             Bundle appLinkExtras = c.b(originalIntent);\n             Intent resultIntent = new Intent();\n             if (categories.contains(\"com.facebook.orca.category.PLATFORM_THREAD_20150314\")) {\n                 resultIntent.putExtra(\"com.facebook.orca.extra.PROTOCOL_VERSION\", 20150314);\n                 String threadToken = appLinkExtras.getString(\"com.facebook.orca.extra.THREAD_TOKEN\");\n                 resultIntent.putExtra(\"com.facebook.orca.extra.THREAD_TOKEN\", threadToken);\n                 resultIntent.setDataAndType(shareToMessengerParams.uri, shareToMessengerParams.mimeType);\n                 resultIntent.setFlags(1);\n                 resultIntent.putExtra(\"com.facebook.orca.extra.APPLICATION_ID\", FacebookSdk.getApplicationId());\n                 resultIntent.putExtra(\"com.facebook.orca.extra.METADATA\", shareToMessengerParams.metaData);\n                 resultIntent.putExtra(\"com.facebook.orca.extra.EXTERNAL_URI\", shareToMessengerParams.externalUri);\n                 activity.setResult(-1, resultIntent);\n                 activity.finish();\n                 return;\n             }\n             throw new RuntimeException();\n         } else {\n             activity.setResult(0, null);\n             activity.finish();\n         }\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/messenger/MessengerUtils.java",
              "file_line": [
                68
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.220-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "dfc4a33b-e83d-4832-91f9-2eb4de3f6ec0",
              "value": "public void onReceive(Context context, Intent intent) {\n         Intent returnIntent = ((InitSecureConnectionActivity.1) this).this$0.getIntent();\n         if (intent.hasExtra(\"sdkResp\")) {\n             returnIntent.putExtra(\"sdkResp\", intent.getSerializableExtra(\"sdkResp\"));\n         }\n         ((InitSecureConnectionActivity.1) this).this$0.setResult(-1, returnIntent);\n         ((InitSecureConnectionActivity.1) this).this$0.finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/payfort/fort/android/sdk/activities/InitSecureConnectionActivity$1.java",
              "file_line": [
                70
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.238-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "28e10c5e-4784-4857-a945-ba5e183c1cd5",
              "value": "public void onPostExecute(String fortResponse) {\n         super.onPostExecute((Cls2E83ODS5XOJ4LHW) fortResponse);\n         String fortResponse2 = ((InitSecureConnectionActivity.Handshake) this).aesCipherManager.decryptMsg(fortResponse, ((InitSecureConnectionActivity.Handshake) this).secretKeySpec);\n         Serializable collectResponse = Utils.collectResponse(fortResponse2, ((FortActivity) ((InitSecureConnectionActivity.Handshake) this).this$0).merchantFortRequest.getRequestMap());\n         if (fortResponse2 != null && collectResponse.isSuccess()) {\n             Intent intent = new Intent((Context) ((InitSecureConnectionActivity.Handshake) this).this$0, (Class<?>) CreditCardPaymentActivity.class);\n             intent.putExtra(\"merchantReq\", (Serializable) ((FortActivity) ((InitSecureConnectionActivity.Handshake) this).this$0).merchantFortRequest);\n             intent.putExtra(\"currencyDecimalPoints\", collectResponse.getCurrencyDecimalPoints());\n             if (collectResponse.getMerchantToken() != null) {\n                 intent.putExtra(\"merchantToken\", (Serializable) collectResponse.getMerchantToken());\n             }\n             intent.putExtra(\"environment\", ((InitSecureConnectionActivity.Handshake) this).environment);\n             intent.putExtra(\"defaultLocale\", FortSdkCache.DEFAULT_SYSTEM_LANGUAGE);\n             ((InitSecureConnectionActivity.Handshake) this).this$0.startActivity(intent);\n             return;\n         }\n         Intent intent2 = ((InitSecureConnectionActivity.Handshake) this).this$0.getIntent();\n         intent2.putExtra(\"sdkResp\", collectResponse);\n         ((InitSecureConnectionActivity.Handshake) this).this$0.setResult(-1, intent2);\n         ((InitSecureConnectionActivity.Handshake) this).this$0.finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/payfort/fort/android/sdk/activities/InitSecureConnectionActivity$Handshake.java",
              "file_line": [
                448
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.262-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "cb1d5f13-5022-4303-b9f0-4aeaceb36c24",
              "value": "public final void K() {\n         Intent successIntent = new Intent();\n         try {\n             S(successIntent);\n             setResult(6, successIntent);\n             finish();\n         } catch (JSONException e) {\n             L(((PayActivity) this).B.toString());\n         }\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                979
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.397-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b5d316f0-974b-437a-af6a-4f7e73b66509",
              "value": "public final void u(int resultCode, Intent data) {\n         setResult(resultCode, data);\n         CardIOActivity.f = null;\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/io/card/payment/CardIOActivity.java",
              "file_line": [
                2586
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.509-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b5238a6f-98b5-4533-84b6-2c278b34d4b7",
              "value": "private void onLoginClientCompleted(LoginClient.Result outcome) {\n         ((LoginFragment) this).request = null;\n         int resultCode = outcome.code == LoginClient.Result.Code.CANCEL ? 0 : -1;\n         Bundle bundle = new Bundle();\n         bundle.putParcelable(\"com.facebook.LoginFragment:Result\", outcome);\n         Intent resultIntent = new Intent();\n         resultIntent.putExtras(bundle);\n         if (isAdded()) {\n             getActivity().setResult(resultCode, resultIntent);\n             getActivity().finish();\n         }\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/login/LoginFragment.java",
              "file_line": [
                133
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.198-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9d206d2a-a60e-4f09-9d69-7491f4c5395c",
              "value": "public final void H() {\n         Intent cancel3dSecureIntent = new Intent();\n         try {\n             S(cancel3dSecureIntent);\n             setResult(9, cancel3dSecureIntent);\n         } catch (JSONException e) {\n             cancel3dSecureIntent.putExtra(\"raw_pay_response\", ((PayActivity) this).B.toString());\n             setResult(10, cancel3dSecureIntent);\n         }\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                846
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.314-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7a9d49c3-cc51-4a9f-87fb-cf5d395ab11e",
              "value": "public final void L(String raw_pay_response) {\n         Intent successIntent = new Intent();\n         successIntent.putExtra(\"raw_pay_response\", raw_pay_response);\n         setResult(7, successIntent);\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                1027
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.416-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "058f512b-d47c-4623-8fd8-e0d6f95fecc5",
              "value": "public final void w(String key) {\n         Intent errorIntent = new Intent();\n         errorIntent.putExtra(\"missing_argument_value\", key);\n         setResult(2, errorIntent);\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                2630
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.473-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9c27fa22-dbd4-40c1-9808-d06414dc2210",
              "value": "public final void A() {\n         Intent canceledIntent = new Intent();\n         setResult(1, canceledIntent);\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/ThreeDSecureWebViewActivty.java",
              "file_line": [
                37
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.492-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f9cff7e2-6714-4236-8112-acc7a4ca9055",
              "value": "public void onBackPressed() {\n         if (Build.VERSION.SDK_INT >= 25 && ((AnswerBotArticleActivity) this).articleView.canGoBack()) {\n             ((AnswerBotArticleActivity) this).articleView.goBack();\n             return;\n         }\n         AnswerBotArticleViewModel answerBotArticleViewModel = ((AnswerBotArticleActivity) this).viewModel;\n         if (answerBotArticleViewModel == null) {\n             setResult(0);\n         } else {\n             setResult(-1, new AnswerBotArticleConfiguration.Builder(answerBotArticleViewModel.getAnswerBotArticleUiConfig()).resultIntent(((AnswerBotArticleActivity) this).viewModel.getArticleResult()));\n         }\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/zendesk/answerbot/AnswerBotArticleActivity.java",
              "file_line": [
                161
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.544-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "47c12763-cdf5-4884-be59-c610ef8a64e7",
              "value": "public final void J() {\n         Intent rejectIntent = new Intent();\n         try {\n             S(rejectIntent);\n             setResult(4, rejectIntent);\n         } catch (JSONException e) {\n             rejectIntent.putExtra(\"raw_pay_response\", ((PayActivity) this).B.toString());\n             setResult(5, rejectIntent);\n         }\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                926
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.376-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0a486e48-c927-4844-8ca3-62a0c4ad0c0c",
              "value": "public final void M(String saveCardData) {\n         Intent successIntent = new Intent();\n         try {\n             JSONObject savedCardDict = new JSONObject(saveCardData);\n             T(successIntent, savedCardDict);\n             S(successIntent);\n             setResult(8, successIntent);\n             finish();\n         } catch (JSONException e) {\n             K();\n         }\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                1068
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.439-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "85d149df-1457-4d81-b15b-e481178c2059",
              "value": "public final void f() {\n         if (((DataEntryActivity) this).v == null) {\n             ((DataEntryActivity) this).v = new CreditCard();\n         }\n         if (((DataEntryActivity) this).g != null) {\n             CreditCard creditCard = ((DataEntryActivity) this).v;\n             d dVar = ((DataEntryActivity) this).h;\n             creditCard.expiryMonth = dVar.a;\n             creditCard.expiryYear = dVar.b;\n         }\n         String value = ((DataEntryActivity) this).f.getValue();\n         CreditCard creditCard2 = ((DataEntryActivity) this).v;\n         Parcelable creditCard3 = new CreditCard(value, creditCard2.expiryMonth, creditCard2.expiryYear, ((DataEntryActivity) this).l.getValue(), ((DataEntryActivity) this).p.getValue(), ((DataEntryActivity) this).r.getValue());\n         Intent dataIntent = new Intent();\n         dataIntent.putExtra(\"io.card.payment.scanResult\", creditCard3);\n         if (getIntent().hasExtra(\"io.card.payment.capturedCardImage\")) {\n             dataIntent.putExtra(\"io.card.payment.capturedCardImage\", getIntent().getByteArrayExtra(\"io.card.payment.capturedCardImage\"));\n         }\n         setResult(CardIOActivity.RESULT_CARD_INFO, dataIntent);\n         finish();\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/io/card/payment/DataEntryActivity.java",
              "file_line": [
                825
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.527-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0fee4990-c3f3-440b-b217-daa330adcf87",
              "value": "private static void shareToMessenger20150314(Activity activity, int requestCode, ShareToMessengerParams shareToMessengerParams) {\n         try {\n             Intent shareIntent = new Intent(\"android.intent.action.SEND\");\n             shareIntent.setFlags(1);\n             shareIntent.setPackage(\"com.facebook.orca\");\n             shareIntent.putExtra(\"android.intent.extra.STREAM\", shareToMessengerParams.uri);\n             shareIntent.setType(shareToMessengerParams.mimeType);\n             String appId = FacebookSdk.getApplicationId();\n             if (appId != null) {\n                 shareIntent.putExtra(\"com.facebook.orca.extra.PROTOCOL_VERSION\", 20150314);\n                 shareIntent.putExtra(\"com.facebook.orca.extra.APPLICATION_ID\", appId);\n                 shareIntent.putExtra(\"com.facebook.orca.extra.METADATA\", shareToMessengerParams.metaData);\n                 shareIntent.putExtra(\"com.facebook.orca.extra.EXTERNAL_URI\", shareToMessengerParams.externalUri);\n             }\n             activity.startActivityForResult(shareIntent, requestCode);\n         } catch (ActivityNotFoundException e) {\n             Intent openMessenger = activity.getPackageManager().getLaunchIntentForPackage(\"com.facebook.orca\");\n             activity.startActivity(openMessenger);\n         }\n     }",
              "vulnerability_id": "04a6ce42-6151-4285-b74d-7899418b87b4",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/messenger/MessengerUtils.java",
              "file_line": [
                645
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.562-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "8a833897-6fac-40dc-a07e-7ef100d04d15",
          "title": "Zip Slip",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Fake App</b> may be vulnerable to Zip Slip, a critical security issue that occurs when extracting files from an archive (e.g., ZIP) without proper path validation.</p>\n<p>If the application extracts files without validating their paths, an attacker could craft a ZIP archive containing directory traversal sequences (../../malicious_file), allowing the extraction of files outside the intended directory. This could lead to overwriting critical files within the application&#39;s internal storage or system directories, potentially enabling arbitrary code execution or modifying the app’s behavior.</p>\n",
              "remediation": "<p>The assessment team recommends implementing the following security measures to prevent Zip Slip exploitation:</p>\n<ul>\n<li>Validate file paths before extraction: Ensure that the destination path does not contain directory traversal sequences (../) that could lead to unintended file extraction locations.</li>\n<li>Use secure libraries for ZIP extraction: Implement libraries that include built-in protections against Zip Slip attacks, ensuring proper file path handling.</li>\n<li>Restrict file system write operations: Enforce security policies that limit where files can be extracted, preventing unauthorized overwrites of sensitive locations.</li>\n<li>Sanitize and restrict input sources: If the application allows users to provide ZIP archives, verify their integrity and contents before extraction.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit this vulnerability to:</p>\n<ul>\n<li>Overwrite critical files: Malicious ZIP archives could replace essential application files, leading to service disruption or security compromise.</li>\n<li>Execute arbitrary code: If critical files such as scripts or configuration files are overwritten, an attacker may execute code with the application's privileges.</li>\n<li>Compromise sensitive data: If the application extracts files to sensitive locations, an attacker could exfiltrate or manipulate private data.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Fake App</b> puede ser vulnerable a Zip Slip, un problema de seguridad crítico que ocurre al extraer archivos de un archivo (por ejemplo, ZIP) sin una validación de ruta adecuada.</p>\n<p>Si la aplicación extrae archivos sin validar sus rutas, un atacante podría crear un archivo ZIP que contenga secuencias transversales de directorio (../../malicious_file), permitiendo la extracción de archivos fuera del directorio deseado. Esto podría llevar a sobrescribir archivos críticos dentro del almacenamiento interno de la aplicación o en los directorios del sistema, lo que podría permitir la ejecución de código arbitrario o modificar el comportamiento de la aplicación.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda implementar las siguientes medidas de seguridad para evitar la explotación de Zip Slip:</p>\n<ul>\n<li>Validar las rutas de los archivos antes de la extracción: asegúrese de que la ruta de destino no contenga secuencias transversales de directorio (../) que puedan conducir a ubicaciones de extracción de archivos no deseadas.</li>\n<li>Utilice bibliotecas seguras para la extracción de ZIP: implemente bibliotecas que incluyan protecciones integradas contra ataques Zip Slip, garantizando un manejo adecuado de la ruta de los archivos.</li>\n<li>Restringir las operaciones de escritura del sistema de archivos: aplique políticas de seguridad que limiten dónde se pueden extraer los archivos, evitando sobrescrituras no autorizadas de ubicaciones confidenciales.</li>\n<li>Desinfectar y restringir las fuentes de entrada: si la aplicación permite a los usuarios proporcionar archivos ZIP, verifique su integridad y contenido antes de la extracción.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar esta vulnerabilidad para:</p>\n<ul>\n<li>Sobrescribir archivos críticos: los archivos ZIP maliciosos podrían reemplazar archivos de aplicaciones esenciales, lo que provocaría una interrupción del servicio o un compromiso de seguridad.</li>\n<li>Ejecutar código arbitrario: si se sobrescriben archivos críticos como scripts o archivos de configuración, un atacante puede ejecutar código con los privilegios de la aplicación.</li>\n<li>Comprometer datos confidenciales: si la aplicación extrae archivos en ubicaciones confidenciales, un atacante podría filtrar o manipular datos privados.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Zip Slip Vulnerability | Snyk",
              "url": "https://security.snyk.io/research/zip-slip-vulnerability"
            },
            {
              "label": "Zip Path Traversal | Security | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/zip-path-traversal?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-2",
            "maswe": "MASWE-0002"
          },
          "evidences": [
            {
              "id": "abae922b-d171-4cc0-a589-9825bbdeac4b",
              "value": "public final String[] d(Context context, String mappedLibraryName) {\n         String[] f;\n         String p = \"lib\" + File.separatorChar + \"([^\\\\\" + File.separatorChar + \"]*)\" + File.separatorChar + mappedLibraryName;\n         Pattern pattern = Pattern.compile(p);\n         Set<String> supportedABIs = new HashSet<>();\n         for (String sourceDir : f(context)) {\n             try {\n                 ZipFile zipFile = new ZipFile(new File(sourceDir), 1);\n                 Enumeration<? extends ZipEntry> elements = zipFile.entries();\n                 while (elements.hasMoreElements()) {\n                     ZipEntry el = elements.nextElement();\n                     Matcher match = pattern.matcher(el.getName());\n                     if (match.matches()) {\n                         supportedABIs.add(match.group(1));\n                     }\n                 }\n             } catch (IOException e) {\n             }\n         }\n         String[] result = new String[supportedABIs.size()];\n         return (String[]) supportedABIs.toArray(result);\n     }",
              "vulnerability_id": "8a833897-6fac-40dc-a07e-7ef100d04d15",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/o/a/a/a.java",
              "file_line": [
                469
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:03.879-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "d1282b1d-a8ea-4e8e-9571-9c9572d458cf",
          "title": "Android Start Internal Components",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Fake App</b> may improperly start internal components (activities or services) via implicit intents, potentially exposing sensitive functionality to unauthorized applications.</p>\n<p>Android applications often use methods like startActivity(), startActivityForResult(), and startService() to launch internal components. If these methods handle unvalidated intents, an attacker could craft a malicious intent to trigger unintended behaviors, interact with private components, or manipulate application logic.</p>\n<p>Additionally, if getParcelableExtra() is used without strict validation, an attacker could inject a malformed or unauthorized Parcelable object, potentially leading to unintended data processing or security risks.</p>\n",
              "remediation": "<p>The assessment team recommends the following mitigations to reduce the risks associated with insecure component invocation:</p>\n<ul>\n<li>Use explicit intents whenever possible: Restrict inter-component communication to explicitly defined targets to prevent unintended access by other applications.</li>\n<li>Validate all incoming intents: Ensure that every received intent is checked for its origin, expected parameters, and content integrity before processing.</li>\n<li>Restrict exported components: In the AndroidManifest.xml file, set android:exported=\"false\" for components that do not need to be accessed by external applications.</li>\n<li>Apply permission-based access control: If an internal component must be accessible externally, enforce strict access control via custom permissions (android:permission) to limit who can interact with it.</li>\n<li>Sanitize getParcelableExtra() inputs: Ensure that only expected Parcelable objects are processed, rejecting unexpected or malformed inputs.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit this issue to:</p>\n<ul>\n<li>Trigger unintended application behavior: If an internal component (such as an activity or service) is started improperly, it might perform unintended actions, such as navigating to a restricted screen or executing a function that was meant to be internal.</li>\n<li>Access sensitive data through exposed components: If an internal activity or service is unintentionally accessible, an attacker may extract sensitive information by interacting with it in ways not originally intended by the developers.</li>\n<li>Manipulate inter-component communication: If the application relies on intents to exchange data between components, an attacker might craft a malicious intent to manipulate this communication, leading to incorrect processing of user data or system functions.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Fake App</b> puede iniciar incorrectamente componentes internos (actividades o servicios) a través de intenciones implícitas, exponiendo potencialmente funcionalidades confidenciales a aplicaciones no autorizadas.</p>\n<p>Las aplicaciones de Android suelen utilizar métodos como startActivity(), startActivityForResult() y startService() para iniciar componentes internos. Si estos métodos manejan intenciones no validadas, un atacante podría crear una intención maliciosa para desencadenar comportamientos no deseados, interactuar con componentes privados o manipular la lógica de la aplicación.</p>\n<p>Además, si se utiliza getParcelableExtra() sin una validación estricta, un atacante podría inyectar un objeto Parcelable con formato incorrecto o no autorizado, lo que podría provocar un procesamiento de datos no deseado o riesgos de seguridad.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes mitigaciones para reducir los riesgos asociados con la invocación de componentes inseguros:</p>\n<ul>\n<li>Utilice intenciones explícitas siempre que sea posible: restrinja la comunicación entre componentes a objetivos definidos explícitamente para evitar el acceso no deseado de otras aplicaciones.</li>\n<li>Validar todos los intents entrantes: asegúrese de que se verifique el origen, los parámetros esperados y la integridad del contenido de cada intent recibido antes de procesarlo.</li>\n<li>Restringir los componentes exportados: en el archivo AndroidManifest.xml, configure android:exported=\"false\" para los componentes a los que no es necesario acceder mediante aplicaciones externas.</li>\n<li>Aplique control de acceso basado en permisos: si un componente interno debe ser accesible externamente, aplique un control de acceso estricto a través de permisos personalizados (android:permiso) para limitar quién puede interactuar con él.</li>\n<li>Desinfectar las entradas getParcelableExtra(): asegúrese de que solo se procesen los objetos Parcelable esperados, rechazando las entradas inesperadas o con formato incorrecto.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar este problema para:</p>\n<ul>\n<li>Desencadenar un comportamiento no deseado de la aplicación: si un componente interno (como una actividad o servicio) se inicia incorrectamente, podría realizar acciones no deseadas, como navegar a una pantalla restringida o ejecutar una función que estaba destinada a ser interna.</li>\n<li>Acceder a datos confidenciales a través de componentes expuestos: si se puede acceder involuntariamente a una actividad o servicio interno, un atacante puede extraer información confidencial interactuando con ella de maneras no previstas originalmente por los desarrolladores.</li>\n<li>Manipular la comunicación entre componentes: si la aplicación se basa en intentos de intercambiar datos entre componentes, un atacante podría idear una intención maliciosa para manipular esta comunicación, lo que llevaría a un procesamiento incorrecto de los datos del usuario o de las funciones del sistema.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#intents"
            },
            {
              "label": "Intent Redirection | Security | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/intent-redirection?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "fe51b266-75f6-4d30-92a0-7c36b32ed82e",
              "value": "private boolean tryFacebookActivity(StartActivityDelegate startActivityDelegate, LoginClient.Request request) {\n         Intent intent = getFacebookActivityIntent(request);\n         if (resolveIntent(intent)) {\n             try {\n                 startActivityDelegate.startActivityForResult(intent, LoginClient.getLoginRequestCode());\n                 return true;\n             } catch (ActivityNotFoundException e) {\n                 return false;\n             }\n         }\n         return false;\n     }",
              "vulnerability_id": "d1282b1d-a8ea-4e8e-9571-9c9572d458cf",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/login/LoginManager.java",
              "file_line": [
                1078
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.490-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "314d4e97-9a36-4a22-a0bd-fce8f2406927",
              "value": "public final void P(String url) {\n         Intent threeDSecureViewIntent = new Intent((Context) this, (Class<?>) ThreeDSecureWebViewActivty.class);\n         threeDSecureViewIntent.putExtra(\"three_d_secure_url\", url);\n         threeDSecureViewIntent.putExtra(\"theme_color\", ((PayActivity) this).z);\n         threeDSecureViewIntent.putExtra(\"three_d_secure_activity_title\", ((PayActivity) this).y);\n         startActivityForResult(threeDSecureViewIntent, e.b.intValue());\n     }",
              "vulnerability_id": "d1282b1d-a8ea-4e8e-9571-9c9572d458cf",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                1197
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.522-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6df3b0bd-01ec-47ff-8c90-c3f119cf44e2",
              "value": "private static void startForegroundService(Context context, Intent intent) {\n         if (Build.VERSION.SDK_INT >= 26) {\n             context.startForegroundService(intent);\n         } else {\n             context.startService(intent);\n         }\n     }",
              "vulnerability_id": "d1282b1d-a8ea-4e8e-9571-9c9572d458cf",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/media/session/MediaButtonReceiver.java",
              "file_line": [
                430
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.468-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f2e3a125-fc9a-4abf-a764-2b117208f224",
              "value": "public void O() {\n         Intent scanIntent = new Intent((Context) this, (Class<?>) CardIOActivity.class);\n         scanIntent.putExtra(\"io.card.payment.requireCardholderName\", true);\n         scanIntent.putExtra(\"io.card.payment.requireExpiry\", true);\n         scanIntent.putExtra(\"io.card.payment.requireCVV\", true);\n         startActivityForResult(scanIntent, e.a.intValue());\n     }",
              "vulnerability_id": "d1282b1d-a8ea-4e8e-9571-9c9572d458cf",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/PayActivity.java",
              "file_line": [
                1153
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.506-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "9ccd8af5-9843-4255-82dc-1e2316305921",
          "title": "Memory Corruption",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Fake App</b> utilizes native methods within its codebase. Native methods, often written in languages like C or C++, are integrated into Android applications to enhance performance or access specific hardware features. However, these languages are prone to memory management issues, such as buffer overflows, use-after-free errors, and null pointer dereferences, which can lead to memory corruption vulnerabilities. Such vulnerabilities can compromise the application&#39;s stability and security, potentially allowing attackers to execute arbitrary code or escalate privileges.</p>\n",
              "remediation": "<p>The assessment team recommends the following measures to mitigate memory corruption risks:</p>\n<ul>\n<li>Adopt Memory-Safe Languages: Utilize languages like Java or Kotlin for application development, minimizing direct memory management.​</li>\n<li>Implement Secure Coding Practices: When native code is necessary, adhere to secure coding standards, such as input validation and proper memory handling.​</li>\n<li>Enable Compiler Security Features: Use compiler options like _FORTIFY_SOURCE to detect and prevent buffer overflows and other memory issues at compile-time or runtime. ​</li>\n<li>Apply Address Space Layout Randomization (ASLR): Ensure ASLR is enabled to randomize memory addresses, making exploitation more challenging.</li>\n</ul>\n",
              "impact": "<p>Exploitation of memory corruption vulnerabilities can result in:</p>\n<ul>\n<li>Remote Code Execution (RCE): Attackers may execute arbitrary code within the application's context, leading to unauthorized actions or data breaches.​</li>\n<li>Denial of Service (DoS): Memory corruption can cause application crashes or instability, disrupting service availability.​</li>\n<li>Privilege Escalation: Attackers might gain elevated privileges, accessing restricted areas of the system or other applications' data.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Fake App</b> utiliza métodos nativos dentro de su código base. Los métodos nativos, a menudo escritos en lenguajes como C o C++, se integran en aplicaciones de Android para mejorar el rendimiento o acceder a funciones de hardware específicas. Sin embargo, estos lenguajes son propensos a sufrir problemas de gestión de la memoria, como desbordamientos del búfer, errores de uso después de la liberación y desreferencias de puntero nulo, lo que puede provocar vulnerabilidades de corrupción de la memoria. Estas vulnerabilidades pueden comprometer la estabilidad y la seguridad de la aplicación, permitiendo potencialmente a los atacantes ejecutar código arbitrario o escalar privilegios.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes medidas para mitigar los riesgos de corrupción de la memoria:</p>\n<ul>\n<li>Adopte lenguajes seguros para la memoria: utilice lenguajes como Java o Kotlin para el desarrollo de aplicaciones, minimizando la administración directa de la memoria.</li>\n<li>Implementar prácticas de codificación segura: cuando sea necesario el código nativo, cumpla con los estándares de codificación segura, como la validación de entradas y el manejo adecuado de la memoria.</li>\n<li>Habilite las funciones de seguridad del compilador: use opciones del compilador como _FORTIFY_SOURCE para detectar y evitar desbordamientos del búfer y otros problemas de memoria en tiempo de compilación o ejecución. ​</li>\n<li>Aplicar aleatorización del diseño del espacio de direcciones (ASLR): asegúrese de que ASLR esté habilitado para aleatorizar las direcciones de memoria, lo que hace que la explotación sea más desafiante.</li>\n</ul>\n",
              "impact": "<p>La explotación de vulnerabilidades de corrupción de memoria puede resultar en:</p>\n<ul>\n<li>Ejecución remota de código (RCE): los atacantes pueden ejecutar código arbitrario dentro del contexto de la aplicación, lo que lleva a acciones no autorizadas o violaciones de datos.</li>\n<li>Denegación de servicio (DoS): la corrupción de la memoria puede provocar fallos o inestabilidad de las aplicaciones, lo que altera la disponibilidad del servicio.</li>\n<li>Escalada de privilegios: los atacantes pueden obtener privilegios elevados, accediendo a áreas restringidas del sistema o a datos de otras aplicaciones.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Native Memory Usage Debugging | Android Open Source Project",
              "url": "https://source.android.com/docs/core/tests/debug/native-memory?hl=es"
            },
            {
              "label": "Use of Native Code | Security | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/use-of-native-code?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-3",
            "maswe": "MASWE-0116"
          },
          "evidences": [
            {
              "id": "9a21e9ec-f14b-4cdf-a797-4ce736768aef",
              "value": "private static native void setSpeedFactor(long j, float f);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                595
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.385-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e0ee243e-947d-4b9c-9770-3059c317488d",
              "value": "private native int getLocationX(long j, int i);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/net/sourceforge/zbar/Symbol.java",
              "file_line": [
                79
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.746-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "dfed24cc-b8f9-4fb5-b7ba-cb4c29ff75b3",
              "value": "private native long firstSymbol(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/net/sourceforge/zbar/SymbolSet.java",
              "file_line": [
                45
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.800-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1b826ce3-0e3e-4a40-8203-77a7a6c89875",
              "value": "private static native long getAllocationByteCount(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                263
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.849-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "a09548be-179e-48de-b473-15b01c01543e",
              "value": "private static native int getLoopCount(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                287
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.958-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5e0244e9-694f-456f-8662-ee10071bcb62",
              "value": "private static native void postUnbindSurface(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                562
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.167-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "bb4d6e55-b4b7-46c3-a48e-eeafd2f3c2c9",
              "value": "private static native long restoreRemainder(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                571
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.222-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "cb574b90-c7be-4c45-991e-597a50f9b2b3",
              "value": "private static native void seekToTime(long j, int i, Bitmap bitmap);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                586
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.324-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1b75e6fe-14d2-40fd-b3a9-8fafc03fe764",
              "value": "private native void destroy(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/net/sourceforge/zbar/Image.java",
              "file_line": [
                86
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.647-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f18619ec-18d8-4339-80ef-be56a3bd633a",
              "value": "private native long getComponents(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/net/sourceforge/zbar/Symbol.java",
              "file_line": [
                73
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.706-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f1de041d-1bd7-4d72-8f7f-ee180e5d0a9d",
              "value": "private native int getLocationSize(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/net/sourceforge/zbar/Symbol.java",
              "file_line": [
                76
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.723-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "756ae912-9435-4962-90c0-19f95d371a2c",
              "value": "private static native void bindSurface(long j, Surface surface, long[] jArr);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                241
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.820-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "823be166-88db-4301-8621-6c65894d6fc1",
              "value": "private static native int getCurrentFrameIndex(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                269
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.875-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5a38e4cc-246d-455b-81b2-a72b82ce2adf",
              "value": "private static native int getDuration(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                278
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.915-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b32cc17e-1146-4d57-bc4a-c4134a2086f9",
              "value": "private static native long getMetadataByteCount(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                290
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.970-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "76943a01-e0fc-441a-a260-d2cbd2c1b8f5",
              "value": "private static native void glTexImage2D(long j, int i, int i2);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                363
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.063-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "fb25334f-f5d2-416f-9951-7424117f2084",
              "value": "private static native boolean reset(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                568
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.208-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "837a42c5-36d1-468b-a7ca-200cb4aa070f",
              "value": "private static native void seekToFrameGL(long j, int i);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                583
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.307-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e00a8a51-c344-4d2f-a7be-29d8447a976a",
              "value": "private static native void setOptions(long j, char c, boolean z);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                592
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.363-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "cb6108a9-396b-49e7-9634-b459d358e703",
              "value": "private native long getResults(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/net/sourceforge/zbar/ImageScanner.java",
              "file_line": [
                42
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.680-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2de302e1-a581-417d-af8e-d177fdb3bc3e",
              "value": "private static native int getCurrentLoop(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                272
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.889-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "695f5b77-1497-474b-977b-1032403e85e3",
              "value": "private static native int getWidth(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                360
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.048-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "438fadd9-9be3-4655-b4fb-52f5d22f8d83",
              "value": "private static native boolean isAnimationCompleted(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                372
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.107-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "bf6b364c-c54b-4363-9873-2569263bb1bb",
              "value": "private static native boolean isOpaque(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                375
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.123-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4af36465-c601-4537-b500-c8dd0194ed08",
              "value": "private static native void saveRemainder(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                577
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.263-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f45d3abc-be87-4614-9bdc-fea10825eecb",
              "value": "private static native void setLoopCount(long j, char c);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                589
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.346-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9f504523-8a16-4ca3-a1ce-e42a6f348501",
              "value": "private static native void startDecoderThread(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                598
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.405-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "31f6fd20-a879-49ae-8305-dd5dac5bb53f",
              "value": "private static native void stopDecoderThread(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                601
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.432-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2e193592-639d-4505-b635-caa1b3e6c9e0",
              "value": "private native long convert(long j, String str);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/net/sourceforge/zbar/Image.java",
              "file_line": [
                80
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.621-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d29c0734-deba-46b0-8b5b-b97974ae823a",
              "value": "private native int getLocationY(long j, int i);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/net/sourceforge/zbar/Symbol.java",
              "file_line": [
                82
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.767-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ee1d129d-468a-4204-af36-c4ccc59bb7f0",
              "value": "private static native void free(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                260
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.834-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4f95b711-24f0-4727-97be-72d7f4dd0db9",
              "value": "private static native int getCurrentPosition(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                275
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.902-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "899744b8-5466-463c-9e00-041136d8c36e",
              "value": "private static native int getHeight(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                284
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.946-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "67078bef-4d5f-4b41-a078-374acc6d605f",
              "value": "private static native int getNumberOfFrames(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                351
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.997-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f4bc4558-4670-4895-bb2b-ee31d4a7ce20",
              "value": "private static native long[] getSavedState(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                354
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.010-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "274461ea-ef7a-4534-912d-7f8f67ac1e1e",
              "value": "private static native void glTexSubImage2D(long j, int i, int i2);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                366
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.077-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e6664afb-6773-47af-83b6-55cacb434e94",
              "value": "private static native void initTexImageDescriptor(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                369
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.091-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "05301e7f-c6d3-48f2-8c8d-31416c7d79f5",
              "value": "public static native long openNativeFileDescriptor(int i, long j) throws GifIOException;",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                470
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.150-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8c151177-29df-4fb2-8593-6bcd09f37ba5",
              "value": "private static native void seekToFrame(long j, int i, Bitmap bitmap);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                580
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.282-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3f334569-a6b3-4833-8820-f8b63b61fbc9",
              "value": "private native long getSymbols(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/net/sourceforge/zbar/Image.java",
              "file_line": [
                89
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.664-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9122b994-b2fe-4158-b78f-3cd7031e6192",
              "value": "private native int getType(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/net/sourceforge/zbar/Symbol.java",
              "file_line": [
                85
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.783-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4fa2f15c-78ca-46ff-b8f5-1da25a3708d9",
              "value": "private static native String getComment(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                266
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.862-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b6aba0ee-eaa5-4651-87bf-4d0dd1eb5156",
              "value": "private static native int getFrameDuration(long j, int i);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                281
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.933-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "661e693f-d573-4721-91ab-80929775c516",
              "value": "private static native int getNativeErrorCode(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                293
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.985-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "85755e47-134a-4817-be2c-868a11ff4604",
              "value": "private static native long getSourceLength(long j);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                357
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.029-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1f44936d-ff76-455b-b1bf-480679bf3299",
              "value": "private static native long renderFrame(long j, Bitmap bitmap);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                565
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.192-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7b2edfec-8806-43d5-a3c1-5bd98d652b78",
              "value": "private static native int restoreSavedState(long j, long[] jArr, Bitmap bitmap);",
              "vulnerability_id": "9ccd8af5-9843-4255-82dc-1e2316305921",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                574
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:08.242-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "f117561a-1b50-4460-a4d2-7950ec563676",
          "title": "Arbitrary File Theft",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Fake App</b> may expose sensitive files through improper use of the external cache directory (externalCacheDir).</p>\n<p>Android applications typically use externalCacheDir to temporarily store data, such as images or documents retrieved from external sources (e.g., camera, file manager). These actions are triggered using implicit intents via startActivityForResult(), which means the application waits for the external app (e.g., camera, file manager) to respond with a URI pointing to the requested file along with a status code.</p>\n<p>If the implementation of onActivityResult() does not properly validate received intents, the application may accept and process intents from any app. Furthermore, if the URI is not validated correctly, the application may blindly trust attacker-supplied URIs. A malicious application can exploit this behavior by injecting a manipulated intent targeting the victim application&#39;s internal files, causing <b>Fake App</b> to buffer its own internal files (such as authentication tokens or user data) into externalCacheDir, effectively exposing them to unauthorized access.</p>\n<p>Since externalCacheDir is stored in external storage (/storage/emulated/0/Android/data/<b>Fake App</b>/cache), it is publicly accessible to any application with READ_EXTERNAL_STORAGE permissions.</p>\n",
              "remediation": "<p>The assessment team recommends the following mitigations to prevent unauthorized access to private files through external cache storage:</p>\n<ul>\n<li>Use internal storage (getCacheDir()) instead of externalCacheDir: Store sensitive temporary files in internal storage, which is private to the application.</li>\n<li>Enforce strict validation of intent data: Ensure that incoming intents (e.g., from startActivityForResult()) are properly validated and restricted to prevent unauthorized file manipulations.</li>\n<li>Implement Scoped Storage: If external storage must be used, follow Scoped Storage best practices to limit file access to the application’s own directory and prevent exposure to third-party apps.</li>\n<li>Regularly clear externalCacheDir: Automatically delete temporary files in externalCacheDir once they are no longer needed to minimize the exposure window.</li>\n<li>Restrict storage permissions: Avoid requesting READ_EXTERNAL_STORAGE or WRITE_EXTERNAL_STORAGE unless absolutely necessary.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit this vulnerability to:</p>\n<ul>\n<li>Access sensitive application data: Private files, including authentication tokens, session cookies, or user-generated content, may be exposed if stored temporarily in externalCacheDir.</li>\n<li>Extract internal configuration files: If the application unintentionally buffers internal files in external storage, an attacker could retrieve them and analyze them for further exploitation.</li>\n<li>Bypass Android’s storage security model: This technique allows an attacker to indirectly access files stored in the app's private directory (/data/user/0/<b>Fake App</b>), circumventing direct access restrictions.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Fake App</b> puede exponer archivos confidenciales mediante el uso inadecuado del directorio de caché externo (externalCacheDir).</p>\n<p>Las aplicaciones de Android suelen utilizar externalCacheDir para almacenar temporalmente datos, como imágenes o documentos recuperados de fuentes externas (por ejemplo, cámara, administrador de archivos). Estas acciones se activan mediante intenciones implícitas a través de startActivityForResult(), lo que significa que la aplicación espera a que la aplicación externa (por ejemplo, cámara, administrador de archivos) responda con un URI que apunte al archivo solicitado junto con un código de estado.</p>\n<p>Si la implementación de onActivityResult() no valida adecuadamente los intents recibidos, la aplicación puede aceptar y procesar intents desde cualquier aplicación. Además, si el URI no se valida correctamente, la aplicación puede confiar ciegamente en los URI proporcionados por el atacante. Una aplicación maliciosa puede aprovechar este comportamiento inyectando una intención manipulada dirigida a los archivos internos de la aplicación víctima, lo que hace que <b>Fake App</b> guarde sus propios archivos internos (como tokens de autenticación o datos de usuario) en externalCacheDir, exponiéndolos efectivamente a acceso no autorizado.</p>\n<p>Dado que externalCacheDir se almacena en un almacenamiento externo (/storage/emulated/0/Android/data/<b>Fake App</b>/cache), cualquier aplicación con permisos READ_EXTERNAL_STORAGE puede acceder a él públicamente.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes mitigaciones para evitar el acceso no autorizado a archivos privados a través del almacenamiento en caché externo:</p>\n<ul>\n<li>Utilice almacenamiento interno (getCacheDir()) en lugar de externalCacheDir: almacene archivos temporales confidenciales en el almacenamiento interno, que es privado para la aplicación.</li>\n<li>Aplique una validación estricta de los datos de intención: asegúrese de que las intenciones entrantes (por ejemplo, desde startActivityForResult()) estén validadas y restringidas adecuadamente para evitar manipulaciones no autorizadas de archivos.</li>\n<li>Implementar Scoped Storage: si se debe utilizar almacenamiento externo, siga las mejores prácticas de Scoped Storage para limitar el acceso a archivos al propio directorio de la aplicación y evitar la exposición a aplicaciones de terceros.</li>\n<li>Borre periódicamente externalCacheDir: elimine automáticamente los archivos temporales en externalCacheDir una vez que ya no sean necesarios para minimizar la ventana de exposición.</li>\n<li>Restringir los permisos de almacenamiento: evite solicitar READ_EXTERNAL_STORAGE o WRITE_EXTERNAL_STORAGE a menos que sea absolutamente necesario.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar esta vulnerabilidad para:</p>\n<ul>\n<li>Acceda a datos confidenciales de la aplicación: los archivos privados, incluidos los tokens de autenticación, las cookies de sesión o el contenido generado por el usuario, pueden quedar expuestos si se almacenan temporalmente en externalCacheDir.</li>\n<li>Extraer archivos de configuración internos: si la aplicación almacena involuntariamente archivos internos en un almacenamiento externo, un atacante podría recuperarlos y analizarlos para su posterior explotación.</li>\n<li>Omitir el modelo de seguridad de almacenamiento de Android: esta técnica permite a un atacante acceder indirectamente a archivos almacenados en el directorio privado de la aplicación (/data/user/0/<b>Fake App</b>), eludiendo las restricciones de acceso directo.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "MASTG-TEST-0026: Testing Implicit Intents - Case 1: Arbitrary File Read",
              "url": "https://mas.owasp.org/MASTG/tests/android/MASVS-CODE/MASTG-TEST-0026/#case-1-arbitrary-file-read"
            },
            {
              "label": "Get a result from an activity | Android Developers",
              "url": "https://developer.android.com/training/basics/intents/result"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "65eac80b-ce66-426a-a68e-917355b1142f",
              "value": "public void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n         Intent intent = new Intent((Context) this, (Class<?>) CustomTabMainActivity.class);\n         intent.setAction(CustomTabActivity.CUSTOM_TAB_REDIRECT_ACTION);\n         intent.putExtra(CustomTabMainActivity.EXTRA_URL, getIntent().getDataString());\n         intent.addFlags(603979776);\n         startActivityForResult(intent, 2);\n     }",
              "vulnerability_id": "f117561a-1b50-4460-a4d2-7950ec563676",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/CustomTabActivity.java",
              "file_line": [
                194
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:03.974-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4e768e28-3ebe-4b0b-8bb9-c340e063629d",
              "value": "private static void shareToMessenger20150314(Activity activity, int requestCode, ShareToMessengerParams shareToMessengerParams) {\n         try {\n             Intent shareIntent = new Intent(\"android.intent.action.SEND\");\n             shareIntent.setFlags(1);\n             shareIntent.setPackage(\"com.facebook.orca\");\n             shareIntent.putExtra(\"android.intent.extra.STREAM\", shareToMessengerParams.uri);\n             shareIntent.setType(shareToMessengerParams.mimeType);\n             String appId = FacebookSdk.getApplicationId();\n             if (appId != null) {\n                 shareIntent.putExtra(\"com.facebook.orca.extra.PROTOCOL_VERSION\", 20150314);\n                 shareIntent.putExtra(\"com.facebook.orca.extra.APPLICATION_ID\", appId);\n                 shareIntent.putExtra(\"com.facebook.orca.extra.METADATA\", shareToMessengerParams.metaData);\n                 shareIntent.putExtra(\"com.facebook.orca.extra.EXTERNAL_URI\", shareToMessengerParams.externalUri);\n             }\n             activity.startActivityForResult(shareIntent, requestCode);\n         } catch (ActivityNotFoundException e) {\n             Intent openMessenger = activity.getPackageManager().getLaunchIntentForPackage(\"com.facebook.orca\");\n             activity.startActivity(openMessenger);\n         }\n     }",
              "vulnerability_id": "f117561a-1b50-4460-a4d2-7950ec563676",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/messenger/MessengerUtils.java",
              "file_line": [
                699
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:03.991-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6fb66aca-28a4-4b65-96a9-78c021b0b234",
              "value": "public final void y() {\n         Intent chooseFile = new Intent(\"android.intent.action.OPEN_DOCUMENT\");\n         chooseFile.setType(\"*/*\");\n         Intent chooseFile2 = Intent.createChooser(chooseFile, \"Choose a file\");\n         q.e(chooseFile2, \"createChooser(chooseFile, \\\"Choose a file\\\")\");\n         startActivityForResult(chooseFile2, 263);\n     }",
              "vulnerability_id": "f117561a-1b50-4460-a4d2-7950ec563676",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/verygoodsecurity/vgscollect/app/FilePickerActivity.java",
              "file_line": [
                281
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.012-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "67e8088b-339a-4f8e-bb60-1bb3d303ec8f",
              "value": "public final void s() {\n         Intent requestFileIntent = new Intent(\"android.intent.action.GET_CONTENT\");\n         requestFileIntent.setType(\"*/*\");\n         requestFileIntent.addCategory(\"android.intent.category.OPENABLE\");\n         Intent chooserIntent = Intent.createChooser(requestFileIntent, getResources().getString(R.string.leak_canary_import_from_title));\n         startActivityForResult(chooserIntent, 0);\n     }",
              "vulnerability_id": "f117561a-1b50-4460-a4d2-7950ec563676",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/leakcanary/internal/activity/LeakActivity.java",
              "file_line": [
                1140
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.029-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "cfe8ce79-71da-4179-b477-b1ec1ae4e9bd",
          "title": "Arbitrary Code Execution",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team discovered a significant vulnerability in the <b>Fake App</b> application that involves the potential for arbitrary code execution. This was identified through the use of various class loading mechanisms within Android&#39;s Dalvik virtual machine system, specifically through methods like DexClassLoader and DexFile. These classes allow dynamic loading of executable code from external sources, which can be exploited if an attacker is able to manipulate the source files or the loading process.</p>\n<p>In practice, this vulnerability could allow malicious actors to load and execute arbitrary code within the context of the application without the user&#39;s knowledge. This could lead to unauthorized access to application data, manipulation of application behavior, or even control over the Android device itself.</p>\n<p>The following code snippet shows the insecure implementation:</p>\n",
              "remediation": "<p>The assessment team recommends the following remediation strategies to address the vulnerability associated with arbitrary code execution through dynamic class loading:</p>\n<ul>\n<li>Validate and Authenticate Code Sources: Ensure that all dynamically loaded code, especially from external sources, is thoroughly validated and authenticated before execution. Implement cryptographic techniques to verify the integrity and origin of the code.\n</li>\n<li>Use Secure Class Loaders: Minimize the use of custom class loaders and rely on the system class loader whenever possible. If custom class loaders are necessary, restrict their use to trusted environments and ensure they do not permit the loading of untrusted code.\n</li>\n<li>Implement Least Privilege Access: Restrict the permissions granted to dynamically loaded code to follow the principle of least privilege. Ensure that loaded code runs in a sandboxed environment with limited access to system resources and sensitive data.</li>\n</ul>\n",
              "impact": "<p>An attacker can exploit this vulnerability to dynamically load and execute arbitrary code on the device. This capability enables unauthorized access to application data and system resources, potentially compromising the entire device. By manipulating or replacing the dynamically loaded code, attackers could control application behaviors, exfiltrate sensitive information, introduce malware, or perform actions on behalf of the user without their consent.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió una vulnerabilidad importante en la aplicación <b>Fake App</b> relacionada con la ejecución de código arbitrario. Esto se identificó a partir del uso de varios mecanismos de carga de clase en el sistema de máquina virtual Dalvik de Android, específicamente, con métodos como DexClassLoader y DexFile. Estas clases permiten que se cargue código ejecutable de manera dinámica de fuentes externas, lo cual puede ser explotado por un atacante que logra manipular los archivos fuente o el proceso de carga. En la práctica, esta vulnerabilidad podría permitir que actores malintencionados carguen y ejecuten código arbitrario en el contexto de la aplicación sin el conocimiento del usuario. Esto podría producir el acceso no autorizado a la información de la aplicación, la manipulación del comportamiento de la aplicación e incluso la pérdida del control sobre el dispositivo Android.</p>\n<p>El siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes estrategias de remediación para abordar la vulnerabilidad asociada con la ejecución de código arbitrario mediante la carga dinámica de clases:</p>\n<ul>\n<li>Validar y autenticar fuentes de código: asegúrese de que todo el código cargado dinámicamente, especialmente el código cargado de fuentes externas, esté completamente validado y autenticado antes de su ejecución. También se recomienda implementar técnicas criptográficas para verificar la integridad y origen del código.\n</li>\n<li>Utilizar cargadores de clases seguros: minimice el uso de cargadores de clases personalizados y confíe en el cargador de clases del sistema siempre que sea posible. Si se necesitan cargadores de clases personalizados, restrinja su uso a entornos confiables y asegúrese de que no permitan la carga de código que no sea de confianza.\n</li>\n<li>Implementar acceso con privilegios mínimos: restrinja los permisos otorgados al código cargado dinámicamente para seguir el principio de privilegios mínimos. Asegúrese de que el código cargado se ejecute en un entorno aislado con acceso limitado a los recursos del sistema y a los datos confidenciales.</li>\n</ul>\n",
              "impact": "<p>Un atacante puede aprovechar esta vulnerabilidad para cargar y ejecutar dinámicamente código arbitrario en el dispositivo. Esto permite el acceso no autorizado a datos de aplicaciones y recursos del sistema, lo que podría comprometer todo el dispositivo. Al manipular o reemplazar el código cargado dinámicamente, los atacantes podrían controlar el comportamiento de las aplicaciones, filtrar información confidencial, introducir malware o realizar acciones en nombre del usuario sin su consentimiento.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "DexFile | Android Developers",
              "url": "https://developer.android.com/reference/dalvik/system/DexFile#loadClass(java.lang.String,%20java.lang.ClassLoader)"
            },
            {
              "label": "DexFile | Android Developers",
              "url": "https://developer.android.com/reference/dalvik/system/DexFile#loadDex(java.lang.String,%20java.lang.String,%20int)"
            },
            {
              "label": "DexFile | Android Developers",
              "url": "https://developer.android.com/reference/dalvik/system/DexFile"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0085"
          },
          "evidences": [
            {
              "id": "a7c8bb30-ad98-458e-861f-01798c1a6dfa",
              "value": "public Cls19RAK8CEKPS3KTR(String str, ClassLoader classLoader) {\n         super(str, classLoader);\n     }",
              "vulnerability_id": "cfe8ce79-71da-4179-b477-b1ec1ae4e9bd",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/dynamite/zza.java",
              "file_line": [
                11
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:03.933-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "9e333b96-d747-4b28-b374-28578c466220",
          "title": "Use of External Storage with Media Types",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Fake App</b> processes media files using external storage. External storage in Android is publicly accessible, meaning any application with the necessary permissions can read or modify files stored there. If sensitive data is stored or handled insecurely in external storage, the application may be exposed to security risks.</p>\n",
              "remediation": "<p>The assessment team recommends storing sensitive media files in internal storage whenever possible to prevent unauthorized access. Applications targeting Android 10 (API level 29) and above should implement scoped storage to restrict access to external storage. Additionally, it is essential to validate and sanitize files read from external storage to prevent injection attacks and to limit the use of permissions such as READ_EXTERNAL_STORAGE and WRITE_EXTERNAL_STORAGE to only essential cases.</p>\n",
              "impact": "<p>Improper use of external storage can lead to:</p>\n<ul>\n<li>Data Tampering: Malicious applications can modify media files stored in external storage, potentially altering their content.</li>\n<li>Data Leakage: Sensitive information stored in external storage may be accessed by unauthorized applications.</li>\n<li>Code Injection: If the application processes media files from external storage without validation, an attacker could introduce malicious payloads.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Fake App</b> procesa archivos multimedia utilizando almacenamiento externo. El almacenamiento externo en Android es de acceso público, lo que significa que cualquier aplicación con los permisos necesarios puede leer o modificar los archivos almacenados allí. Si los datos confidenciales se almacenan o manejan de manera insegura en un almacenamiento externo, la aplicación puede quedar expuesta a riesgos de seguridad.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda almacenar archivos multimedia confidenciales en un almacenamiento interno siempre que sea posible para evitar el acceso no autorizado. Las aplicaciones destinadas a Android 10 (nivel de API 29) y superiores deben implementar almacenamiento con alcance para restringir el acceso al almacenamiento externo. Además, es esencial validar y desinfectar los archivos leídos desde el almacenamiento externo para evitar ataques de inyección y limitar el uso de permisos como READ_EXTERNAL_STORAGE y WRITE_EXTERNAL_STORAGE solo a casos esenciales.</p>\n",
              "impact": "<p>El uso inadecuado del almacenamiento externo puede provocar:</p>\n<ul>\n<li>Manipulación de datos: las aplicaciones maliciosas pueden modificar archivos multimedia almacenados en un almacenamiento externo, alterando potencialmente su contenido.</li>\n<li>Fuga de datos: aplicaciones no autorizadas pueden acceder a la información confidencial almacenada en un almacenamiento externo.</li>\n<li>Inyección de código: si la aplicación procesa archivos multimedia desde un almacenamiento externo sin validación, un atacante podría introducir cargas útiles maliciosas.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#external-storage"
            },
            {
              "label": "Sensitive Data Stored in External Storage | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sensitive-data-external-storage"
            },
            {
              "label": "MASTG-TEST-0201: Runtime Use of APIs to Access External Storage | OWASP Mobile Application Security",
              "url": "https://mas.owasp.org/MASTG/tests-beta/android/MASVS-STORAGE/MASTG-TEST-0201/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "3439d2cc-c71d-4e55-9ae5-1d8375ef9154",
              "value": "private static long queryForLong(Context context, Uri self, String column, long defaultValue) {\n         ContentResolver resolver = context.getContentResolver();\n         Cursor c = null;\n         try {\n             c = resolver.query(self, new String[]{column}, null, null, null);\n             return (!c.moveToFirst() || c.isNull(0)) ? defaultValue : c.getLong(0);\n         } catch (Exception e) {\n             Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             return defaultValue;\n         } finally {\n             DocumentsContractApi19.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/DocumentsContractApi19.java",
              "file_line": [
                584
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.341-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "86d5c3c5-8f62-466b-b2e1-cda47eda30c9",
              "value": "public final c j(String id) {\n         String[] whereSelectionParams = {\"vnd.android.cursor.item/name\", id};\n         Cursor nameCur = h().query(ContactsContract.Data.CONTENT_URI, null, \"mimetype = ? AND contact_id = ?\", whereSelectionParams, \"data2\");\n         c contactName = new c((String) null, (String) null, (String) null, (String) null, (String) null, 31, (i) null);\n         while (nameCur != null && nameCur.moveToNext()) {\n             contactName.f(nameCur.getString(nameCur.getColumnIndex(\"data2\")));\n             contactName.h(nameCur.getString(nameCur.getColumnIndex(\"data3\")));\n             contactName.g(nameCur.getString(nameCur.getColumnIndex(\"data1\")));\n             contactName.i(nameCur.getString(nameCur.getColumnIndex(\"data4\")));\n             contactName.j(nameCur.getString(nameCur.getColumnIndex(\"data6\")));\n         }\n         if (nameCur != null) {\n             nameCur.close();\n         }\n         return contactName;\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/d/a/e/h/m0/d.java",
              "file_line": [
                1675
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.475-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9c5b9afd-7640-4106-a9a1-839b113f36cf",
              "value": "private String AFKeystoreWrapper() {\n         Cursor cursor;\n         Throwable th;\n         try {\n             ContentResolver contentResolver = ((ax) this).AFInAppEventType.getContentResolver();\n             StringBuilder sb = new StringBuilder(\"content:\n             sb.append(((ax) this).values);\n             cursor = contentResolver.query(Uri.parse(sb.toString()), new String[]{\"aid\"}, null, null, null);\n             if (cursor != null) {\n                 try {\n                     if (cursor.moveToFirst()) {\n                         String string = cursor.getString(cursor.getColumnIndex(\"aid\"));\n                         cursor.close();\n                         return string;\n                     }\n                 } catch (Throwable th2) {\n                     th = th2;\n                     if (cursor != null) {\n                         cursor.close();\n                     }\n                     throw th;\n                 }\n             }\n             if (cursor != null) {\n                 cursor.close();\n             }\n             return null;\n         } catch (Throwable th3) {\n             cursor = null;\n             th = th3;\n         }\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/appsflyer/internal/ae.java",
              "file_line": [
                84
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.381-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "48c16787-5f0c-4d6c-9d8f-7aa6c20081cc",
              "value": "public final void h(Context context, String fileName, Bitmap bitmap, int quality) {\n         Uri imageCollection;\n         q.f(context, \"context\");\n         q.f(fileName, \"fileName\");\n         q.f(bitmap, \"bitmap\");\n         if (j0.a()) {\n             imageCollection = MediaStore.Images.Media.getContentUri(\"external_primary\");\n         } else {\n             imageCollection = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;\n         }\n         ContentValues imageDetails = new ContentValues();\n         imageDetails.put(\"_display_name\", q.n(fileName, \".jpeg\"));\n         imageDetails.put(\"mime_type\", \"image/jpg\");\n         ContentResolver $this$saveBitmapFile_u24lambda_u2d6 = context.getContentResolver();\n         try {\n             Uri fileUri = $this$saveBitmapFile_u24lambda_u2d6.insert(imageCollection, imageDetails);\n             if (fileUri != null) {\n                 OutputStream fos = $this$saveBitmapFile_u24lambda_u2d6.openOutputStream(fileUri);\n                 bitmap.compress(Bitmap.CompressFormat.JPEG, quality, fos);\n                 bitmap.recycle();\n                 if (fos == null) {\n                     return;\n                 }\n                 fos.close();\n             }\n         } catch (Exception error$iv) {\n             a.j(error$iv);\n         }\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/d/a/e/h/d.java",
              "file_line": [
                485
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.429-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6b5c7103-e7fb-4e4e-bc5c-3c7993a705f7",
              "value": "public static MediaResult j(Context context, Uri uri) {\n         String schema = uri.getScheme();\n         long size = -1;\n         String name = \"\";\n         String mimeType = \"\";\n         if (\"content\".equals(schema)) {\n             String[] projection = {\"_size\", \"_display_name\"};\n             ContentResolver contentResolver = context.getContentResolver();\n             Cursor cursor = contentResolver.query(uri, projection, null, null, null);\n             String mimeType2 = contentResolver.getType(uri);\n             if (cursor == null) {\n                 mimeType = mimeType2;\n             } else {\n                 try {\n                     if (cursor.moveToFirst()) {\n                         size = cursor.getLong(cursor.getColumnIndex(\"_size\"));\n                         name = cursor.getString(cursor.getColumnIndex(\"_display_name\"));\n                     }\n                     cursor.close();\n                     mimeType = mimeType2;\n                 } catch (Throwable th) {\n                     cursor.close();\n                     throw th;\n                 }\n             }\n         }\n         return new MediaResult((File) null, uri, uri, name, mimeType, size, -1L, -1L);\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/s/a/v.java",
              "file_line": [
                319
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.580-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "347204fb-050a-44aa-a765-b03a96e3ca61",
              "value": "public final a d(String id) {\n         String[] whereSelectionParams = {\"vnd.android.cursor.item/organization\", id};\n         a companyValue = new a((String) null, (String) null, (String) null, 7, (i) null);\n         Cursor companyCur = h().query(ContactsContract.Data.CONTENT_URI, null, \"mimetype = ? AND contact_id = ?\", whereSelectionParams, null);\n         while (companyCur != null && companyCur.moveToNext()) {\n             companyValue.d(companyCur.getString(companyCur.getColumnIndex(\"data1\")));\n             companyValue.e(companyCur.getString(companyCur.getColumnIndex(\"data5\")));\n             companyValue.f(companyCur.getString(companyCur.getColumnIndex(\"data4\")));\n         }\n         if (companyCur != null) {\n             companyCur.close();\n         }\n         return companyValue;\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/d/a/e/h/m0/d.java",
              "file_line": [
                376
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.444-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5ca12d1b-38d8-4d8e-898c-2613bdf7b8a4",
              "value": "public final e e(String phoneNumber) {\n         String name;\n         q.f(phoneNumber, \"phoneNumber\");\n         if (p.B(c().getContext())) {\n             char c = 1;\n             String[] selectionArgs = {'%' + phoneNumber + '%'};\n             Cursor cursor = h().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, d.d, \"replace(replace(replace(replace(data1, '-',''),'(',''),')',''),' ','') LIKE ?\", selectionArgs, \"display_name ASC LIMIT 1\");\n             List contacts = new ArrayList();\n             q.d(cursor);\n             cursor.moveToFirst();\n             while (!cursor.isAfterLast()) {\n                 String[] strArr = d.d;\n                 long id = cursor.getLong(cursor.getColumnIndex(strArr[0]));\n                 String lookupKey = cursor.getString(cursor.getColumnIndex(strArr[c]));\n                 String string = cursor.getString(cursor.getColumnIndex(strArr[2]));\n                 if (string != null) {\n                     name = string;\n                 } else {\n                     name = \"\";\n                 }\n                 String phone = cursor.getString(cursor.getColumnIndex(strArr[3]));\n                 if (phone == null) {\n                     phone = \"\";\n                 }\n                 q.e(lookupKey, \"lookupKey\");\n                 contacts.add(new e(id, lookupKey, name, u.B(u.B(u.B(u.B(phone, \" \", \"\", false, 4), \"(\", \"\", false, 4), \")\", \"\", false, 4), \"-\", \"\", false, 4)));\n                 cursor.moveToNext();\n                 c = 1;\n             }\n             cursor.close();\n             return (e) w.Z(contacts);\n         }\n         return null;\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/d/a/e/h/m0/d.java",
              "file_line": [
                544
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.457-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "78487cf0-a131-45c8-b2ad-92126c59fa94",
              "value": "public Cursor getSearchManagerSuggestions(SearchableInfo searchable, String query, int limit) {\n         String authority;\n         String[] selArgs;\n         if (searchable == null || (authority = searchable.getSuggestAuthority()) == null) {\n             return null;\n         }\n         Uri.Builder uriBuilder = new Uri.Builder().scheme(\"content\").authority(authority).query(\"\").fragment(\"\");\n         String contentPath = searchable.getSuggestPath();\n         if (contentPath != null) {\n             uriBuilder.appendEncodedPath(contentPath);\n         }\n         uriBuilder.appendPath(\"search_suggest_query\");\n         String selection = searchable.getSuggestSelection();\n         if (selection != null) {\n             String[] selArgs2 = {query};\n             selArgs = selArgs2;\n         } else {\n             uriBuilder.appendPath(query);\n             selArgs = null;\n         }\n         if (limit > 0) {\n             uriBuilder.appendQueryParameter(\"limit\", String.valueOf(limit));\n         }\n         Uri uri = uriBuilder.build();\n         return ((SuggestionsAdapter) this).mProviderContext.getContentResolver().query(uri, null, selection, selArgs, null);\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SuggestionsAdapter.java",
              "file_line": [
                2084
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.301-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "09a2fffd-08bc-472b-952c-a23e64321db3",
              "value": "public static boolean exists(Context context, Uri self) {\n         ContentResolver resolver = context.getContentResolver();\n         Cursor c = null;\n         try {\n             c = resolver.query(self, new String[]{\"document_id\"}, null, null, null);\n             return c.getCount() > 0;\n         } catch (Exception e) {\n             Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             return false;\n         } finally {\n             DocumentsContractApi19.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/DocumentsContractApi19.java",
              "file_line": [
                236
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.320-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3628a103-73aa-412d-a1ca-7033cd3f3a75",
              "value": "public DocumentFile[] listFiles() {\n         ContentResolver resolver = ((TreeDocumentFile) this).mContext.getContentResolver();\n         Uri uri = ((TreeDocumentFile) this).mUri;\n         Uri childrenUri = DocumentsContract.buildChildDocumentsUriUsingTree(uri, DocumentsContract.getDocumentId(uri));\n         ArrayList<Uri> results = new ArrayList<>();\n         Cursor c = null;\n         try {\n             try {\n                 c = resolver.query(childrenUri, new String[]{\"document_id\"}, null, null, null);\n                 while (c.moveToNext()) {\n                     String documentId = c.getString(0);\n                     Uri documentUri = DocumentsContract.buildDocumentUriUsingTree(((TreeDocumentFile) this).mUri, documentId);\n                     results.add(documentUri);\n                 }\n             } catch (Exception e) {\n                 Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             }\n             Uri[] result = (Uri[]) results.toArray(new Uri[results.size()]);\n             DocumentFile[] resultFiles = new DocumentFile[result.length];\n             for (int i = 0; i < result.length; i++) {\n                 resultFiles[i] = new TreeDocumentFile(this, ((TreeDocumentFile) this).mContext, result[i]);\n             }\n             return resultFiles;\n         } finally {\n             TreeDocumentFile.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/TreeDocumentFile.java",
              "file_line": [
                439
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.359-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "57fad032-e946-41ed-970c-ce51b2d7927a",
              "value": "public Cursor a(Uri uri) {\n         String imageId = uri.getLastPathSegment();\n         return ((c.a) this).b.query(MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI, c.a.a, \"kind = 1 AND image_id = ?\", new String[]{imageId}, null);\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/b/a/m/m/o/c$a.java",
              "file_line": [
                89
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.396-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8d3cbb76-f596-4d12-b2ec-220d26596baa",
              "value": "public Cursor a(Uri uri) {\n         String videoId = uri.getLastPathSegment();\n         return ((c.b) this).b.query(MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI, c.b.a, \"kind = 1 AND video_id = ?\", new String[]{videoId}, null);\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/b/a/m/m/o/c$b.java",
              "file_line": [
                89
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.411-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ec44f6cd-dbbb-4ef1-a6ac-d4c1e1743f6c",
              "value": "public static long getContentSize(Uri contentUri) {\n         Cursor cursor = null;\n         try {\n             cursor = FacebookSdk.getApplicationContext().getContentResolver().query(contentUri, null, null, null, null);\n             int sizeIndex = cursor.getColumnIndex(\"_size\");\n             cursor.moveToFirst();\n             long j = cursor.getLong(sizeIndex);\n             cursor.close();\n             return j;\n         } catch (Throwable th) {\n             if (cursor != null) {\n                 cursor.close();\n             }\n             throw th;\n         }\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/Utility.java",
              "file_line": [
                1513
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.488-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "33e6d63c-ee4c-437b-bbfb-1dadb806f2c4",
              "value": "public static String zza(ContentResolver contentResolver, String str, String str2) {\n         synchronized (zzgv.class) {\n             String str3 = null;\n             if (zzgv.zze == null) {\n                 zzgv.zzk.set(false);\n                 zzgv.zze = new HashMap();\n                 zzgv.zzl = new Object();\n                 zzgv.zzm = false;\n                 contentResolver.registerContentObserver(zzgv.zza, true, new zzgu((Handler) null));\n             } else if (zzgv.zzk.getAndSet(false)) {\n                 zzgv.zze.clear();\n                 zzgv.zzf.clear();\n                 zzgv.zzg.clear();\n                 zzgv.zzh.clear();\n                 zzgv.zzi.clear();\n                 zzgv.zzl = new Object();\n                 zzgv.zzm = false;\n             }\n             Object obj = zzgv.zzl;\n             if (zzgv.zze.containsKey(str)) {\n                 String str4 = (String) zzgv.zze.get(str);\n                 if (str4 != null) {\n                     str3 = str4;\n                 }\n                 return str3;\n             }\n             int length = zzgv.zzj.length;\n             Cursor query = contentResolver.query(zzgv.zza, null, null, new String[]{str}, null);\n             if (query == null) {\n                 return null;\n             }\n             try {\n                 if (!query.moveToFirst()) {\n                     zzgv.zzc(obj, str, (String) null);\n                 } else {\n                     String string = query.getString(1);\n                     if (string != null && string.equals(null)) {\n                         string = null;\n                     }\n                     zzgv.zzc(obj, str, string);\n                     if (string != null) {\n                         str3 = string;\n                     }\n                 }\n                 return str3;\n             } finally {\n                 query.close();\n             }\n         }\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/internal/measurement/zzgv.java",
              "file_line": [
                326
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.513-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7c9dd35a-7662-4386-b47e-c2dea343af02",
              "value": "public static String g(Context context, Uri uri) {\n         String schema = uri.getScheme();\n         String path = \"\";\n         if (\"content\".equals(schema)) {\n             String[] projection = {\"_display_name\"};\n             ContentResolver contentResolver = context.getContentResolver();\n             Cursor cursor = contentResolver.query(uri, projection, null, null, null);\n             if (cursor == null) {\n                 return \"\";\n             }\n             try {\n                 if (cursor.moveToFirst()) {\n                     path = cursor.getString(0);\n                 }\n                 return path;\n             } finally {\n                 cursor.close();\n             }\n         } else if (!\"file\".equals(schema)) {\n             return \"\";\n         } else {\n             String path2 = uri.getLastPathSegment();\n             return path2;\n         }\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/s/a/v.java",
              "file_line": [
                187
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.562-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "261ae6d7-bd1e-423e-bfbd-01a715009b8b",
              "value": "r0.close();\n      */\n     \n     public static int getExifOrientation(ContentResolver contentResolver, Uri uri) {\n         Cursor cursor = null;\n         try {\n             cursor = contentResolver.query(uri, MediaStoreRequestHandler.CONTENT_ORIENTATION, null, null, null);\n             if (cursor != null && cursor.moveToFirst()) {\n                 int i = cursor.getInt(0);\n                 cursor.close();\n                 return i;\n             }\n             return 0;\n         } catch (RuntimeException e) {\n             if (cursor != null) {\n                 cursor.close();\n             }\n             return 0;\n         } catch (Throwable th) {\n             if (cursor != null) {\n                 cursor.close();\n             }\n             throw th;\n         }\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/squareup/picasso/MediaStoreRequestHandler.java",
              "file_line": [
                70
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.530-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "26d20271-846d-448a-976a-3282d0b26b64",
              "value": "public final void r(Uri fileUri) {\n         FileDescriptor fileDescriptor;\n         try {\n             ParcelFileDescriptor openFileDescriptor = getContentResolver().openFileDescriptor(fileUri, \"r\");\n             if (openFileDescriptor != null && (fileDescriptor = openFileDescriptor.getFileDescriptor()) != null) {\n                 FileInputStream inputStream = new FileInputStream(fileDescriptor);\n                 File target = InternalLeakCanary.INSTANCE.createLeakDirectoryProvider(this).i();\n                 if (target != null) {\n                     FileOutputStream output = new FileOutputStream(target);\n                     a.a(inputStream, output, 8192);\n                     b.a(output, (Throwable) null);\n                     b.a(inputStream, (Throwable) null);\n                     HeapAnalyzerService.a.b(HeapAnalyzerService.c, this, target, (Long) null, (String) null, 12);\n                 }\n             }\n         } catch (IOException e) {\n             a1 this_$iv = a1.b;\n             a1.a logger$iv = this_$iv.a();\n             if (logger$iv != null) {\n                 logger$iv.b(e, \"Could not imported Hprof file\");\n             }\n         }\n     }",
              "vulnerability_id": "9e333b96-d747-4b28-b374-28578c466220",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/leakcanary/internal/activity/LeakActivity.java",
              "file_line": [
                801
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.547-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "7dbb32e0-67ff-4cd3-8470-c9c124af7dae",
          "title": "WebviewClient Should Override Url Loading",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team identified a potential security risk in the shouldOverrideUrlLoading(WebView view, WebResourceRequest request) method within the <b>Fake App</b> application&#39;s code. This method enables developers to override the default URL loading behavior of WebView when a new URL request is made. However, if this functionality is not handled carefully, it could lead to various security vulnerabilities.</p>\n<p>The code snippet below demonstrates the vulnerable implementation:</p>\n",
              "remediation": "<p>To mitigate the identified vulnerability, the assessment team recommends implementing the following security measures:</p>\n<p>Validate and Sanitize Requests: Rigorously validate and sanitize the WebResourceRequest object to prevent potential injection attacks or unauthorized access to sensitive information.</p>\n<p>Apply a Content Security Policy (CSP): Implement a Content Security Policy to limit the allowed sources for the WebView&#39;s loaded resources, thereby reducing the risk of malicious content loading.</p>\n<p>URL Whitelisting: Establish a URL whitelisting mechanism to allow only trusted URLs to be loaded, thus preventing access to potentially harmful sites.</p>\n<p>Use Secure Communication: Ensure web resources are loaded over HTTPS to maintain encrypted communication and protect against potential eavesdropping or data interception.</p>\n<p>Monitor External URLs: Vigilantly monitor and validate external URLs loaded by the WebView to prevent malicious URL redirection.</p>\n<p>Keep WebView Updated: Consistently update WebView and the Android system to take advantage of the latest security patches and improvements, thereby diminishing the risk of exploitation through known vulnerabilities.</p>\n",
              "impact": "<p>If the shouldOverrideUrlLoading(WebView view, WebResourceRequest request) method is not properly secured, attackers could exploit this vulnerability to manipulate URL loading behavior. Such exploitation could result in unauthorized redirection, phishing attacks, or the execution of malicious scripts through manipulated URLs. This vulnerability poses a significant threat to user security, potentially leading to data breaches or unauthorized access to sensitive information.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó un posible riesgo de seguridad en el método shouldOverrideUrlLoading(WebView view, WebResourceRequest request) dentro del código de la aplicación <b>Fake App</b>. Este método permite a los desarrolladores anular el comportamiento de carga de URL por defecto del WebView cuando se realiza una nueva solicitud de URL. Sin embargo, si esta funcionalidad no se maneja con cuidado, podría conducir a varias vulnerabilidades de seguridad.</p>\n<p>El fragmento de código a continuación muestra la implementación vulnerable:</p>\n",
              "remediation": "<p>Para mitigar la vulnerabilidad identificada, el equipo de evaluación recomienda implementar las siguientes medidas de seguridad:</p>\n<p>Validar y Sanear Solicitudes: Validar y sanear rigurosamente el objeto WebResourceRequest para prevenir posibles ataques de inyección o acceso no autorizado a información sensible.</p>\n<p>Aplicar una Política de Seguridad de Contenido (CSP): Implementar una Política de Seguridad de Contenido para limitar las fuentes permitidas para los recursos cargados por el WebView, reduciendo así el riesgo de carga de contenido malicioso.</p>\n<p>Lista Blanca de URLs: Establecer un mecanismo de lista blanca de URLs para permitir solo la carga de URLs confiables, evitando así el acceso a sitios potencialmente dañinos.</p>\n<p>Usar Comunicación Segura: Asegurar que los recursos web se carguen a través de HTTPS para mantener una comunicación cifrada y proteger contra posibles interceptaciones de datos o escuchas.</p>\n<p>Monitorear URLs Externas: Monitorear y validar las URLs externas cargadas por el WebView para prevenir redirecciones maliciosas de URLs.</p>\n<p>Mantener WebView Actualizado: Actualizar regularmente WebView y el sistema Android para aprovechar los últimos parches de seguridad y mejoras, disminuyendo así el riesgo de explotación a través de vulnerabilidades conocidas.</p>\n",
              "impact": "<p>Si el método shouldOverrideUrlLoading(WebView view, WebResourceRequest request) no está adecuadamente asegurado, los atacantes podrían explotar esta vulnerabilidad para manipular el comportamiento de carga de URL. Tal explotación podría resultar en redirecciones no autorizadas, ataques de phishing o la ejecución de scripts maliciosos a través de URLs manipuladas. Esta vulnerabilidad representa una amenaza significativa para la seguridad del usuario, pudiendo llevar a violaciones de datos o acceso no autorizado a información sensible.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Exploiting Android WebView Vulnerabilities | by Sanatsu | Mobis3c | Medium",
              "url": "https://medium.com/mobis3c/exploiting-android-webview-vulnerabilities-e2bcff780892"
            },
            {
              "label": "Webview Attacks - HackTricks",
              "url": "https://book.hacktricks.xyz/mobile-pentesting/android-app-pentesting/webview-attacks"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0083"
          },
          "evidences": [
            {
              "id": "d5012b41-8701-404b-a9b1-e6e7b2e8e80a",
              "value": "public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n         Uri requestUrl = request == null ? null : request.getUrl();\n         if (requestUrl != null && WebViewFragment.g(((WebViewFragment.c) this).a, requestUrl.getScheme())) {\n             Context requireContext = ((WebViewFragment.c) this).a.requireContext();\n             q.e(requireContext, \"requireContext()\");\n             g.b(requireContext, requestUrl, (a) null, 2);\n             return true;\n         }\n         return super.shouldOverrideUrlLoading(view, request);\n     }",
              "vulnerability_id": "7dbb32e0-67ff-4cd3-8470-c9c124af7dae",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/fake/app/home/screens/webview/WebViewFragment$c.java",
              "file_line": [
                201
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.244-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "d0d7bda9-8f85-4a28-8dc4-8591e7677ee7",
          "title": "Webview loadUrl usage",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team discovered that within the <b>Fake App</b> application, the method <b>myWebView.loadUrl(url)</b> is used to load web content into the WebView component of Android applications. However, if this functionality is not managed cautiously, it can expose the app to several security vulnerabilities. These include Cross-Site Scripting (XSS) attacks, Open Redirect vulnerabilities, JavaScript exploitation, and violations of the Same-Origin Policy. </p>\n<p>The code snippet below demonstrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends the following mitigations:</p>\n<p>Input Validation: Implement comprehensive validation and sanitization of user-provided URLs to prevent injection attacks.</p>\n<p>Disable JavaScript When Not Needed: Only enable JavaScript in WebView if it&#39;s essential for the app&#39;s functionality. This approach reduces the attack surface.</p>\n<p>Use Secure Communication: Ensure web content is loaded over HTTPS to maintain encrypted communication and protect user data.</p>\n<p>Configure WebView Settings Properly: Adjust WebView settings to disable file access from file URLs and enforce the Same-Origin Policy.</p>\n<p>Implement a Web Content Security Policy: Establish a Content Security Policy (CSP) to limit the types of content that can be loaded in WebView, thus mitigating XSS attacks.</p>\n<p>Regularly Update WebView and Android System: Keep WebView and the Android system updated to take advantage of the latest security patches and improvements.</p>\n",
              "impact": "<p>An attacker could exploit these vulnerabilities to gain unauthorized access, steal sensitive user data, execute malicious scripts, or redirect users to harmful websites. Such exploits can seriously compromise both the security and the integrity of the application and its users.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que dentro de la aplicación <b>Fake App</b>, el método <b>myWebView.loadUrl(url)</b> se utiliza para cargar contenido web en el componente WebView de las aplicaciones Android. Sin embargo, si esta funcionalidad no se maneja con precaución, puede exponer la aplicación a varias vulnerabilidades de seguridad. Estas incluyen ataques de Cross-Site Scripting (XSS), vulnerabilidades de tipo Open Redirect, explotación de JavaScript y violaciones de la Política de Mismo Origen.</p>\n<p>El fragmento de código a continuación muestra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes medidas de mitigación:</p>\n<p>Validación de Entradas: Implementar una validación y saneamiento exhaustivos de las URLs proporcionadas por los usuarios para prevenir ataques de inyección.</p>\n<p>Deshabilitar JavaScript Cuando No Sea Necesario: Habilitar JavaScript en WebView solo si es esencial para la funcionalidad de la aplicación. Este enfoque reduce la superficie de ataque.</p>\n<p>Usar Comunicación Segura: Asegurar que el contenido web se cargue sobre HTTPS para mantener una comunicación cifrada y proteger los datos de los usuarios.</p>\n<p>Configurar Adecuadamente los Ajustes de WebView: Ajustar los ajustes de WebView para deshabilitar el acceso a archivos desde URLs de archivos y hacer cumplir la Política de Mismo Origen.</p>\n<p>Implementar una Política de Seguridad de Contenido Web: Establecer una Política de Seguridad de Contenido (CSP) para limitar los tipos de contenido que pueden cargarse en WebView, mitigando así ataques XSS.</p>\n<p>Actualizar Regularmente WebView y el Sistema Android: Mantener actualizados WebView y el sistema Android para aprovechar los últimos parches de seguridad y mejoras.</p>\n",
              "impact": "<p>Un atacante podría aprovechar estas vulnerabilidades para obtener acceso no autorizado, robar datos sensibles de los usuarios, ejecutar scripts maliciosos o redirigir a los usuarios a sitios web dañinos. Estos ataques pueden comprometer seriamente tanto la seguridad como la integridad de la aplicación y sus usuarios.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Exploiting Android WebView Vulnerabilities | by Sanatsu | Mobis3c | Medium",
              "url": "https://medium.com/mobis3c/exploiting-android-webview-vulnerabilities-e2bcff780892"
            },
            {
              "label": "Webview Attacks - HackTricks",
              "url": "https://book.hacktricks.xyz/mobile-pentesting/android-app-pentesting/webview-attacks"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-2",
            "maswe": "MASWE-0071"
          },
          "evidences": [
            {
              "id": "7d197ed9-e06e-4a96-b70e-b5b81fbc1648",
              "value": "public final void D() {\n         ((c) this).j.a();\n         if (((a) this).f.i().isEmpty()) {\n             Point point = ((c) this).j.a;\n             int mHeight = point.y;\n             int mWidth = point.x;\n             float d = getResources().getDisplayMetrics().density;\n             String html = ((a) this).f.m();\n             String style = \"<style>body{width:\" + ((int) (mWidth / d)) + \"px; height: \" + ((int) (mHeight / d)) + \"px; margin: 0; padding:0;}</style>\";\n             String html2 = html.replaceFirst(\"<head>\", \"<head>\" + style);\n             c0.n(\"Density appears to be \" + d);\n             ((c) this).j.setInitialScale((int) (100.0f * d));\n             ((c) this).j.loadDataWithBaseURL(null, html2, \"text/html\", \"utf-8\", null);\n             return;\n         }\n         String url = ((a) this).f.i();\n         ((c) this).j.setWebViewClient(new WebViewClient());\n         ((c) this).j.loadUrl(url);\n     }",
              "vulnerability_id": "d0d7bda9-8f85-4a28-8dc4-8591e7677ee7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/o0/c.java",
              "file_line": [
                291
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.805-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "39fcc687-de11-40f4-9f8e-13eb5a1e8c1e",
              "value": "public final void s() {\n         ((f) this).l.a();\n         Point point = ((f) this).l.a;\n         int mHeight = point.y;\n         int mWidth = point.x;\n         float d = getResources().getDisplayMetrics().density;\n         String html = ((a) this).f.m();\n         String style = \"<style>body{width:\" + ((int) (mWidth / d)) + \"px; height: \" + ((int) (mHeight / d)) + \"px; margin: 0; padding:0;}</style>\";\n         String html2 = html.replaceFirst(\"<head>\", \"<head>\" + style);\n         c0.n(\"Density appears to be \" + d);\n         ((f) this).l.setInitialScale((int) (100.0f * d));\n         ((f) this).l.loadDataWithBaseURL(null, html2, \"text/html\", \"utf-8\", null);\n     }",
              "vulnerability_id": "d0d7bda9-8f85-4a28-8dc4-8591e7677ee7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/o0/f.java",
              "file_line": [
                439
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.933-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "04ec521c-01cb-4ad0-aa26-c7b494afd64e",
              "value": "public void cancel() {\n         WebView webView = getWebView();\n         if (!isPageFinished() || isListenerCalled() || webView == null || !webView.isShown()) {\n             super.cancel();\n         } else if (((FacebookWebFallbackDialog) this).waitingForDialogToClose) {\n         } else {\n             ((FacebookWebFallbackDialog) this).waitingForDialogToClose = true;\n             webView.loadUrl(\"javascript:(function() {  var event = document.createEvent('Event');  event.initEvent('fbPlatformDialogMustClose',true,true);  document.dispatchEvent(event);})();\");\n             Handler handler = new Handler(Looper.getMainLooper());\n             handler.postDelayed(new FacebookWebFallbackDialog.1(this), 1500L);\n         }\n     }",
              "vulnerability_id": "d0d7bda9-8f85-4a28-8dc4-8591e7677ee7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/FacebookWebFallbackDialog.java",
              "file_line": [
                143
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.267-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "56235984-8aa1-4c75-9981-1dbbeea7c7eb",
              "value": "private void redirectTo3DsCheck(String urlToRedirect) {\n         CookieManager.getInstance().setAcceptCookie(true);\n         ((CreditCardPaymentActivity) this).service.setup3DsWebView(((CreditCardPaymentActivity) this).threeDsWebView);\n         ((CreditCardPaymentActivity) this).threeDsWebView.setWebViewClient(new CreditCardPaymentActivity.8(this));\n         ((CreditCardPaymentActivity) this).threeDsWebView.loadUrl(urlToRedirect);\n     }",
              "vulnerability_id": "d0d7bda9-8f85-4a28-8dc4-8591e7677ee7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/payfort/fort/android/sdk/activities/CreditCardPaymentActivity.java",
              "file_line": [
                944
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.315-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f82e9d01-b835-46fa-9043-13c795f5d7ca",
              "value": "public void run() {\n         ArticleView.access$200(((ArticleView.1.1) this).this$1.this$0).loadDataWithBaseURL(((ArticleView.1.1) this).this$1.val$article.getUrl(), ((ArticleView.1.1) this).val$html, \"text/html\", \"UTF-8\", ((ArticleView.1.1) this).this$1.val$article.getUrl());\n     }",
              "vulnerability_id": "d0d7bda9-8f85-4a28-8dc4-8591e7677ee7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/zendesk/answerbot/ArticleView$1$1.java",
              "file_line": [
                80
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.405-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "cb0fc709-06ff-48db-9cc6-55b0f56e31c4",
              "value": "public static final void F(WebViewFragment this$0, e user) {\n         q.f(this$0, \"this$0\");\n         String id = user == null ? null : user.h();\n         if (id == null) {\n             id = \"\";\n         }\n         String c = user == null ? null : user.c();\n         String token = c != null ? c : \"\";\n         View view = this$0.getView();\n         WebSettings $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0 = ((WebView) (view == null ? null : view.findViewById(2131429516))).getSettings();\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setJavaScriptEnabled(true);\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setJavaScriptCanOpenWindowsAutomatically(true);\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setDomStorageEnabled(true);\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setLoadWithOverviewMode(true);\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setCacheMode(2);\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setMixedContentMode(0);\n         String language = (String) this$0.getViewModel().b().getValue();\n         View view2 = this$0.getView();\n         ((WebView) (view2 == null ? null : view2.findViewById(2131429516))).setWebViewClient(new WebViewFragment.c(this$0));\n         CookieManager cookieManager = CookieManager.getInstance();\n         View view3 = this$0.getView();\n         cookieManager.setAcceptThirdPartyCookies((WebView) (view3 == null ? null : view3.findViewById(2131429516)), true);\n         String injection = this$0.h(token, id, language);\n         View view4 = this$0.getView();\n         ((WebView) (view4 != null ? view4.findViewById(2131429516) : null)).loadDataWithBaseURL(this$0.a, injection, null, \"UTF-8\", null);\n     }",
              "vulnerability_id": "d0d7bda9-8f85-4a28-8dc4-8591e7677ee7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/fake/app/home/screens/webview/WebViewFragment.java",
              "file_line": [
                341
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.712-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "25a3c8ed-d95a-4a0b-bb07-81731ab213c3",
              "value": "public void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n         setContentView(2131623987);\n         B();\n         y();\n         z();\n         WebView webView = (WebView) findViewById(2131429515);\n         webView.setWebViewClient(new ThreeDSecureWebViewActivty.a(this));\n         webView.getSettings().setJavaScriptEnabled(true);\n         webView.loadUrl(((ThreeDSecureWebViewActivty) this).a);\n     }",
              "vulnerability_id": "d0d7bda9-8f85-4a28-8dc4-8591e7677ee7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/ThreeDSecureWebViewActivty.java",
              "file_line": [
                109
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.363-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "48512c7d-ae6f-4892-864c-e15c68e62911",
              "value": "public final void j(String headerText, String termsUrl) {\n         ((TermsAndConditionsFragment) this).d.b.setText(headerText);\n         ((TermsAndConditionsFragment) this).d.c.loadUrl(termsUrl);\n     }",
              "vulnerability_id": "d0d7bda9-8f85-4a28-8dc4-8591e7677ee7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/fake/app/screens/mainscreens/settings/TermsAndConditionsFragment/TermsAndConditionsFragment.java",
              "file_line": [
                46
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:04.770-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "1fcf8d7c-6a69-4233-a106-874c76671114",
          "title": "Google Maps API Key Disclosed",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>Fake App</b> mobile application integrates Google Maps for geolocation functionality and the API key is disclosed in &lt;Source Code, Response, etc&gt;. It was found that the configuration of this API key could be accessed and used by unauthorized users, enabling them to consume the API without any restrictions.</p>\n<p>The code snippet below illustrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends implementing an IP/Referer or application restriction to control who can utilize the API key. Furthermore, the team suggests using a client ID authentication solution and signatures instead of relying solely on API keys.</p>\n<p>Additionally, it is advised to either remove the API key from the JavaScript file or restrict its use through the Google Developer Console at <a href=\"https://console.developers.google.com/\">https://console.developers.google.com/</a>.</p>\n",
              "impact": "<p>If Google Maps API keys are not properly secured and configured, an attacker could potentially:</p>\n<p>Consume the company’s monthly quota for the service.\nIncur significant financial costs to the company by unauthorized usage of the service, especially if there are no limitations set on API budgets.\nExecute a denial-of-service attack targeting the service, especially if there are controls for maximum billing in the Google account settings.\nIn this specific case, it was found that an attacker could generate requests using a Staticmap at an estimated cost of $2 per 1000 requests.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación móvil <b>Fake App</b> integra Google Maps para funcionalidades de geolocalización y la clave API se revela en &lt;Código Fuente, Respuesta, etc&gt;. Se encontró que la configuración de esta clave API podría ser accedida y utilizada por usuarios no autorizados, permitiéndoles consumir la API sin restricciones.</p>\n<p>El fragmento de código a continuación muestra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda implementar una restricción de IP/Referer o de aplicación para controlar quién puede utilizar la clave API. Además, el equipo sugiere usar una solución de autenticación con ID de cliente y firmas en lugar de depender únicamente de claves API.</p>\n<p>Adicionalmente, se aconseja eliminar la clave API del archivo JavaScript o restringir su uso a través de la Consola de Desarrolladores de Google en <a href=\"https://console.developers.google.com/\">https://console.developers.google.com/</a>.</p>\n",
              "impact": "<p>Si las claves de la API de Google Maps no están debidamente aseguradas y configuradas, un atacante podría:</p>\n<p>Consumir la cuota mensual de la empresa para el servicio.\nIncurrir en costos financieros significativos para la empresa mediante el uso no autorizado del servicio, especialmente si no hay límites establecidos en los presupuestos de la API.\nEjecutar un ataque de denegación de servicio dirigido al servicio, especialmente si existen controles para el límite máximo de facturación en las configuraciones de la cuenta de Google.\nEn este caso específico, se encontró que un atacante podría generar solicitudes utilizando un Staticmap a un costo estimado de $2 por cada 1000 solicitudes.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "API security best practices  |  Google Maps Platform  |  Google for Developers",
              "url": "https://developers.google.com/maps/api-security-best-practices"
            },
            {
              "label": "CWE - CWE-798: Use of Hard-coded Credentials (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/798.html"
            },
            {
              "label": "Use of hard-coded password | OWASP Foundation",
              "url": "https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-AUTH-1",
            "maswe": "MASWE-0005"
          },
          "evidences": [
            {
              "id": "114a2436-b367-44a5-a988-904c6c99463f",
              "value": "<string name=\"google_api_key\">AIzaSyDfLxyKcvwPkJdX5EZ69o8pL8lVqrbAu-g</string>\n    <string name=\"google_app_id\">1:715904638473:android:a24088457e8043073da2d8</string>\n    <string name=\"google_crash_reporting_api_key\">AIzaSyDfLxyKcvwPkJdX5EZ69o8pL8lVqrbAu-g</string>\n    <string name=\"google_storage_bucket\">fake-app-bef7e.appspot.com</string>\n    <string name=\"gotit\">Got It</string>",
              "vulnerability_id": "1fcf8d7c-6a69-4233-a106-874c76671114",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/res/values/strings.xml",
              "file_line": [
                493
              ],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T21:09:10.512-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4ab55082-b19d-4cbe-9ab7-a2e665c0cc36",
              "value": "your offer\"</string>\n    <string name=\"give_the_code_to_the_cashier_cashback\">Give the code to the cashier</string>\n    <string name=\"google_api_key\">AIzaSyDfLxyKcvwPkJdX5EZ69o8pL8lVqrbAu-g</string>\n    <string name=\"google_app_id\">1:715904638473:android:a24088457e8043073da2d8</string>\n    <string name=\"google_crash_reporting_api_key\">AIzaSyDfLxyKcvwPkJdX5EZ69o8pL8lVqrbAu-g</string>",
              "vulnerability_id": "1fcf8d7c-6a69-4233-a106-874c76671114",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/res/values/strings.xml",
              "file_line": [
                491
              ],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T21:09:10.493-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "50f80fc2-45c0-4e10-bc7a-4f86f7801cd5",
          "title": "Webview JavaScript enabled",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team discovered that in the Web View configuration of the <b>Fake App</b> application, the <b>setJavaScriptEnabled</b> property is enabled (set to true). This configuration may introduce multiple risks, including Cross Site Scripting (XSS) and Content Spoofing.</p>\n<p>The code snippet below illustrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends, if feasible, disabling the <b>setJavaScriptEnabled</b> property to prevent attacks such as XSS (Cross Site Scripting) and Content Spoofing. If disabling this property is not an option, it is highly advised to secure the API thoroughly to eliminate the possibility of payload injections.</p>\n",
              "impact": "<p>If JavaScript is enabled within the Web View configuration, it means that all JavaScript code from the loaded website will be executed within the Web View. Consequently, if an attacker manages to inject a Cross Site Scripting (XSS) payload, it will also be executed. The execution of such malicious scripts might result in unintended information leakage, modification of settings on the server side through bypassed CSRF protection, and other potential security threats.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que en la configuración de Web View de la aplicación <b>Fake App</b>, la propiedad <b>setJavaScriptEnabled</b> está habilitada (configurada en true). Esta configuración puede introducir múltiples riesgos, incluyendo Cross Site Scripting (XSS) y suplantación de contenido (Content Spoofing).</p>\n<p>El fragmento de código a continuación muestra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda, si es posible, deshabilitar la propiedad <b>setJavaScriptEnabled</b> para evitar ataques como XSS (Cross Site Scripting) y suplantación de contenido (Content Spoofing). Si no es posible deshabilitar esta propiedad, se aconseja encarecidamente asegurar la API de manera exhaustiva para eliminar la posibilidad de inyecciones de payload.</p>\n",
              "impact": "<p>Si JavaScript está habilitado en la configuración de Web View, significa que todo el código JavaScript del sitio web cargado será ejecutado dentro del Web View. Por lo tanto, si un atacante logra inyectar un payload de Cross Site Scripting (XSS), este también será ejecutado. La ejecución de dichos scripts maliciosos podría resultar en la filtración no intencionada de información, modificación de configuraciones en el lado del servidor a través de la protección CSRF eludida y otros posibles riesgos de seguridad.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "WebView Paper",
              "url": "https://arxiv.org/ftp/arxiv/papers/1304/1304.7451.pdf"
            },
            {
              "label": "Exploiting Android WebView Vulnerabilities | by Sanatsu | Mobis3c | Medium",
              "url": "https://medium.com/mobis3c/exploiting-android-webview-vulnerabilities-e2bcff780892"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-2",
            "maswe": "MASWE-0071"
          },
          "evidences": [
            {
              "id": "2b0522ee-00fe-48c3-bcbc-bc4ead055015",
              "value": "public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n         r c = r.c(inflater, container, false);\n         ((TermsAndConditionsFragment) this).d = c;\n         c.c.getSettings().setJavaScriptEnabled(true);\n         if (((TermsAndConditionsFragment) this).c.equals(\"TERMS\")) {\n             j(getString(2131952545), e.a.k());\n         } else if (((TermsAndConditionsFragment) this).c.equals(\"PRIVACY\")) {\n             j(getString(2131952434), e.a.g());\n         }\n         return ((TermsAndConditionsFragment) this).d.b();\n     }",
              "vulnerability_id": "50f80fc2-45c0-4e10-bc7a-4f86f7801cd5",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/fake/app/screens/mainscreens/settings/TermsAndConditionsFragment/TermsAndConditionsFragment.java",
              "file_line": [
                111
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.401-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "cfcf10b8-7e16-49c5-842f-70191276c649",
              "value": "public static final void F(WebViewFragment this$0, e user) {\n         q.f(this$0, \"this$0\");\n         String id = user == null ? null : user.h();\n         if (id == null) {\n             id = \"\";\n         }\n         String c = user == null ? null : user.c();\n         String token = c != null ? c : \"\";\n         View view = this$0.getView();\n         WebSettings $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0 = ((WebView) (view == null ? null : view.findViewById(2131429516))).getSettings();\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setJavaScriptEnabled(true);\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setJavaScriptCanOpenWindowsAutomatically(true);\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setDomStorageEnabled(true);\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setLoadWithOverviewMode(true);\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setCacheMode(2);\n         $this$onViewCreated_u24lambda_u2d1_u24lambda_u2d0.setMixedContentMode(0);\n         String language = (String) this$0.getViewModel().b().getValue();\n         View view2 = this$0.getView();\n         ((WebView) (view2 == null ? null : view2.findViewById(2131429516))).setWebViewClient(new WebViewFragment.c(this$0));\n         CookieManager cookieManager = CookieManager.getInstance();\n         View view3 = this$0.getView();\n         cookieManager.setAcceptThirdPartyCookies((WebView) (view3 == null ? null : view3.findViewById(2131429516)), true);\n         String injection = this$0.h(token, id, language);\n         View view4 = this$0.getView();\n         ((WebView) (view4 != null ? view4.findViewById(2131429516) : null)).loadDataWithBaseURL(this$0.a, injection, null, \"UTF-8\", null);\n     }",
              "vulnerability_id": "50f80fc2-45c0-4e10-bc7a-4f86f7801cd5",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/fake/app/home/screens/webview/WebViewFragment.java",
              "file_line": [
                203
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.386-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "59811392-5a3b-4806-a7d2-1885d62610fb",
              "value": "public void setup3DsWebView(WebView webView) {\n         webView.getSettings().setJavaScriptEnabled(true);\n         webView.getSettings().setAppCacheEnabled(false);\n         webView.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);\n         webView.getSettings().setDisplayZoomControls(true);\n         webView.getSettings().setSupportZoom(true);\n         webView.setVerticalScrollBarEnabled(true);\n         webView.setHorizontalScrollBarEnabled(true);\n     }",
              "vulnerability_id": "50f80fc2-45c0-4e10-bc7a-4f86f7801cd5",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/payfort/fort/android/sdk/activities/services/CreditPaymentService.java",
              "file_line": [
                1141
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.426-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "071b54b5-137b-43d7-b551-f70187296105",
              "value": "public void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n         setContentView(2131623987);\n         B();\n         y();\n         z();\n         WebView webView = (WebView) findViewById(2131429515);\n         webView.setWebViewClient(new ThreeDSecureWebViewActivty.a(this));\n         webView.getSettings().setJavaScriptEnabled(true);\n         webView.loadUrl(((ThreeDSecureWebViewActivty) this).a);\n     }",
              "vulnerability_id": "50f80fc2-45c0-4e10-bc7a-4f86f7801cd5",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/paymob/acceptsdk/ThreeDSecureWebViewActivty.java",
              "file_line": [
                104
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:10.449-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "d2f89b5f-cf7a-4a56-9e31-ade445a6c7f3",
          "title": "Access External Storage",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>Fake App</b> application utilizes external storage for reading and writing data. Storing data externally poses a risk as it can be accessed and modified by malicious applications on the same device. This vulnerability can lead to information disclosure, data tampering, or other forms of malicious behavior.</p>\n<p>The code snippet below illustrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends not storing executable files, configuration files, or sensitive user data on the external storage if its possible otherwise it should be strongly encrypted to avoid sensitive information to be disclosed.</p>\n",
              "impact": "<p>An attacker or a malicious application could exploit this vulnerability to access or modify the data stored in the external storage. This unauthorized access or modification could lead to serious security issues, including data breaches, information disclosure, and compromising the integrity of the application&#39;s data.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación <b>Fake App</b> utiliza almacenamiento externo para leer y escribir datos. El almacenamiento de datos de forma externa representa un riesgo, ya que puede ser accedido y modificado por aplicaciones maliciosas en el mismo dispositivo. Esta vulnerabilidad puede llevar a la divulgación de información, manipulación de datos u otras formas de comportamiento malicioso.</p>\n<p>El fragmento de código a continuación ilustra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda evitar almacenar archivos ejecutables, archivos de configuración o datos sensibles de usuarios en el almacenamiento externo siempre que sea posible. Si es necesario utilizar almacenamiento externo, es crucial emplear encriptación fuerte para prevenir la divulgación de información sensible.</p>\n",
              "impact": "<p>Un atacante o una aplicación maliciosa podría aprovechar esta vulnerabilidad para acceder o modificar los datos almacenados en el almacenamiento externo. Este acceso o modificación no autorizados podrían conducir a graves problemas de seguridad, incluyendo violaciones de datos, divulgación de información y compromiso de la integridad de los datos de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "M2: Insecure Data Storage | OWASP Foundation",
              "url": "https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage"
            },
            {
              "label": "MSTG- Testing Data Storage",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#external-storage"
            },
            {
              "label": "CWE - CWE-921: Storage of Sensitive Data in a Mechanism without Access Control (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/921.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "3a8b6ed8-5a41-4d03-a17f-70934ebecfc2",
              "value": "private static void refreshAvailableExternalStorage() {\n         try {\n             if (Utility.externalStorageExists()) {\n                 File path = Environment.getExternalStorageDirectory();\n                 StatFs stat = new StatFs(path.getPath());\n                 Utility.availableExternalStorageGB = stat.getAvailableBlocks() * stat.getBlockSize();\n             }\n             Utility.availableExternalStorageGB = Utility.convertBytesToGB(Utility.availableExternalStorageGB);\n         } catch (Exception e) {\n         }\n     }",
              "vulnerability_id": "d2f89b5f-cf7a-4a56-9e31-ade445a6c7f3",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/Utility.java",
              "file_line": [
                4345
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.521-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2f21322b-7d17-4299-b918-cf8e50e1f233",
              "value": "public final File[] h(Context context) {\n         File[] externalCacheDirs = context.getExternalCacheDirs();\n         q.c(externalCacheDirs, \"context.externalCacheDirs\");\n         return externalCacheDirs;\n     }",
              "vulnerability_id": "d2f89b5f-cf7a-4a56-9e31-ade445a6c7f3",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/leakcanary/internal/LeakCanaryFileProvider$a.java",
              "file_line": [
                178
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.567-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3b6d6652-181b-46a9-83b5-7df1b390378a",
              "value": "public final File[] i(Context context, String type) {\n         File[] externalFilesDirs = context.getExternalFilesDirs(type);\n         q.c(externalFilesDirs, \"context.getExternalFilesDirs(type)\");\n         return externalFilesDirs;\n     }",
              "vulnerability_id": "d2f89b5f-cf7a-4a56-9e31-ade445a6c7f3",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/leakcanary/internal/LeakCanaryFileProvider$a.java",
              "file_line": [
                199
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.583-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0f4fa125-837e-426d-8217-58f349be2ce4",
              "value": "private static void refreshTotalExternalStorage() {\n         try {\n             if (Utility.externalStorageExists()) {\n                 File path = Environment.getExternalStorageDirectory();\n                 StatFs stat = new StatFs(path.getPath());\n                 Utility.totalExternalStorageGB = stat.getBlockCount() * stat.getBlockSize();\n             }\n             Utility.totalExternalStorageGB = Utility.convertBytesToGB(Utility.totalExternalStorageGB);\n         } catch (Exception e) {\n         }\n     }",
              "vulnerability_id": "d2f89b5f-cf7a-4a56-9e31-ade445a6c7f3",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/Utility.java",
              "file_line": [
                4661
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.542-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "a5ace2f6-2b03-46f8-97a9-a2ea785635fc",
          "title": "Debug Enabled For App [android:debuggable=true]",
          "severity": "low",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>Fake App</b> application has the &#39;debuggable&#39; flag set to &#39;true&#39; in its <b>AndroidManifest.xml</b> file. Enabling debugging in the application simplifies the process for reverse engineers to analyze it and attach a debugger. This exposes the app to risks such as dumping stack traces and accessing debugging helper classes.</p>\n<p>The flag is evident in the following snippet from the Android Manifest file:</p>\n",
              "remediation": "<p>The assessment team strongly recommends ensuring that the <b>android:debuggable</b> flag is set to &#39;false&#39; when releasing your application. This practice is crucial for maintaining security and preventing unauthorized access or reverse engineering of the app.</p>\n",
              "impact": "<p>Setting the <b>android:debuggable</b> flag to &#39;true&#39; in the application <b>Fake App</b> allows debugging, which makes it easier for attackers to gain access to secure parts of the application. This setting increases the risk of sensitive functionalities and data being exposed, as it simplifies reverse engineering and unauthorized access.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación <b>Fake App</b> tiene el &#39;flag&#39; &#39;debuggable&#39; configurado en &#39;true&#39; en su archivo <b>AndroidManifest.xml</b>. Habilitar la depuración en la aplicación facilita a los analistas de ingeniería inversa para analizarla y conectar un depurador. Esto expone la aplicación a riesgos como el volcado de &#39;stack traces&#39; y el acceso a clases de ayuda para la depuración.</p>\n<p>El &#39;flag&#39; se puede ver en el siguiente fragmento del archivo Android Manifest:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda encarecidamente asegurarse de que el &#39;flag&#39; <b>android:debuggable</b> esté configurado en &#39;false&#39; al lanzar su aplicación. Esta práctica es crucial para mantener la seguridad y prevenir el acceso no autorizado o la ingeniería inversa de la app.</p>\n",
              "impact": "<p>Configurar el &#39;flag&#39; <b>android:debuggable</b> en &#39;true&#39; en la aplicación <b>Fake App</b> permite la depuración, lo que facilita que los atacantes accedan a partes seguras de la aplicación. Esta configuración aumenta el riesgo de que se expongan funcionalidades y datos sensibles, ya que simplifica la ingeniería inversa y el acceso no autorizado.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "android:debuggable  |  App quality  |  Android Developers",
              "url": "https://developer.android.com/topic/security/risks/android-debuggable"
            },
            {
              "label": "Exploiting debuggable android applications | Infosec",
              "url": "https://resources.infosecinstitute.com/topic/android-hacking-security-part-6-exploiting-debuggable-android-applications/"
            },
            {
              "label": "MSTG - Testing Code Quality",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#debuggable-apps"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0067"
          },
          "evidences": [
            {
              "id": "27e77a9e-7fc6-44ed-a465-31cb1eb7ed7c",
              "value": "<uses-permission android:name=\"com.google.android.c2dm.permission.RECEIVE\" />\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" />\n    <application android:theme=\"@style/AppTheme\" android:label=\"Fake App (Beta)\" android:icon=\"@mipmap/ic_launcher\" android:name=\"com.fake.app.application.FakeApp\" android:debuggable=\"true\" android:configChanges=\"layoutDirection|locale\" android:backupAgent=\"com.fake.app.backup.FakeAppBackupAgent\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:fullBackupOnly=\"true\" android:fullBackupContent=\"@xml/fake_app_backup_rules\" android:usesCleartextTraffic=\"true\" android:networkSecurityConfig=\"@xml/network_security_config\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:appComponentFactory=\"androidx.core.app.CoreComponentFactory\">\n        <activity android:theme=\"@style/ApplicationTheme\" android:name=\"com.fake.app.screens.mainscreens.Wallet.WalletPayment.AddFundsActivity\" android:exported=\"true\" android:launchMode=\"singleTask\" android:screenOrientation=\"portrait\" android:windowSoftInputMode=\"adjustResize\" />",
              "vulnerability_id": "a5ace2f6-2b03-46f8-97a9-a2ea785635fc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/AndroidManifest.xml",
              "file_line": [],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T21:09:08.559-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "3a611e7f-96d5-4dc3-b392-ad1c1835e39d",
          "title": "Application Allows Execution of Backups",
          "severity": "low",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>android:allowBackup</b> attribute is set to true in the Android Manifest file of the <b>Fake App</b> application. This setting determines if a user can back up and restore the application&#39;s data. When the backup flag is true, it permits an attacker to extract a backup of the application&#39;s data through adb/USB, even on unrooted devices.</p>\n",
              "remediation": "<p>To prevent unauthorized backup of the app data, set the <b>android:allowBackup</b> attribute to false. By default, the allowBackup setting is enabled if this attribute is not explicitly defined, necessitating manual deactivation. It&#39;s important to regularly review the <b>AndroidManifest.xml</b> file to ensure that the developer framework does not inadvertently include insecure default settings.</p>\n",
              "impact": "<p>Android includes an <b>allowBackup</b> attribute, used to enable the backup of all application data. This attribute is defined in the <b>AndroidManifest.xml</b> file. When its value is set to true, it permits users to back up the application data using the Android Debug Bridge (ADB). However, this setting can potentially expose sensitive data, as it allows for data backup without strong security controls, potentially leading to data leakage or unauthorized access if exploited.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que el atributo <b>android:allowBackup</b> está configurado como true en el archivo Android Manifest de la aplicación <b>Fake App</b>. Esta configuración determina si los datos de la aplicación pueden ser respaldados y restaurados por el usuario. Cuando el flag allowBackup está en true, permite a un atacante realizar un backup de los datos de la aplicación a través de adb/USB, incluso en dispositivos que no están rooteados.</p>\n",
              "remediation": "<p>Para prevenir el respaldo no autorizado de los datos de la aplicación, configure el atributo <b>android:allowBackup</b> en false. Por defecto, la configuración allowBackup está habilitada si este atributo no se define explícitamente, lo que requiere una desactivación manual. Es importante revisar regularmente el archivo <b>AndroidManifest.xml</b> para asegurarse de que el marco de desarrollo no incluya por error configuraciones predeterminadas inseguras.</p>\n",
              "impact": "<p>Android incluye un atributo llamado <b>allowBackup</b>, utilizado para habilitar el respaldo de todos los datos de una aplicación. Este atributo se define en el archivo <b>AndroidManifest.xml</b>. Cuando su valor está configurado en true, permite a los usuarios respaldar los datos de la aplicación utilizando el Android Debug Bridge (ADB). Sin embargo, esta configuración puede exponer datos sensibles, ya que permite realizar copias de seguridad de datos sin controles de seguridad estrictos, lo que podría llevar a la filtración de datos o acceso no autorizado si se explota.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "MSTG - Testing Backups",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-backups-for-sensitive-data-mstg-storage-8"
            },
            {
              "label": "Back up user data with Auto Backup  |  Android Developers",
              "url": "https://developer.android.com/guide/topics/data/autobackup"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-2",
            "maswe": "MASWE-0003"
          },
          "evidences": [
            {
              "id": "99c8a0cd-68cd-4201-a2d4-56139ce9ccb6",
              "value": "<uses-permission android:name=\"com.google.android.c2dm.permission.RECEIVE\" />\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" />\n    <application android:theme=\"@style/AppTheme\" android:label=\"Fake App (Beta)\" android:icon=\"@mipmap/ic_launcher\" android:name=\"com.fake.app.application.FakeApp\" android:debuggable=\"true\" android:configChanges=\"layoutDirection|locale\" android:backupAgent=\"com.fake.app.backup.FakeBackupAgent\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:fullBackupOnly=\"true\" android:fullBackupContent=\"@xml/fake_app_backup_rules\" android:usesCleartextTraffic=\"true\" android:networkSecurityConfig=\"@xml/network_security_config\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:appComponentFactory=\"androidx.core.app.CoreComponentFactory\">\n        <activity android:theme=\"@style/ApplicationTheme\" android:name=\"com.fake.app.screens.mainscreens.Wallet.WalletPayment.AddFundsActivity\" android:exported=\"true\" android:launchMode=\"singleTask\" android:screenOrientation=\"portrait\" android:windowSoftInputMode=\"adjustResize\" />",
              "vulnerability_id": "3a611e7f-96d5-4dc3-b392-ad1c1835e39d",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/AndroidManifest.xml",
              "file_line": [],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T21:09:09.450-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
          "title": "Dynamic Receiver Registration",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team discovered a vulnerability in the <b>Fake App</b> application related to the dynamic registration of broadcast receivers. This issue arises due to the application&#39;s use of the registerReceiver() method, which can register broadcast receivers dynamically at runtime instead of declaring them statically in the Android manifest. While dynamic registration provides flexibility, it also introduces potential security risks if not properly managed.</p>\n<p>Specifically, dynamically registered broadcast receivers do not benefit from the Android system&#39;s manifest-based security checks, which can lead to unintended broadcast exposure. If the intent filters associated with these receivers are not carefully specified, it could allow external applications to send broadcasts to the receivers, potentially leading to information leakage or triggering unintended behavior within the app.</p>\n<p>The following code snippet shows the insecure implementation:</p>\n",
              "remediation": "<p>To mitigate the risks associated with dynamically registered broadcast receivers the assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Explicit Intent Filters: Ensure that all dynamically registered broadcast receivers use explicit intent filters that clearly define what actions the receiver is intended to respond to. This helps prevent malicious apps from sending broadcasts that could trigger unintended behavior.\n</li>\n<li>Validate Broadcast Origin: Implement checks within the broadcast receiver to validate the origin of the broadcast. This ensures that only broadcasts from trusted sources are processed, reducing the risk of unauthorized access or manipulation.\n</li>\n<li>Limit Receiver Exposure: Where possible, avoid dynamic registration of broadcast receivers and instead declare them statically in the Android manifest with the necessary permission settings. This leverages the platform's built-in security features to control who can send broadcasts to the receivers.\n</li>\n<li>Use Local Broadcast Manager: For intra-app communication, use Android's Local Broadcast Manager to handle broadcasts. This confines broadcast messages to the app itself, preventing external applications from sending messages to the receivers.\n</li>\n<li>Unregister Receivers: Always ensure that dynamically registered receivers are unregistered when not needed, especially when the app is not in the foreground. This prevents dormant receivers from being triggered unexpectedly.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit the dynamically registered broadcast receivers to send unauthorized broadcasts that trigger unintended actions or manipulate the application’s behavior. This vulnerability could lead to the leakage of sensitive information if broadcasts are intercepted, or could cause the application to perform unintended operations. Such exposures can compromise user data privacy and application functionality</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió una vulnerabilidad en la aplicación <b>Fake App</b> relacionada con el registro dinámico de receptores de transmisión. Este problema surge debido al uso por parte de la aplicación del método RegisterReceiver(), que puede registrar receptores de transmisión dinámicamente en tiempo de ejecución en lugar de declararlos estáticamente en el manifiesto de Android. Si bien el registro dinámico proporciona flexibilidad, también introduce riesgos potenciales de seguridad si no se gestiona adecuadamente.</p>\n<p>Específicamente, los receptores de transmisión registrados dinámicamente no se benefician de las comprobaciones de seguridad basadas en manifiestos del sistema Android, lo que puede provocar una exposición involuntaria de la transmisión. Si los filtros de intención asociados con estos receptores no se especifican cuidadosamente, podría permitir que aplicaciones externas envíen transmisiones a los receptores, lo que podría provocar una fuga de información o desencadenar un comportamiento no deseado dentro de la aplicación.</p>\n<p>El siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>Para mitigar los riesgos asociados con los receptores de transmisión registrados dinámicamente, el equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Filtros de intención explícitos: asegúrese de que todos los receptores de transmisión registrados dinámicamente utilicen filtros de intención explícitos que definan claramente a qué acciones debe responder el receptor. Esto ayuda a evitar que aplicaciones maliciosas envíen difusiones que podrían desencadenar un comportamiento no deseado.\n</li>\n<li>Validar origen de transmisión: implemente comprobaciones dentro del receptor de transmisión para validar el origen de la transmisión. Esto garantiza que solo se procesen transmisiones de fuentes confiables, lo que reduce el riesgo de acceso o manipulación no autorizados.\n</li>\n<li>Limitar la exposición del receptor: cuando sea posible, evite el registro dinámico de los receptores de transmisión y, en cambio, declárelos estáticamente en el manifiesto de Android con la configuración de permisos necesaria. Esto aprovecha las funciones de seguridad integradas de la plataforma para controlar quién puede enviar transmisiones a los receptores.\n</li>\n<li>Utilizar el Administrador de transmisiones locales: para la comunicación dentro de la aplicación, use el Administrador de transmisiones locales de Android para manejar las transmisiones. Esto limita los mensajes de difusión a la propia aplicación y evita que aplicaciones externas envíen mensajes a los receptores.\n</li>\n<li>Cancelar receptores: asegúrese siempre de cancelar el registro de los receptores registrados dinámicamente cuando no sean necesarios, especialmente cuando la aplicación no esté en primer plano. Esto evita que los receptores inactivos se activen inesperadamente.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar los receptores de transmisión registrados dinámicamente para enviar transmisiones no autorizadas que desencadenen acciones no deseadas o manipulen el comportamiento de la aplicación. Esta vulnerabilidad podría provocar la fuga de información confidencial si se interceptan las transmisiones o podría provocar que la aplicación realice operaciones no deseadas. Estas exposiciones pueden comprometer la privacidad de los datos del usuario y la funcionalidad de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Transmisiones persistentes | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sticky-broadcast?hl=es-419"
            },
            {
              "label": "Insecure Broadcast Receiver Configuration - Ostorlab: Mobile application security testing for android and ios",
              "url": "https://docs.ostorlab.co/kb/INSECURE_REGISTER_RECEIVER_FLAG/index.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0063"
          },
          "evidences": [
            {
              "id": "e8fc2c17-336b-41da-a923-f11032e79875",
              "value": "public void registerReceiver() {\n         if (TopicsSyncTask.access$100()) {\n             Log.d(\"FirebaseMessaging\", \"Connectivity change received registered\");\n         }\n         TopicsSyncTask.access$300(((TopicsSyncTask.ConnectivityChangeReceiver) this).this$0).registerReceiver(this, new IntentFilter(\"android.net.conn.CONNECTIVITY_CHANGE\"));\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/firebase/messaging/TopicsSyncTask$ConnectivityChangeReceiver.java",
              "file_line": [
                163
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.356-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f230978f-c806-4c5d-a9e7-6c412b164725",
              "value": "private int getBatteryLevel() {\n         IntentFilter batteryChangedFilter = new IntentFilter(\"android.intent.action.BATTERY_CHANGED\");\n         Intent batteryStatus = ((DeviceInfo) this).context.getApplicationContext().registerReceiver(null, batteryChangedFilter);\n         if (batteryStatus != null) {\n             return batteryStatus.getIntExtra(\"level\", -1);\n         }\n         return -1;\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/zendesk/core/DeviceInfo.java",
              "file_line": [
                113
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.409-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "90b8ac8a-1f30-4f18-b5f4-47e1d3f95433",
              "value": "public void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n         String str = CustomTabActivity.CUSTOM_TAB_REDIRECT_ACTION;\n         if (str.equals(getIntent().getAction())) {\n             setResult(0);\n             finish();\n         } else if (savedInstanceState == null) {\n             String action = getIntent().getStringExtra(CustomTabMainActivity.EXTRA_ACTION);\n             Bundle parameters = getIntent().getBundleExtra(CustomTabMainActivity.EXTRA_PARAMS);\n             String chromePackage = getIntent().getStringExtra(CustomTabMainActivity.EXTRA_CHROME_PACKAGE);\n             CustomTab customTab = new CustomTab(action, parameters);\n             boolean couldOpenCustomTab = customTab.openCustomTab(this, chromePackage);\n             ((CustomTabMainActivity) this).shouldCloseCustomTab = false;\n             if (!couldOpenCustomTab) {\n                 setResult(0, getIntent().putExtra(CustomTabMainActivity.NO_ACTIVITY_EXCEPTION, true));\n                 finish();\n                 return;\n             }\n             ((CustomTabMainActivity) this).redirectReceiver = new CustomTabMainActivity.1(this);\n             LocalBroadcastManager.getInstance(this).registerReceiver(((CustomTabMainActivity) this).redirectReceiver, new IntentFilter(str));\n         }\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/CustomTabMainActivity.java",
              "file_line": [
                457
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.224-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "230e2813-29a5-4a9e-9211-3ef2f82e4aab",
              "value": "private void associateWithLikeActionController(LikeActionController likeActionController) {\n         ((LikeView) this).likeActionController = likeActionController;\n         ((LikeView) this).broadcastReceiver = new LikeView.LikeControllerBroadcastReceiver(this, (LikeView.1) null);\n         LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(getContext());\n         IntentFilter filter = new IntentFilter();\n         filter.addAction(\"com.facebook.sdk.LikeActionController.UPDATED\");\n         filter.addAction(\"com.facebook.sdk.LikeActionController.DID_ERROR\");\n         filter.addAction(\"com.facebook.sdk.LikeActionController.DID_RESET\");\n         localBroadcastManager.registerReceiver(((LikeView) this).broadcastReceiver, filter);\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/share/widget/LikeView.java",
              "file_line": [
                286
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.277-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b4f852ef-3433-4617-a1f3-eaa6b4f3680b",
              "value": "public final int getBatteryLevel() {\n         IntentFilter batteryChangedFilter = new IntentFilter(\"android.intent.action.BATTERY_CHANGED\");\n         Intent batteryStatus = ((SupportSdkMetadata) this).context.getApplicationContext().registerReceiver(null, batteryChangedFilter);\n         if (batteryStatus != null) {\n             return batteryStatus.getIntExtra(\"level\", -1);\n         }\n         return -1;\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/zendesk/support/SupportSdkMetadata.java",
              "file_line": [
                60
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.421-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "a51e6c88-c0c2-4917-a5f4-a0f2b56c5f99",
              "value": "private static float init(Context context) {\n         try {\n             Intent registerReceiver = context.getApplicationContext().registerReceiver(null, new IntentFilter(\"android.intent.action.BATTERY_CHANGED\"));\n             int intExtra = registerReceiver.getIntExtra(\"level\", -1);\n             int intExtra2 = registerReceiver.getIntExtra(\"scale\", -1);\n             if (intExtra == -1 || intExtra2 == -1) {\n                 return 50.0f;\n             }\n             return (intExtra / intExtra2) * 100.0f;\n         } catch (Throwable th) {\n             AFLogger.valueOf(th.getMessage(), th);\n             return 1.0f;\n         }\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/appsflyer/internal/ai.java",
              "file_line": [
                3814
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.030-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "fb94e305-bc0b-4146-890e-5e34e9c8aabc",
              "value": "public final void d0() {\n         a $this$initListeners_u24lambda_u2d20 = N().b;\n         $this$initListeners_u24lambda_u2d20.c.setOnClickListener(this);\n         $this$initListeners_u24lambda_u2d20.q.setOnClickListener(this);\n         $this$initListeners_u24lambda_u2d20.g.setOnClickListener(this);\n         $this$initListeners_u24lambda_u2d20.f.setOnClickListener(this);\n         $this$initListeners_u24lambda_u2d20.s.setOnClickListener(this);\n         $this$initListeners_u24lambda_u2d20.n.setOnClickListener(this);\n         $this$initListeners_u24lambda_u2d20.p.setOnClickListener(this);\n         $this$initListeners_u24lambda_u2d20.j.setOnClickListener(this);\n         getSupportFragmentManager().setFragmentResultListener(\"7000\", this, new e(this));\n         LocalBroadcastManager.getInstance(getApplicationContext()).registerReceiver(T(), new IntentFilter(\"broadcast_login_state_changed\"));\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/fake/app/screens/mainscreens/single/SingleFakeAppActivity.java",
              "file_line": [
                1825
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.118-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9ed5fd83-0470-4294-939a-11e809f77a2d",
              "value": "public final void i() {\n         if (((e) this).d) {\n             return;\n         }\n         ((e) this).c = h(((e) this).a);\n         try {\n             ((e) this).a.registerReceiver(((e) this).f, new IntentFilter(\"android.net.conn.CONNECTIVITY_CHANGE\"));\n             ((e) this).d = true;\n         } catch (SecurityException e) {\n             if (Log.isLoggable(\"ConnectivityMonitor\", 5)) {\n                 Log.w(\"ConnectivityMonitor\", \"Failed to register\", e);\n             }\n         }\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/b/a/n/e.java",
              "file_line": [
                180
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.144-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "735593d2-c4aa-4c98-8903-b5ddc6a1556c",
              "value": "private static void ensureReceiverRegistered(Context applicationContext) {\n         if (FirebaseApp.UserUnlockReceiver.INSTANCE.get() == null) {\n             FirebaseApp.UserUnlockReceiver receiver = new FirebaseApp.UserUnlockReceiver(applicationContext);\n             if (FirebaseApp.UserUnlockReceiver.INSTANCE.compareAndSet(null, receiver)) {\n                 IntentFilter intentFilter = new IntentFilter(\"android.intent.action.USER_UNLOCKED\");\n                 applicationContext.registerReceiver(receiver, intentFilter);\n             }\n         }\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/firebase/FirebaseApp$UserUnlockReceiver.java",
              "file_line": [
                114
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.300-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "78a07de1-e58c-417c-98d7-5e3bd73eb345",
              "value": "private String AFInAppEventParameterName() {\n         String obj;\n         int i;\n         try {\n             String obj2 = ((c.d) this).values.get(c.d.AFInAppEventParameterName(TextUtils.getTrimmedLength(\"\"), (char) (TextUtils.indexOf((CharSequence) \"\", '0', 0, 0) + 45903), 12 - ExpandableListView.getPackedPositionType(0L)).intern()).toString();\n             String obj3 = ((c.d) this).values.get(c.d.AFInAppEventParameterName(24 - (ViewConfiguration.getZoomControlsTimeout() > 0L ? 1 : (ViewConfiguration.getZoomControlsTimeout() == 0L ? 0 : -1)), (char) (58193 - View.MeasureSpec.makeMeasureSpec(0, 0)), 15 - (ViewConfiguration.getLongPressTimeout() >> 16)).intern()).toString();\n             String replaceAll = c.d.AFInAppEventParameterName(38 - View.MeasureSpec.getSize(0), (char) (38557 - ExpandableListView.getPackedPositionType(0L)), 5 - ((Process.getThreadPriority(0) + 20) >> 6)).intern().replaceAll(c.d.values(new int[]{554720026, 810846395, -1353340409, 1995249900}, TextUtils.indexOf((CharSequence) \"\", '0', 0) + 6).intern(), \"\");\n             StringBuilder sb = new StringBuilder();\n             sb.append(obj2);\n             sb.append(obj3);\n             sb.append(replaceAll);\n             String AFInAppEventParameterName = ah.AFInAppEventParameterName(sb.toString());\n             StringBuilder sb2 = new StringBuilder();\n             sb2.append(\"\");\n             sb2.append(AFInAppEventParameterName.substring(0, 16));\n             obj = sb2.toString();\n         } catch (Exception e) {\n             StringBuilder sb3 = new StringBuilder();\n             sb3.append(c.d.values(new int[]{640847658, -233831226, 620669702, -1347693514, 1083507952, -1102549683, -450369102, -1732957970, 393969182, 886873569, -1952655995, 1892296752, 1890815725, -1673734706, 1444084348, -987179240, 1094281385, 992383361, 17585538, 973864474, -432527319, -1739858274}, TextUtils.lastIndexOf(\"\", '0') + 45).intern());\n             sb3.append(e);\n             AFLogger.AFInAppEventParameterName(sb3.toString());\n             StringBuilder sb4 = new StringBuilder();\n             sb4.append(\"\");\n             sb4.append(c.d.AFInAppEventParameterName(42 - (ExpandableListView.getPackedPositionForChild(0, 0) > 0L ? 1 : (ExpandableListView.getPackedPositionForChild(0, 0) == 0L ? 0 : -1)), (char) (5797 - (ViewConfiguration.getDoubleTapTimeout() >> 16)), AndroidCharacter.getMirror('0') - 30).intern());\n             obj = sb4.toString();\n         }\n         try {\n             Intent registerReceiver = ((c.d) this).AFKeystoreWrapper.registerReceiver(null, new IntentFilter(c.d.values(new int[]{-248593871, 418937694, 1034627370, 175927361, -56373222, 1046364932, 687343027, -368521510, 1427030466, 1568180991, -741401460, -1800867994, 1331349556, 1216887738, -1608381182, -1947019990, 948188064, 1315957742, -1365079188, 1790179928}, (ViewConfiguration.getScrollBarFadeDuration() >> 16) + 37).intern()));\n             int i2 = -2700;\n             if (registerReceiver != null) {\n                 i2 = registerReceiver.getIntExtra(c.d.values(new int[]{998518318, -1660110958, -513052711, 611993354, 508697840, 1938850892}, PhoneNumberUtils.toaFromString(\"\") - 118).intern(), -2700);\n             } else {\n                 int i3 = c.d.getLevel + 121;\n                 c.d.AFVersionDeclaration = i3 % 128;\n                 if (i3 % 2 == 0) {\n                 }\n             }\n             String str = ((c.d) this).AFKeystoreWrapper.getApplicationInfo().nativeLibraryDir;\n             if (str != null) {\n                 switch (str.contains(c.d.values(new int[]{-1675036583, 1271474483}, 2 - ImageFormat.getBitsPerPixel(0)).intern())) {\n                     case false:\n                         break;\n                     default:\n                         int i4 = c.d.getLevel + 61;\n                         c.d.AFVersionDeclaration = i4 % 128;\n                         switch (i4 % 2 == 0 ? 'L' : (char) 16) {\n                             case 16:\n                                 i = 1;\n                                 break;\n                             default:\n                                 i = 0;\n                                 break;\n                         }\n                 }\n                 int size = ((SensorManager) ((c.d) this).AFKeystoreWrapper.getSystemService(c.d.values(new int[]{-2108098182, 924452591, -880754948, 1430040891}, 6 - (ViewConfiguration.getScrollBarFadeDuration() >> 16)).intern())).getSensorList(-1).size();\n                 StringBuilder sb5 = new StringBuilder();\n                 sb5.append(c.d.AFInAppEventParameterName(TextUtils.getCapsMode(\"\", 0, 0) + 61, (char) (ViewConfiguration.getTapTimeout() >> 16), (TypedValue.complexToFloat(0) > 0.0f ? 1 : (TypedValue.complexToFloat(0) == 0.0f ? 0 : -1)) + 1).intern());\n                 sb5.append(i2);\n                 sb5.append(c.d.values(new int[]{1802121942, -851730084}, KeyEvent.getDeadChar(0, 0) + 2).intern());\n                 sb5.append(i);\n                 sb5.append(c.d.AFInAppEventParameterName((AudioTrack.getMaxVolume() > 0.0f ? 1 : (AudioTrack.getMaxVolume() == 0.0f ? 0 : -1)) + 61, (char) TextUtils.getCapsMode(\"\", 0, 0), (SystemClock.elapsedRealtime() > 0L ? 1 : (SystemClock.elapsedRealtime() == 0L ? 0 : -1)) + 1).intern());\n                 sb5.append(size);\n                 sb5.append(c.d.AFInAppEventParameterName(Color.blue(0) + 64, (char) TextUtils.getCapsMode(\"\", 0, 0), 6 - AndroidCharacter.getEastAsianWidth('0')).intern());\n                 sb5.append(((c.d) this).values.size());\n                 String obj4 = sb5.toString();\n                 StringBuilder sb6 = new StringBuilder();\n                 sb6.append(obj);\n                 sb6.append(c.d.b.AFInAppEventType(c.d.b.AFInAppEventParameterName(c.d.b.AFInAppEventType(obj4))));\n                 return sb6.toString();\n             }\n             i = 0;\n             int size2 = ((SensorManager) ((c.d) this).AFKeystoreWrapper.getSystemService(c.d.values(new int[]{-2108098182, 924452591, -880754948, 1430040891}, 6 - (ViewConfiguration.getScrollBarFadeDuration() >> 16)).intern())).getSensorList(-1).size();\n             StringBuilder sb52 = new StringBuilder();\n             sb52.append(c.d.AFInAppEventParameterName(TextUtils.getCapsMode(\"\", 0, 0) + 61, (char) (ViewConfiguration.getTapTimeout() >> 16), (TypedValue.complexToFloat(0) > 0.0f ? 1 : (TypedValue.complexToFloat(0) == 0.0f ? 0 : -1)) + 1).intern());\n             sb52.append(i2);\n             sb52.append(c.d.values(new int[]{1802121942, -851730084}, KeyEvent.getDeadChar(0, 0) + 2).intern());\n             sb52.append(i);\n             sb52.append(c.d.AFInAppEventParameterName((AudioTrack.getMaxVolume() > 0.0f ? 1 : (AudioTrack.getMaxVolume() == 0.0f ? 0 : -1)) + 61, (char) TextUtils.getCapsMode(\"\", 0, 0), (SystemClock.elapsedRealtime() > 0L ? 1 : (SystemClock.elapsedRealtime() == 0L ? 0 : -1)) + 1).intern());\n             sb52.append(size2);\n             sb52.append(c.d.AFInAppEventParameterName(Color.blue(0) + 64, (char) TextUtils.getCapsMode(\"\", 0, 0), 6 - AndroidCharacter.getEastAsianWidth('0')).intern());\n             sb52.append(((c.d) this).values.size());\n             String obj42 = sb52.toString();\n             StringBuilder sb62 = new StringBuilder();\n             sb62.append(obj);\n             sb62.append(c.d.b.AFInAppEventType(c.d.b.AFInAppEventParameterName(c.d.b.AFInAppEventType(obj42))));\n             return sb62.toString();\n         } catch (Exception e2) {\n             StringBuilder sb7 = new StringBuilder();\n             sb7.append(c.d.values(new int[]{640847658, -233831226, 620669702, -1347693514, 1083507952, -1102549683, -450369102, -1732957970, 393969182, 886873569, -1952655995, 1892296752, 1890815725, -1673734706, 1444084348, -987179240, 1094281385, 992383361, 17585538, 973864474, -432527319, -1739858274}, 44 - (ViewConfiguration.getTapTimeout() >> 16)).intern());\n             sb7.append(e2);\n             AFLogger.AFInAppEventParameterName(sb7.toString());\n             StringBuilder sb8 = new StringBuilder();\n             sb8.append(obj);\n             sb8.append(c.d.values(new int[]{-828854563, 475996213, 640677171, -1604617094, -1550728992, -1021112346, 2006942107, 297401137}, TextUtils.getCapsMode(\"\", 0, 0) + 16).intern());\n             return sb8.toString();\n         }\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/appsflyer/internal/c$d.java",
              "file_line": [
                689
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.055-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "efbd3d78-f508-4853-bbcc-0938dbda9108",
              "value": "public final void z() {\n         LocalBroadcastManager.getInstance(requireActivity().getApplicationContext()).registerReceiver(((AccountFragment) this).f, new IntentFilter(\"broadcast_login_state_changed\"));\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/fake/app/screens/mainscreens/account/AccountFragment.java",
              "file_line": [
                1381
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.088-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "fc952605-69fb-48dd-9701-ca72e0e221de",
              "value": "public void onActivityResult(int requestCode, int resultCode, Intent data) {\n         super.onActivityResult(requestCode, resultCode, data);\n         if (resultCode == 0) {\n             Intent broadcast = new Intent(CustomTabActivity.CUSTOM_TAB_REDIRECT_ACTION);\n             broadcast.putExtra(CustomTabMainActivity.EXTRA_URL, getIntent().getDataString());\n             LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);\n             ((CustomTabActivity) this).closeReceiver = new CustomTabActivity.1(this);\n             LocalBroadcastManager.getInstance(this).registerReceiver(((CustomTabActivity) this).closeReceiver, new IntentFilter(CustomTabActivity.DESTROY_ACTION));\n         }\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/CustomTabActivity.java",
              "file_line": [
                146
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.210-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9373e07e-acaf-4671-9821-2a6b6d048abe",
              "value": "public void register() {\n         IntentFilter filter = new IntentFilter();\n         filter.addAction(\"android.intent.action.AIRPLANE_MODE\");\n         if (((Dispatcher.NetworkBroadcastReceiver) this).dispatcher.scansNetworkChanges) {\n             filter.addAction(\"android.net.conn.CONNECTIVITY_CHANGE\");\n         }\n         ((Dispatcher.NetworkBroadcastReceiver) this).dispatcher.context.registerReceiver(this, filter);\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/squareup/picasso/Dispatcher$NetworkBroadcastReceiver.java",
              "file_line": [
                168
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.394-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5e1cbb0d-f84b-4675-86ce-0a1a2876432d",
              "value": "public final void l() {\n         LocalBroadcastManager.getInstance(requireContext()).registerReceiver(((SelectOptionFragment) this).d, new IntentFilter(\"broadcast_login_state_changed\"));\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/fake/app/wallet/screens/selectoption/SelectOptionFragment.java",
              "file_line": [
                448
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.174-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d858293e-705c-4ecd-bb91-dd7fd1944e2a",
              "value": "public void registerReceiver() {\n         if (SyncTask.isDebugLogEnabled()) {\n             Log.d(\"FirebaseMessaging\", \"Connectivity change received registered\");\n         }\n         ((SyncTask.ConnectivityChangeReceiver) this).task.getContext().registerReceiver(this, new IntentFilter(\"android.net.conn.CONNECTIVITY_CHANGE\"));\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/firebase/messaging/SyncTask$ConnectivityChangeReceiver.java",
              "file_line": [
                137
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.341-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "a4cd39c2-f105-4d4e-96b7-139467a8e1d0",
              "value": "public void setup() {\n         cleanup();\n         IntentFilter filter = createIntentFilterForBroadcastReceiver();\n         if (filter == null || filter.countActions() == 0) {\n             return;\n         }\n         if (((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver == null) {\n             ((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver = new AppCompatDelegateImpl.AutoNightModeManager.1(this);\n         }\n         ((AppCompatDelegateImpl.AutoNightModeManager) this).this$0.mContext.registerReceiver(((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver, filter);\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/app/AppCompatDelegateImpl$AutoNightModeManager.java",
              "file_line": [
                157
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.009-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3d55debb-0c83-48a9-84d4-5d70703f8c9d",
              "value": "private void addBroadcastReceiver() {\n         IntentFilter filter = new IntentFilter();\n         filter.addAction(\"com.facebook.sdk.ACTION_CURRENT_ACCESS_TOKEN_CHANGED\");\n         ((AccessTokenTracker) this).broadcastManager.registerReceiver(((AccessTokenTracker) this).receiver, filter);\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/AccessTokenTracker.java",
              "file_line": [
                111
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.189-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f2d696eb-473d-4184-b047-cf91411fef2f",
              "value": "private void addBroadcastReceiver() {\n         IntentFilter filter = new IntentFilter();\n         filter.addAction(\"com.facebook.sdk.ACTION_CURRENT_PROFILE_CHANGED\");\n         ((ProfileTracker) this).broadcastManager.registerReceiver(((ProfileTracker) this).receiver, filter);\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/ProfileTracker.java",
              "file_line": [
                83
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.237-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "726626ba-4031-43b9-8edc-64adbf844a5f",
              "value": "private void open() {\n         LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(((BoltsMeasurementEventListener) this).applicationContext);\n         broadcastManager.registerReceiver(this, new IntentFilter(\"com.parse.bolts.measurement_event\"));\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/BoltsMeasurementEventListener.java",
              "file_line": [
                111
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.261-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "52542618-81b1-4a48-9f47-0e322a988109",
              "value": "public static BatteryState get(Context context) {\n         boolean powerConnected = false;\n         Float level = null;\n         try {\n             IntentFilter ifilter = new IntentFilter(\"android.intent.action.BATTERY_CHANGED\");\n             Intent batteryStatusIntent = context.registerReceiver(null, ifilter);\n             if (batteryStatusIntent != null) {\n                 powerConnected = BatteryState.isPowerConnected(batteryStatusIntent);\n                 level = BatteryState.getLevel(batteryStatusIntent);\n             }\n         } catch (IllegalStateException ex) {\n             Logger.getLogger().e(\"An error occurred getting battery state.\", ex);\n         }\n         return new BatteryState(level, powerConnected);\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/firebase/crashlytics/internal/common/BatteryState.java",
              "file_line": [
                63
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.318-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "dbf00f8a-41f1-42f9-86d8-b30dbd66ee3e",
              "value": "private void setupLocalBroadCastConfigs() {\n         ((InitSecureConnectionActivity) this).mMessageReceiver = new InitSecureConnectionActivity.1(this);\n         LocalBroadcastManager.getInstance(this).registerReceiver(((InitSecureConnectionActivity) this).mMessageReceiver, new IntentFilter(\"responseEvent\"));\n     }",
              "vulnerability_id": "d0ca8d4a-a42d-467a-888a-874c05b7dfb0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/payfort/fort/android/sdk/activities/InitSecureConnectionActivity.java",
              "file_line": [
                177
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:09.371-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "e09f3d02-871f-4b55-9b40-694f5492be61",
          "title": "Implicit Intent Detected",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Fake App</b> uses implicit intents, which allow the Android system to determine which component, potentially from another application, should handle an intent. While this enables flexible inter-application communication, insecure implementation can lead to unintended exposure of sensitive functionality.</p>\n",
              "remediation": "<p>The assessment team recommends using explicit intents whenever possible to ensure that only intended application components handle them. If implicit intents are required, developers should restrict exposed components by properly configuring intent filters and setting the exported attribute to false when external access is not necessary. Additionally, all incoming intents should be validated to prevent unauthorized access or data manipulation.</p>\n",
              "impact": "<p>Improper handling of implicit intents can result in intent hijacking, where malicious applications intercept and manipulate intents that were not explicitly directed to a specific component. This could lead to unauthorized access to sensitive data or unintended execution of actions triggered by an attacker.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Fake App</b> utiliza intenciones implícitas, que permiten al sistema Android determinar qué componente, potencialmente de otra aplicación, debe manejar una intención. Si bien esto permite una comunicación flexible entre aplicaciones, una implementación insegura puede provocar una exposición involuntaria de funciones confidenciales.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda utilizar intenciones explícitas siempre que sea posible para garantizar que solo los componentes de la aplicación previstos las manejen. Si se requieren intenciones implícitas, los desarrolladores deben restringir los componentes expuestos configurando correctamente los filtros de intención y estableciendo el atributo exportado en falso cuando no sea necesario el acceso externo. Además, todos los intents entrantes deben validarse para evitar el acceso no autorizado o la manipulación de datos.</p>\n",
              "impact": "<p>El manejo inadecuado de intenciones implícitas puede resultar en secuestro de intenciones, donde aplicaciones maliciosas interceptan y manipulan intenciones que no estaban dirigidas explícitamente a un componente específico. Esto podría dar lugar a un acceso no autorizado a datos confidenciales o a la ejecución involuntaria de acciones provocadas por un atacante.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Intents and Intent Filters | App architecture - Android Developers",
              "url": "https://developer.android.com/guide/components/intents-filters?hl=es-419"
            },
            {
              "label": "Implicit Intent Hijacking | Security - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/implicit-intent-hijacking?hl=es-419"
            },
            {
              "label": "Mitigate security risks in your app - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "dce64838-57e3-4c10-8382-c52ee0036517",
              "value": "public Cls0S7YWII0G1C615F(Context context, String tag, ComponentName mbrComponent, PendingIntent mbrIntent, Bundle token2Bundle) {\n         new ArrayList();\n         if (context == null) {\n             throw new IllegalArgumentException(\"context must not be null\");\n         }\n         if (TextUtils.isEmpty(tag)) {\n             throw new IllegalArgumentException(\"tag must not be null or empty\");\n         }\n         if (mbrComponent == null && (mbrComponent = MediaButtonReceiver.getMediaButtonReceiverComponent(context)) == null) {\n             Log.w(\"MediaSessionCompat\", \"Couldn't find a unique registered media button receiver in the given context.\");\n         }\n         if (mbrComponent != null && mbrIntent == null) {\n             Intent mediaButtonIntent = new Intent(\"android.intent.action.MEDIA_BUTTON\");\n             mediaButtonIntent.setComponent(mbrComponent);\n             mbrIntent = PendingIntent.getBroadcast(context, 0, mediaButtonIntent, 0);\n         }\n         if (Build.VERSION.SDK_INT >= 28) {\n             MediaSessionCompat.f fVar = new MediaSessionCompat.f(context, tag, token2Bundle);\n             ((MediaSessionCompat) this).b = fVar;\n             e(new MediaSessionCompat.a(this));\n             fVar.d(mbrIntent);\n         } else {\n             MediaSessionCompat.e eVar = new MediaSessionCompat.e(context, tag, token2Bundle);\n             ((MediaSessionCompat) this).b = eVar;\n             e(new MediaSessionCompat.b(this));\n             eVar.d(mbrIntent);\n         }\n         ((MediaSessionCompat) this).c = new MediaControllerCompat(context, this);\n         if (MediaSessionCompat.a == 0) {\n             MediaSessionCompat.a = (int) (TypedValue.applyDimension(1, 320.0f, context.getResources().getDisplayMetrics()) + 0.5f);\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaSessionCompat.java",
              "file_line": [
                126
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.619-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "492dc3ac-efa4-4441-ae44-9d6332391481",
              "value": "public static Intent setAlwaysUseBrowserUI(Intent intent) {\n         if (intent == null) {\n             intent = new Intent(\"android.intent.action.VIEW\");\n         }\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.support.customtabs.extra.user_opt_out\", true);\n         return intent;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/browser/customtabs/CustomTabsIntent.java",
              "file_line": [
                121
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.790-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b384d117-c704-474c-946d-02997264fa66",
              "value": "private static PendingIntent createMessagingPendingIntent(Context context, Intent intent) {\n         return PendingIntent.getBroadcast(context, CommonNotificationBuilder.generatePendingIntentRequestCode(), new Intent(\"com.google.firebase.MESSAGING_EVENT\").setComponent(new ComponentName(context, \"com.google.firebase.iid.FirebaseInstanceIdReceiver\")).putExtra(\"wrapped_intent\", intent), CommonNotificationBuilder.getPendingIntentFlags(1073741824));\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/firebase/messaging/CommonNotificationBuilder.java",
              "file_line": [
                189
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.642-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b5feae4b-4eec-4aaa-a0d8-e16da6b3b527",
              "value": "private Intent createVoiceAppSearchIntent(Intent baseIntent, SearchableInfo searchable) {\n         ComponentName searchActivity = searchable.getSearchActivity();\n         Intent queryIntent = new Intent(\"android.intent.action.SEARCH\");\n         queryIntent.setComponent(searchActivity);\n         PendingIntent pending = PendingIntent.getActivity(getContext(), 0, queryIntent, 1073741824);\n         Bundle queryExtras = new Bundle();\n         Bundle bundle = ((SearchView) this).mAppSearchData;\n         if (bundle != null) {\n             queryExtras.putParcelable(\"app_data\", bundle);\n         }\n         Intent voiceIntent = new Intent(baseIntent);\n         String languageModel = \"free_form\";\n         String prompt = null;\n         String language = null;\n         int maxResults = 1;\n         Resources resources = getResources();\n         if (searchable.getVoiceLanguageModeId() != 0) {\n             languageModel = resources.getString(searchable.getVoiceLanguageModeId());\n         }\n         if (searchable.getVoicePromptTextId() != 0) {\n             prompt = resources.getString(searchable.getVoicePromptTextId());\n         }\n         if (searchable.getVoiceLanguageId() != 0) {\n             language = resources.getString(searchable.getVoiceLanguageId());\n         }\n         if (searchable.getVoiceMaxResults() != 0) {\n             maxResults = searchable.getVoiceMaxResults();\n         }\n         voiceIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", languageModel);\n         voiceIntent.putExtra(\"android.speech.extra.PROMPT\", prompt);\n         voiceIntent.putExtra(\"android.speech.extra.LANGUAGE\", language);\n         voiceIntent.putExtra(\"android.speech.extra.MAX_RESULTS\", maxResults);\n         voiceIntent.putExtra(\"calling_package\", searchActivity == null ? null : searchActivity.flattenToShortString());\n         voiceIntent.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT\", pending);\n         voiceIntent.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT_BUNDLE\", queryExtras);\n         return voiceIntent;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                1089
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.652-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "37f2ef4b-c7b8-46b5-a3b6-4ef0ac8509bc",
              "value": "public Cls16K03SV7TVQL3C1(Context context, Uri uri) {\n         ((BrowserActionsIntent.Builder) this).mIntent = new Intent(\"androidx.browser.browseractions.browser_action_open\");\n         ((BrowserActionsIntent.Builder) this).mMenuItems = null;\n         ((BrowserActionsIntent.Builder) this).mOnItemSelectedPendingIntent = null;\n         ((BrowserActionsIntent.Builder) this).mContext = context;\n         ((BrowserActionsIntent.Builder) this).mUri = uri;\n         ((BrowserActionsIntent.Builder) this).mType = 0;\n         ((BrowserActionsIntent.Builder) this).mMenuItems = new ArrayList();\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/browser/browseractions/BrowserActionsIntent$Builder.java",
              "file_line": [
                53
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.667-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ccd1220a-3aa5-4bbe-9512-dcf4007fc7ab",
              "value": "public static boolean bindCustomTabsService(Context context, String packageName, CustomTabsServiceConnection connection) {\n         Intent intent = new Intent(\"android.support.customtabs.action.CustomTabsService\");\n         if (!TextUtils.isEmpty(packageName)) {\n             intent.setPackage(packageName);\n         }\n         return context.bindService(intent, connection, 33);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/browser/customtabs/CustomTabsClient.java",
              "file_line": [
                47
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.754-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "81ca3220-4dd0-45c2-9cac-744c026ade5b",
              "value": "public static PendingIntent buildMediaButtonPendingIntent(Context context, ComponentName mbrComponent, long action) {\n         if (mbrComponent == null) {\n             Log.w(\"MediaButtonReceiver\", \"The component name of media button receiver should be provided.\");\n             return null;\n         }\n         int keyCode = PlaybackStateCompat.g(action);\n         if (keyCode == 0) {\n             Log.w(\"MediaButtonReceiver\", \"Cannot build a media button pending intent with the given action: \" + action);\n             return null;\n         }\n         Intent intent = new Intent(\"android.intent.action.MEDIA_BUTTON\");\n         intent.setComponent(mbrComponent);\n         intent.putExtra(\"android.intent.extra.KEY_EVENT\", new KeyEvent(0, keyCode));\n         return PendingIntent.getBroadcast(context, keyCode, intent, 0);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/media/session/MediaButtonReceiver.java",
              "file_line": [
                121
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.829-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8f0b2bf8-f584-404a-b45e-ba8b5dce43b8",
              "value": "private static ComponentName getServiceComponentByAction(Context context, String action) {\n         PackageManager pm = context.getPackageManager();\n         Intent queryIntent = new Intent(action);\n         queryIntent.setPackage(context.getPackageName());\n         List<ResolveInfo> resolveInfos = pm.queryIntentServices(queryIntent, 0);\n         if (resolveInfos.size() == 1) {\n             ResolveInfo resolveInfo = resolveInfos.get(0);\n             ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n             return new ComponentName(serviceInfo.packageName, serviceInfo.name);\n         } else if (resolveInfos.isEmpty()) {\n             return null;\n         } else {\n             throw new IllegalStateException(\"Expected 1 service that handles \" + action + \", found \" + resolveInfos.size());\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/media/session/MediaButtonReceiver.java",
              "file_line": [
                251
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.849-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c1f49293-ce01-4013-ac01-084199bc68a0",
              "value": "public final void y() {\n         Intent chooseFile = new Intent(\"android.intent.action.OPEN_DOCUMENT\");\n         chooseFile.setType(\"*/*\");\n         Intent chooseFile2 = Intent.createChooser(chooseFile, \"Choose a file\");\n         q.e(chooseFile2, \"createChooser(chooseFile, \\\"Choose a file\\\")\");\n         startActivityForResult(chooseFile2, 263);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/verygoodsecurity/vgscollect/app/FilePickerActivity.java",
              "file_line": [
                258
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.859-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "76581daf-64c2-4906-8fbb-2c81dce8dc2c",
              "value": "private Intent createIntent(String action, Uri data, String extraData, String query, int actionKey, String actionMsg) {\n         Intent intent = new Intent(action);\n         intent.addFlags(268435456);\n         if (data != null) {\n             intent.setData(data);\n         }\n         intent.putExtra(\"user_query\", ((SearchView) this).mUserQuery);\n         if (query != null) {\n             intent.putExtra(\"query\", query);\n         }\n         if (extraData != null) {\n             intent.putExtra(\"intent_extra_data_key\", extraData);\n         }\n         Bundle bundle = ((SearchView) this).mAppSearchData;\n         if (bundle != null) {\n             intent.putExtra(\"app_data\", bundle);\n         }\n         if (actionKey != 0) {\n             intent.putExtra(\"action_key\", actionKey);\n             intent.putExtra(\"action_msg\", actionMsg);\n         }\n         intent.setComponent(((SearchView) this).mSearchable.getSearchActivity());\n         return intent;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                776
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.636-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7bc5c072-ddf5-4f21-9560-46f46e54f081",
              "value": "public void startConnection(InstallReferrerStateListener installReferrerStateListener) {\n         ServiceInfo serviceInfo;\n         if (isReady()) {\n             InstallReferrerCommons.logVerbose(\"InstallReferrerClient\", \"Service connection is valid. No need to re-initialize.\");\n             installReferrerStateListener.onInstallReferrerSetupFinished(0);\n             return;\n         }\n         int i = ((InstallReferrerClientImpl) this).clientState;\n         if (i == 1) {\n             InstallReferrerCommons.logWarn(\"InstallReferrerClient\", \"Client is already in the process of connecting to the service.\");\n             installReferrerStateListener.onInstallReferrerSetupFinished(3);\n         } else if (i == 3) {\n             InstallReferrerCommons.logWarn(\"InstallReferrerClient\", \"Client was already closed and can't be reused. Please create another instance.\");\n             installReferrerStateListener.onInstallReferrerSetupFinished(3);\n         } else {\n             InstallReferrerCommons.logVerbose(\"InstallReferrerClient\", \"Starting install referrer service setup.\");\n             Intent intent = new Intent(\"com.google.android.finsky.BIND_GET_INSTALL_REFERRER_SERVICE\");\n             intent.setComponent(new ComponentName(\"com.android.vending\", \"com.google.android.finsky.externalreferrer.GetInstallReferrerService\"));\n             List<ResolveInfo> queryIntentServices = ((InstallReferrerClientImpl) this).mApplicationContext.getPackageManager().queryIntentServices(intent, 0);\n             if (queryIntentServices == null || queryIntentServices.isEmpty() || (serviceInfo = queryIntentServices.get(0).serviceInfo) == null) {\n                 ((InstallReferrerClientImpl) this).clientState = 0;\n                 InstallReferrerCommons.logVerbose(\"InstallReferrerClient\", \"Install Referrer service unavailable on device.\");\n                 installReferrerStateListener.onInstallReferrerSetupFinished(2);\n                 return;\n             }\n             String str = serviceInfo.packageName;\n             String str2 = serviceInfo.name;\n             if (!\"com.android.vending\".equals(str) || str2 == null || !isPlayStoreCompatible()) {\n                 InstallReferrerCommons.logWarn(\"InstallReferrerClient\", \"Play Store missing or incompatible. Version 8.3.73 or later required.\");\n                 ((InstallReferrerClientImpl) this).clientState = 0;\n                 installReferrerStateListener.onInstallReferrerSetupFinished(2);\n                 return;\n             }\n             Intent intent2 = new Intent(intent);\n             ServiceConnection installReferrerServiceConnection = new InstallReferrerClientImpl.InstallReferrerServiceConnection(this, installReferrerStateListener, (InstallReferrerClientImpl.1) null);\n             ((InstallReferrerClientImpl) this).serviceConnection = installReferrerServiceConnection;\n             try {\n                 if (((InstallReferrerClientImpl) this).mApplicationContext.bindService(intent2, installReferrerServiceConnection, 1)) {\n                     InstallReferrerCommons.logVerbose(\"InstallReferrerClient\", \"Service was bonded successfully.\");\n                     return;\n                 }\n                 InstallReferrerCommons.logWarn(\"InstallReferrerClient\", \"Connection to service is blocked.\");\n                 ((InstallReferrerClientImpl) this).clientState = 0;\n                 installReferrerStateListener.onInstallReferrerSetupFinished(1);\n             } catch (SecurityException e) {\n                 InstallReferrerCommons.logWarn(\"InstallReferrerClient\", \"No permission to connect to service.\");\n                 ((InstallReferrerClientImpl) this).clientState = 0;\n                 installReferrerStateListener.onInstallReferrerSetupFinished(4);\n             }\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/android/installreferrer/api/InstallReferrerClientImpl.java",
              "file_line": [
                329
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.872-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "82f6c3e6-0475-4a9d-92a0-0c2b0ef6010d",
              "value": "public static void flushAndWait(FlushReason reason) {\n         PersistedEvents result = AppEventStore.readAndClearStore();\n         AppEventQueue.appEventCollection.addPersistedEvents(result);\n         try {\n             FlushStatistics flushResults = AppEventQueue.sendEventsToServer(reason, AppEventQueue.appEventCollection);\n             if (flushResults != null) {\n                 Intent intent = new Intent(\"com.facebook.sdk.APP_EVENTS_FLUSHED\");\n                 intent.putExtra(\"com.facebook.sdk.APP_EVENTS_NUM_EVENTS_FLUSHED\", flushResults.numEvents);\n                 intent.putExtra(\"com.facebook.sdk.APP_EVENTS_FLUSH_RESULT\", (Serializable) flushResults.result);\n                 Context context = FacebookSdk.getApplicationContext();\n                 LocalBroadcastManager.getInstance(context).sendBroadcast(intent);\n             }\n         } catch (Exception e) {\n             Log.w(AppEventQueue.TAG, \"Caught unexpected exception while flushing app events: \", e);\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/appevents/AppEventQueue.java",
              "file_line": [
                372
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.332-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "78e4564b-5227-4f88-9ab6-fc2d0b3d40d3",
              "value": "public static Intent createPlatformServiceIntent(Context context) {\n         for (NativeProtocol.NativeAppInfo appInfo : NativeProtocol.facebookAppInfoList) {\n             Intent intent = NativeProtocol.validateServiceIntent(context, new Intent(\"com.facebook.platform.PLATFORM_SERVICE\").setPackage(appInfo.getPackage()).addCategory(\"android.intent.category.DEFAULT\"), appInfo);\n             if (intent != null) {\n                 return intent;\n             }\n         }\n         return null;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/NativeProtocol.java",
              "file_line": [
                1230
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.421-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4d257eee-c1be-4146-892b-e4a15481f2d4",
              "value": "public final Intent zzd(Context context) {\n         Bundle bundle;\n         if (((zzm) this).zza != null) {\n             if (((zzm) this).zze) {\n                 Bundle bundle2 = new Bundle();\n                 bundle2.putString(\"serviceActionBundleKey\", ((zzm) this).zza);\n                 try {\n                     bundle = context.getContentResolver().call(zzm.zzf, \"serviceIntentCall\", (String) null, bundle2);\n                 } catch (IllegalArgumentException e) {\n                     String valueOf = String.valueOf(e);\n                     StringBuilder sb = new StringBuilder(String.valueOf(valueOf).length() + 34);\n                     sb.append(\"Dynamic intent resolution failed: \");\n                     sb.append(valueOf);\n                     Log.w(\"ConnectionStatusConfig\", sb.toString());\n                     bundle = null;\n                 }\n                 r2 = bundle != null ? (Intent) bundle.getParcelable(\"serviceResponseIntentKey\") : null;\n                 if (r2 == null) {\n                     String valueOf2 = String.valueOf(((zzm) this).zza);\n                     Log.w(\"ConnectionStatusConfig\", valueOf2.length() != 0 ? \"Dynamic lookup for intent failed for action: \".concat(valueOf2) : new String(\"Dynamic lookup for intent failed for action: \"));\n                 }\n             }\n             return r2 != null ? r2 : new Intent(((zzm) this).zza).setPackage(((zzm) this).zzb);\n         }\n         return new Intent().setComponent(((zzm) this).zzc);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/common/internal/zzm.java",
              "file_line": [
                470
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.565-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7350a03e-bd4a-4fcc-b190-69916c5ec386",
              "value": "private boolean ensureServiceBound(NotificationManagerCompat.SideChannelManager.ListenerRecord record) {\n         if (record.bound) {\n             return true;\n         }\n         Intent intent = new Intent(\"android.support.BIND_NOTIFICATION_SIDE_CHANNEL\").setComponent(record.componentName);\n         boolean bindService = ((NotificationManagerCompat.SideChannelManager) this).mContext.bindService(intent, this, 33);\n         record.bound = bindService;\n         if (bindService) {\n             record.retryCount = 0;\n         } else {\n             Log.w(\"NotifManCompat\", \"Unable to bind to listener \" + record.componentName);\n             ((NotificationManagerCompat.SideChannelManager) this).mContext.unbindService(this);\n         }\n         return record.bound;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/NotificationManagerCompat$SideChannelManager.java",
              "file_line": [
                138
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.814-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6211957d-17a6-4677-b72a-619b6e040c68",
              "value": "public void onReceive(Context context, Intent intent) {\n         String str;\n         if (intent == null) {\n             return;\n         }\n         try {\n             str = intent.getStringExtra(\"referrer\");\n         } catch (Throwable th) {\n             AFLogger.valueOf(\"error in BroadcastReceiver \", th);\n             str = null;\n         }\n         if (str != null && ai.values(context).getString(\"referrer\", null) != null) {\n             ai.valueOf().AFKeystoreWrapper(context, str);\n             return;\n         }\n         AFLogger.valueOf(\"MultipleInstallBroadcastReceiver called\");\n         ai.valueOf().values(context, intent);\n         for (ResolveInfo resolveInfo : context.getPackageManager().queryBroadcastReceivers(new Intent(\"com.android.vending.INSTALL_REFERRER\"), 0)) {\n             String action = intent.getAction();\n             if (((PackageItemInfo) resolveInfo.activityInfo).packageName.equals(context.getPackageName()) && \"com.android.vending.INSTALL_REFERRER\".equals(action) && !getClass().getName().equals(((PackageItemInfo) resolveInfo.activityInfo).name)) {\n                 StringBuilder sb = new StringBuilder(\"trigger onReceive: class: \");\n                 sb.append(((PackageItemInfo) resolveInfo.activityInfo).name);\n                 AFLogger.valueOf(sb.toString());\n                 try {\n                     ((BroadcastReceiver) Class.forName(((PackageItemInfo) resolveInfo.activityInfo).name).newInstance()).onReceive(context, intent);\n                 } catch (Throwable th2) {\n                     StringBuilder sb2 = new StringBuilder(\"error in BroadcastReceiver \");\n                     sb2.append(((PackageItemInfo) resolveInfo.activityInfo).name);\n                     AFLogger.valueOf(sb2.toString(), th2);\n                 }\n             }\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/appsflyer/MultipleInstallBroadcastReceiver.java",
              "file_line": [
                105
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.915-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "21ad09dd-bca6-4a35-b73b-35a6489e7416",
              "value": "r0 = th;\n      */\n         r9 = f.c.a.a.u.n(r43);\n      */\n     \n     public final void T(Context context, Bundle extras, String notifMessage, String notifTitle, int notificationId) {\n         String str;\n         NotificationCompat.BigTextStyle bigText;\n         int priorityInt;\n         String str2;\n         String str3;\n         NotificationCompat.Builder nb;\n         boolean z;\n         String str4;\n         String str5;\n         String actionsString;\n         JSONArray actions;\n         JSONArray actions2;\n         String intentServiceName;\n         boolean notificationViewedEnabled;\n         JSONArray actions3;\n         Class clazz;\n         boolean isCTIntentServiceAvailable;\n         String icoPath;\n         int priorityInt2;\n         String actionsString2;\n         String str6;\n         String str7;\n         String channelId;\n         String label;\n         String str8;\n         String dl;\n         String ico;\n         String id;\n         boolean autoCancel;\n         String ico2;\n         String channelId2;\n         int icon;\n         boolean sendToCTIntentService;\n         Intent actionLaunchIntent;\n         Uri soundUri;\n         Uri soundUri2;\n         String x;\n         Bitmap bpMap;\n         NotificationCompat.BigTextStyle bigPicture;\n         int notificationId2 = notificationId;\n         String str9 = \"wzrk_sound\";\n         NotificationManager notificationManager = (NotificationManager) context.getSystemService(\"notification\");\n         if (notificationManager == null) {\n             ((g) this).f.l().f(((g) this).f.c(), \"Unable to render notification, Notification Manager is null.\");\n             return;\n         }\n         String channelId3 = extras.getString(\"wzrk_cid\", \"\");\n         int i = Build.VERSION.SDK_INT;\n         String dl2 = \"dl\";\n         boolean requiresChannelId = i >= 26;\n         if (i >= 26) {\n             int messageCode = -1;\n             String value = \"\";\n             if (channelId3.isEmpty()) {\n                 messageCode = 8;\n                 value = extras.toString();\n             } else if (notificationManager.getNotificationChannel(channelId3) == null) {\n                 messageCode = 9;\n                 value = channelId3;\n             }\n             if (messageCode != -1) {\n                 b channelIdError = c.b(512, messageCode, new String[]{value});\n                 ((g) this).f.l().f(((g) this).f.c(), channelIdError.b());\n                 ((g) this).h.b(channelIdError);\n                 return;\n             }\n         }\n         String icoPath2 = extras.getString(\"ico\");\n         Intent launchIntent = new Intent(context, CTPushNotificationReceiver.class);\n         launchIntent.putExtras(extras);\n         String str10 = \"wzrk_acts\";\n         launchIntent.removeExtra(\"wzrk_acts\");\n         PendingIntent pIntent = PendingIntent.getBroadcast(context, (int) System.currentTimeMillis(), launchIntent, 134217728);\n         String bigPictureUrl = extras.getString(\"wzrk_bp\");\n         if (bigPictureUrl == null) {\n             str = \"ico\";\n         } else if (bigPictureUrl.startsWith(\"http\")) {\n             try {\n                 bpMap = h0.q(bigPictureUrl, false, context);\n                 try {\n                 } catch (Throwable th) {\n                     t = th;\n                     NotificationCompat.BigTextStyle bigText2 = new NotificationCompat.BigTextStyle().bigText(notifMessage);\n                     str = \"ico\";\n                     ((g) this).f.l().t(((g) this).f.c(), \"Falling back to big text notification, couldn't fetch big picture\", t);\n                     bigText = bigText2;\n                     x = d0.h(context).j();\n                     if (x == null) {\n                     }\n                 }\n             } catch (Throwable th2) {\n                 t = th2;\n             }\n             if (bpMap == null) {\n                 throw new Exception(\"Failed to fetch big picture!\");\n             }\n             if (extras.containsKey(\"wzrk_nms\")) {\n                 String summaryText = extras.getString(\"wzrk_nms\");\n                 bigPicture = new NotificationCompat.BigPictureStyle().setSummaryText(summaryText).bigPicture(bpMap);\n             } else {\n                 bigPicture = new NotificationCompat.BigPictureStyle().setSummaryText(notifMessage).bigPicture(bpMap);\n             }\n             str = \"ico\";\n             bigText = bigPicture;\n             x = d0.h(context).j();\n             if (x == null) {\n                 throw new IllegalArgumentException();\n             }\n             int smallIcon = context.getResources().getIdentifier(x, \"drawable\", context.getPackageName());\n             if (smallIcon == 0) {\n                 throw new IllegalArgumentException();\n             }\n             String priority = extras.getString(\"pr\");\n             if (priority != null) {\n                 int priorityInt3 = priority.equals(\"high\") ? 1 : 0;\n                 priorityInt = priority.equals(\"max\") ? 2 : priorityInt3;\n             } else {\n                 priorityInt = 0;\n             }\n             String channelId4 = \"drawable\";\n             if (notificationId2 == -1000) {\n                 try {\n                     Object collapse_key = extras.get(\"wzrk_ck\");\n                     if (collapse_key == null) {\n                         str2 = \"wzrk_sound\";\n                         str3 = \"wzrk_acts\";\n                     } else if (collapse_key instanceof Number) {\n                         notificationId2 = ((Number) collapse_key).intValue();\n                         str2 = \"wzrk_sound\";\n                         str3 = \"wzrk_acts\";\n                     } else if (collapse_key instanceof String) {\n                         try {\n                             notificationId2 = Integer.parseInt(collapse_key.toString());\n                             try {\n                                 c0 l = ((g) this).f.l();\n                                 str3 = \"wzrk_acts\";\n                                 try {\n                                     str10 = ((g) this).f.c();\n                                     str2 = \"wzrk_sound\";\n                                 } catch (NumberFormatException e) {\n                                     e = e;\n                                     str2 = \"wzrk_sound\";\n                                 }\n                                 try {\n                                     str9 = \"Converting collapse_key: \" + collapse_key + \" to notificationId int: \" + notificationId2;\n                                     l.f(str10, str9);\n                                 } catch (NumberFormatException e2) {\n                                     e = e2;\n                                     try {\n                                         notificationId2 = collapse_key.toString().hashCode();\n                                         str9 = ((g) this).f.l();\n                                         str10 = ((g) this).f.c();\n                                         str9.f(str10, \"Converting collapse_key: \" + collapse_key + \" to notificationId int: \" + notificationId2);\n                                     } catch (NumberFormatException e3) {\n                                     }\n                                     if (notificationId2 == -1000) {\n                                     }\n                                     if (requiresChannelId) {\n                                     }\n                                     if (extras.containsKey(\"wzrk_clr\")) {\n                                     }\n                                     nb.setContentTitle(notifTitle).setContentText(notifMessage).setContentIntent(pIntent).setAutoCancel(z).setStyle(bigText).setPriority(priorityInt).setSmallIcon(smallIcon);\n                                     String icoPath3 = icoPath2;\n                                     nb.setLargeIcon(h0.q(icoPath3, z, context));\n                                     str4 = str2;\n                                     if (extras.containsKey(str4)) {\n                                     }\n                                     String str11 = str3;\n                                     actionsString = extras.getString(str11);\n                                     if (actionsString == null) {\n                                     }\n                                     actions2 = actions;\n                                     intentServiceName = d0.h(context).i();\n                                     Class clazz2 = null;\n                                     if (intentServiceName != null) {\n                                     }\n                                     boolean isCTIntentServiceAvailable2 = G(context, clazz2);\n                                     if (actions2 == null) {\n                                     }\n                                     Notification n = nb.build();\n                                     notificationManager.notify(notificationId2, n);\n                                     ((g) this).f.l().f(((g) this).f.c(), \"Rendered notification: \" + n.toString());\n                                     String ttl = extras.getString(\"wzrk_ttl\", ((System.currentTimeMillis() + 345600000) / 1000) + \"\");\n                                     long wzrk_ttl = Long.parseLong(ttl);\n                                     String wzrk_pid = extras.getString(\"wzrk_pid\");\n                                     f.c.a.a.j0.b dbAdapter = ((g) this).e.c(context);\n                                     ((g) this).f.l().r(\"Storing Push Notification...\" + wzrk_pid + \" - with ttl - \" + ttl);\n                                     dbAdapter.K(wzrk_pid, wzrk_ttl);\n                                     notificationViewedEnabled = str5.equals(extras.getString(\"wzrk_rnv\", \"\"));\n                                     if (notificationViewedEnabled) {\n                                     }\n                                 }\n                             } catch (NumberFormatException e4) {\n                                 e = e4;\n                                 str2 = \"wzrk_sound\";\n                                 str3 = \"wzrk_acts\";\n                             }\n                         } catch (NumberFormatException e5) {\n                             e = e5;\n                             str2 = \"wzrk_sound\";\n                             str3 = \"wzrk_acts\";\n                         }\n                     } else {\n                         str2 = \"wzrk_sound\";\n                         str3 = \"wzrk_acts\";\n                     }\n                 } catch (NumberFormatException e6) {\n                     str2 = str9;\n                     str3 = str10;\n                 }\n             } else {\n                 str2 = \"wzrk_sound\";\n                 str3 = \"wzrk_acts\";\n                 ((g) this).f.l().f(((g) this).f.c(), \"Have user provided notificationId: \" + notificationId2 + \" won't use collapse_key (if any) as basis for notificationId\");\n             }\n             if (notificationId2 == -1000) {\n                 notificationId2 = (int) (Math.random() * 100.0d);\n                 ((g) this).f.l().f(((g) this).f.c(), \"Setting random notificationId: \" + notificationId2);\n             }\n             if (requiresChannelId) {\n                 nb = new NotificationCompat.Builder(context);\n             } else {\n                 nb = new NotificationCompat.Builder(context, channelId3);\n                 String badgeIconParam = extras.getString(\"wzrk_bi\", null);\n                 if (badgeIconParam != null) {\n                     try {\n                         int badgeIconType = Integer.parseInt(badgeIconParam);\n                         if (badgeIconType >= 0) {\n                             nb.setBadgeIconType(badgeIconType);\n                         }\n                     } catch (Throwable th3) {\n                     }\n                 }\n                 String badgeCountParam = extras.getString(\"wzrk_bc\", null);\n                 if (badgeCountParam != null) {\n                     try {\n                         int badgeCount = Integer.parseInt(badgeCountParam);\n                         if (badgeCount >= 0) {\n                             nb.setNumber(badgeCount);\n                         }\n                     } catch (Throwable th4) {\n                     }\n                 }\n                 if (extras.containsKey(\"wzrk_st\")) {\n                     nb.setSubText(extras.getString(\"wzrk_st\"));\n                 }\n             }\n             if (extras.containsKey(\"wzrk_clr\")) {\n                 z = true;\n             } else {\n                 int color = Color.parseColor(extras.getString(\"wzrk_clr\"));\n                 nb.setColor(color);\n                 z = true;\n                 nb.setColorized(true);\n             }\n             nb.setContentTitle(notifTitle).setContentText(notifMessage).setContentIntent(pIntent).setAutoCancel(z).setStyle(bigText).setPriority(priorityInt).setSmallIcon(smallIcon);\n             String icoPath32 = icoPath2;\n             nb.setLargeIcon(h0.q(icoPath32, z, context));\n             str4 = str2;\n             try {\n                 if (extras.containsKey(str4)) {\n                     str5 = \"true\";\n                 } else {\n                     Object o = extras.get(str4);\n                     if (o instanceof Boolean) {\n                         try {\n                             if (((Boolean) o).booleanValue()) {\n                                 soundUri = RingtoneManager.getDefaultUri(2);\n                                 str5 = \"true\";\n                                 if (soundUri != null) {\n                                     nb.setSound(soundUri);\n                                 }\n                             }\n                         } catch (Throwable th5) {\n                             t = th5;\n                             str5 = \"true\";\n                             ((g) this).f.l().g(((g) this).f.c(), \"Could not process sound parameter\", t);\n                             String str112 = str3;\n                             actionsString = extras.getString(str112);\n                             if (actionsString == null) {\n                             }\n                             actions2 = actions;\n                             intentServiceName = d0.h(context).i();\n                             Class clazz22 = null;\n                             if (intentServiceName != null) {\n                             }\n                             boolean isCTIntentServiceAvailable22 = G(context, clazz22);\n                             if (actions2 == null) {\n                             }\n                             Notification n2 = nb.build();\n                             notificationManager.notify(notificationId2, n2);\n                             ((g) this).f.l().f(((g) this).f.c(), \"Rendered notification: \" + n2.toString());\n                             String ttl2 = extras.getString(\"wzrk_ttl\", ((System.currentTimeMillis() + 345600000) / 1000) + \"\");\n                             long wzrk_ttl2 = Long.parseLong(ttl2);\n                             String wzrk_pid2 = extras.getString(\"wzrk_pid\");\n                             f.c.a.a.j0.b dbAdapter2 = ((g) this).e.c(context);\n                             ((g) this).f.l().r(\"Storing Push Notification...\" + wzrk_pid2 + \" - with ttl - \" + ttl2);\n                             dbAdapter2.K(wzrk_pid2, wzrk_ttl2);\n                             notificationViewedEnabled = str5.equals(extras.getString(\"wzrk_rnv\", \"\"));\n                             if (notificationViewedEnabled) {\n                             }\n                         }\n                     }\n                     if (o instanceof String) {\n                         String s = (String) o;\n                         str5 = \"true\";\n                         try {\n                             try {\n                                 if (s.equals(str5)) {\n                                     soundUri = RingtoneManager.getDefaultUri(2);\n                                 } else if (s.isEmpty()) {\n                                     soundUri2 = null;\n                                 } else {\n                                     if (s.contains(\".mp3\") || s.contains(\".ogg\") || s.contains(\".wav\")) {\n                                         try {\n                                             s = s.substring(0, s.length() - 4);\n                                         } catch (Throwable th6) {\n                                             t = th6;\n                                             ((g) this).f.l().g(((g) this).f.c(), \"Could not process sound parameter\", t);\n                                             String str1122 = str3;\n                                             actionsString = extras.getString(str1122);\n                                             if (actionsString == null) {\n                                             }\n                                             actions2 = actions;\n                                             intentServiceName = d0.h(context).i();\n                                             Class clazz222 = null;\n                                             if (intentServiceName != null) {\n                                             }\n                                             boolean isCTIntentServiceAvailable222 = G(context, clazz222);\n                                             if (actions2 == null) {\n                                             }\n                                             Notification n22 = nb.build();\n                                             notificationManager.notify(notificationId2, n22);\n                                             ((g) this).f.l().f(((g) this).f.c(), \"Rendered notification: \" + n22.toString());\n                                             String ttl22 = extras.getString(\"wzrk_ttl\", ((System.currentTimeMillis() + 345600000) / 1000) + \"\");\n                                             long wzrk_ttl22 = Long.parseLong(ttl22);\n                                             String wzrk_pid22 = extras.getString(\"wzrk_pid\");\n                                             f.c.a.a.j0.b dbAdapter22 = ((g) this).e.c(context);\n                                             ((g) this).f.l().r(\"Storing Push Notification...\" + wzrk_pid22 + \" - with ttl - \" + ttl22);\n                                             dbAdapter22.K(wzrk_pid22, wzrk_ttl22);\n                                             notificationViewedEnabled = str5.equals(extras.getString(\"wzrk_rnv\", \"\"));\n                                             if (notificationViewedEnabled) {\n                                             }\n                                         }\n                                     }\n                                     soundUri = Uri.parse(\"android.resource:\n                                 }\n                                 if (soundUri != null) {\n                                 }\n                             } catch (Throwable th7) {\n                                 t = th7;\n                                 ((g) this).f.l().g(((g) this).f.c(), \"Could not process sound parameter\", t);\n                                 String str11222 = str3;\n                                 actionsString = extras.getString(str11222);\n                                 if (actionsString == null) {\n                                 }\n                                 actions2 = actions;\n                                 intentServiceName = d0.h(context).i();\n                                 Class clazz2222 = null;\n                                 if (intentServiceName != null) {\n                                 }\n                                 boolean isCTIntentServiceAvailable2222 = G(context, clazz2222);\n                                 if (actions2 == null) {\n                                 }\n                                 Notification n222 = nb.build();\n                                 notificationManager.notify(notificationId2, n222);\n                                 ((g) this).f.l().f(((g) this).f.c(), \"Rendered notification: \" + n222.toString());\n                                 String ttl222 = extras.getString(\"wzrk_ttl\", ((System.currentTimeMillis() + 345600000) / 1000) + \"\");\n                                 long wzrk_ttl222 = Long.parseLong(ttl222);\n                                 String wzrk_pid222 = extras.getString(\"wzrk_pid\");\n                                 f.c.a.a.j0.b dbAdapter222 = ((g) this).e.c(context);\n                                 ((g) this).f.l().r(\"Storing Push Notification...\" + wzrk_pid222 + \" - with ttl - \" + ttl222);\n                                 dbAdapter222.K(wzrk_pid222, wzrk_ttl222);\n                                 notificationViewedEnabled = str5.equals(extras.getString(\"wzrk_rnv\", \"\"));\n                                 if (notificationViewedEnabled) {\n                                 }\n                             }\n                         } catch (Throwable th8) {\n                             t = th8;\n                             ((g) this).f.l().g(((g) this).f.c(), \"Could not process sound parameter\", t);\n                             String str112222 = str3;\n                             actionsString = extras.getString(str112222);\n                             if (actionsString == null) {\n                             }\n                             actions2 = actions;\n                             intentServiceName = d0.h(context).i();\n                             Class clazz22222 = null;\n                             if (intentServiceName != null) {\n                             }\n                             boolean isCTIntentServiceAvailable22222 = G(context, clazz22222);\n                             if (actions2 == null) {\n                             }\n                             Notification n2222 = nb.build();\n                             notificationManager.notify(notificationId2, n2222);\n                             ((g) this).f.l().f(((g) this).f.c(), \"Rendered notification: \" + n2222.toString());\n                             String ttl2222 = extras.getString(\"wzrk_ttl\", ((System.currentTimeMillis() + 345600000) / 1000) + \"\");\n                             long wzrk_ttl2222 = Long.parseLong(ttl2222);\n                             String wzrk_pid2222 = extras.getString(\"wzrk_pid\");\n                             f.c.a.a.j0.b dbAdapter2222 = ((g) this).e.c(context);\n                             ((g) this).f.l().r(\"Storing Push Notification...\" + wzrk_pid2222 + \" - with ttl - \" + ttl2222);\n                             dbAdapter2222.K(wzrk_pid2222, wzrk_ttl2222);\n                             notificationViewedEnabled = str5.equals(extras.getString(\"wzrk_rnv\", \"\"));\n                             if (notificationViewedEnabled) {\n                             }\n                         }\n                     } else {\n                         soundUri2 = null;\n                         str5 = \"true\";\n                     }\n                     soundUri = soundUri2;\n                     if (soundUri != null) {\n                     }\n                 }\n             } catch (Throwable th9) {\n                 t = th9;\n                 str5 = \"true\";\n             }\n             String str1122222 = str3;\n             actionsString = extras.getString(str1122222);\n             if (actionsString == null) {\n                 try {\n                     actions2 = new JSONArray(actionsString);\n                 } catch (Throwable t) {\n                     actions = null;\n                     ((g) this).f.l().f(((g) this).f.c(), \"error parsing notification actions: \" + t.getLocalizedMessage());\n                 }\n                 intentServiceName = d0.h(context).i();\n                 Class clazz222222 = null;\n                 if (intentServiceName != null) {\n                     try {\n                         clazz222222 = Class.forName(intentServiceName);\n                     } catch (ClassNotFoundException e7) {\n                         try {\n                             clazz222222 = Class.forName(\"com.clevertap.android.sdk.pushnotification.CTNotificationIntentService\");\n                         } catch (ClassNotFoundException e8) {\n                             c0.a(\"No Intent Service found\");\n                         }\n                     }\n                 } else {\n                     try {\n                         clazz222222 = Class.forName(\"com.clevertap.android.sdk.pushnotification.CTNotificationIntentService\");\n                     } catch (ClassNotFoundException e9) {\n                         c0.a(\"No Intent Service found\");\n                     }\n                 }\n                 boolean isCTIntentServiceAvailable222222 = G(context, clazz222222);\n                 if (actions2 == null && actions2.length() > 0) {\n                     int i2 = 0;\n                     while (i2 < actions2.length()) {\n                         try {\n                             JSONObject action = actions2.getJSONObject(i2);\n                             actions3 = actions2;\n                             try {\n                                 label = action.optString(\"l\");\n                                 clazz = clazz222222;\n                                 str8 = dl2;\n                                 try {\n                                     dl = action.optString(str8);\n                                     icoPath = icoPath32;\n                                     String icoPath4 = str;\n                                     try {\n                                         ico = action.optString(icoPath4);\n                                         id = action.optString(\"id\");\n                                         str7 = icoPath4;\n                                         try {\n                                             autoCancel = action.optBoolean(\"ac\", true);\n                                         } catch (Throwable th10) {\n                                             t = th10;\n                                             dl2 = str8;\n                                             isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                                             priorityInt2 = priorityInt;\n                                             actionsString2 = actionsString;\n                                             str6 = channelId4;\n                                             channelId = channelId3;\n                                             ((g) this).f.l().f(((g) this).f.c(), \"error adding notification action : \" + t.getLocalizedMessage());\n                                             i2++;\n                                             channelId3 = channelId;\n                                             actions2 = actions3;\n                                             clazz222222 = clazz;\n                                             icoPath32 = icoPath;\n                                             isCTIntentServiceAvailable222222 = isCTIntentServiceAvailable;\n                                             str = str7;\n                                             priorityInt = priorityInt2;\n                                             channelId4 = str6;\n                                             actionsString = actionsString2;\n                                         }\n                                     } catch (Throwable th11) {\n                                         t = th11;\n                                         dl2 = str8;\n                                         isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                                         str7 = icoPath4;\n                                     }\n                                 } catch (Throwable th12) {\n                                     t = th12;\n                                     dl2 = str8;\n                                     isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                                     icoPath = icoPath32;\n                                     priorityInt2 = priorityInt;\n                                     actionsString2 = actionsString;\n                                     str6 = channelId4;\n                                     str7 = str;\n                                     channelId = channelId3;\n                                 }\n                             } catch (Throwable th13) {\n                                 t = th13;\n                                 clazz = clazz222222;\n                                 isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                                 icoPath = icoPath32;\n                                 priorityInt2 = priorityInt;\n                                 actionsString2 = actionsString;\n                                 str6 = channelId4;\n                                 str7 = str;\n                                 channelId = channelId3;\n                             }\n                         } catch (Throwable th14) {\n                             t = th14;\n                             actions3 = actions2;\n                             clazz = clazz222222;\n                             isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                             icoPath = icoPath32;\n                             priorityInt2 = priorityInt;\n                             actionsString2 = actionsString;\n                             str6 = channelId4;\n                             str7 = str;\n                             channelId = channelId3;\n                         }\n                         if (label.isEmpty()) {\n                             priorityInt2 = priorityInt;\n                             actionsString2 = actionsString;\n                             str6 = channelId4;\n                             isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                             channelId = channelId3;\n                             dl2 = str8;\n                         } else if (id.isEmpty()) {\n                             priorityInt2 = priorityInt;\n                             actionsString2 = actionsString;\n                             str6 = channelId4;\n                             isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                             channelId = channelId3;\n                             dl2 = str8;\n                         } else {\n                             if (ico.isEmpty()) {\n                                 priorityInt2 = priorityInt;\n                                 actionsString2 = actionsString;\n                                 str6 = channelId4;\n                                 channelId = channelId3;\n                             } else {\n                                 try {\n                                     try {\n                                         priorityInt2 = priorityInt;\n                                         ico2 = ico;\n                                         String str12 = channelId4;\n                                         channelId = channelId3;\n                                         channelId2 = str12;\n                                         try {\n                                             int icon2 = context.getResources().getIdentifier(ico2, channelId2, context.getPackageName());\n                                             str6 = channelId2;\n                                             actionsString2 = actionsString;\n                                             icon = icon2;\n                                         } catch (Throwable th15) {\n                                             t = th15;\n                                             try {\n                                                 c0 l2 = ((g) this).f.l();\n                                                 String c = ((g) this).f.c();\n                                                 str6 = channelId2;\n                                                 try {\n                                                     StringBuilder sb = new StringBuilder();\n                                                     actionsString2 = actionsString;\n                                                     sb.append(\"unable to add notification action icon: \");\n                                                     sb.append(t.getLocalizedMessage());\n                                                     l2.f(c, sb.toString());\n                                                     icon = 0;\n                                                     if (autoCancel) {\n                                                     }\n                                                     if (sendToCTIntentService) {\n                                                     }\n                                                     if (actionLaunchIntent != null) {\n                                                     }\n                                                     isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                                                     int requestCode = ((int) System.currentTimeMillis()) + i2;\n                                                     if (sendToCTIntentService) {\n                                                     }\n                                                     nb.addAction(icon, label, actionIntent);\n                                                 } catch (Throwable th16) {\n                                                     t = th16;\n                                                     actionsString2 = actionsString;\n                                                     dl2 = str8;\n                                                     isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                                                     ((g) this).f.l().f(((g) this).f.c(), \"error adding notification action : \" + t.getLocalizedMessage());\n                                                     i2++;\n                                                     channelId3 = channelId;\n                                                     actions2 = actions3;\n                                                     clazz222222 = clazz;\n                                                     icoPath32 = icoPath;\n                                                     isCTIntentServiceAvailable222222 = isCTIntentServiceAvailable;\n                                                     str = str7;\n                                                     priorityInt = priorityInt2;\n                                                     channelId4 = str6;\n                                                     actionsString = actionsString2;\n                                                 }\n                                             } catch (Throwable th17) {\n                                                 t = th17;\n                                                 str6 = channelId2;\n                                             }\n                                             i2++;\n                                             channelId3 = channelId;\n                                             actions2 = actions3;\n                                             clazz222222 = clazz;\n                                             icoPath32 = icoPath;\n                                             isCTIntentServiceAvailable222222 = isCTIntentServiceAvailable;\n                                             str = str7;\n                                             priorityInt = priorityInt2;\n                                             channelId4 = str6;\n                                             actionsString = actionsString2;\n                                         }\n                                     } catch (Throwable th18) {\n                                         t = th18;\n                                         priorityInt2 = priorityInt;\n                                         ico2 = ico;\n                                         String str13 = channelId4;\n                                         channelId = channelId3;\n                                         channelId2 = str13;\n                                     }\n                                 } catch (Throwable th19) {\n                                     t = th19;\n                                     priorityInt2 = priorityInt;\n                                     ico2 = ico;\n                                     String str14 = channelId4;\n                                     channelId = channelId3;\n                                     channelId2 = str14;\n                                 }\n                                 sendToCTIntentService = !autoCancel && isCTIntentServiceAvailable222222;\n                                 if (sendToCTIntentService) {\n                                     try {\n                                         actionLaunchIntent = new Intent(\"com.clevertap.PUSH_EVENT\");\n                                         actionLaunchIntent.setPackage(context.getPackageName());\n                                         actionLaunchIntent.putExtra(\"ct_type\", \"com.clevertap.ACTION_BUTTON_CLICK\");\n                                         if (!dl.isEmpty()) {\n                                             actionLaunchIntent.putExtra(str8, dl);\n                                         }\n                                         dl2 = str8;\n                                     } catch (Throwable th20) {\n                                         t = th20;\n                                         dl2 = str8;\n                                         isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                                         ((g) this).f.l().f(((g) this).f.c(), \"error adding notification action : \" + t.getLocalizedMessage());\n                                         i2++;\n                                         channelId3 = channelId;\n                                         actions2 = actions3;\n                                         clazz222222 = clazz;\n                                         icoPath32 = icoPath;\n                                         isCTIntentServiceAvailable222222 = isCTIntentServiceAvailable;\n                                         str = str7;\n                                         priorityInt = priorityInt2;\n                                         channelId4 = str6;\n                                         actionsString = actionsString2;\n                                     }\n                                 } else {\n                                     try {\n                                         if (dl.isEmpty()) {\n                                             dl2 = str8;\n                                             try {\n                                                 actionLaunchIntent = context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());\n                                             } catch (Throwable th21) {\n                                                 t = th21;\n                                                 isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                                                 ((g) this).f.l().f(((g) this).f.c(), \"error adding notification action : \" + t.getLocalizedMessage());\n                                                 i2++;\n                                                 channelId3 = channelId;\n                                                 actions2 = actions3;\n                                                 clazz222222 = clazz;\n                                                 icoPath32 = icoPath;\n                                                 isCTIntentServiceAvailable222222 = isCTIntentServiceAvailable;\n                                                 str = str7;\n                                                 priorityInt = priorityInt2;\n                                                 channelId4 = str6;\n                                                 actionsString = actionsString2;\n                                             }\n                                         } else {\n                                             dl2 = str8;\n                                             actionLaunchIntent = new Intent(\"android.intent.action.VIEW\", Uri.parse(dl));\n                                         }\n                                     } catch (Throwable th22) {\n                                         t = th22;\n                                         dl2 = str8;\n                                     }\n                                 }\n                                 if (actionLaunchIntent != null) {\n                                     try {\n                                         actionLaunchIntent.putExtras(extras);\n                                         actionLaunchIntent.removeExtra(str1122222);\n                                         actionLaunchIntent.putExtra(\"actionId\", id);\n                                         actionLaunchIntent.putExtra(\"autoCancel\", autoCancel);\n                                         actionLaunchIntent.putExtra(\"wzrk_c2a\", id);\n                                         actionLaunchIntent.putExtra(\"notificationId\", notificationId2);\n                                         actionLaunchIntent.setFlags(603979776);\n                                     } catch (Throwable th23) {\n                                         t = th23;\n                                         isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                                         ((g) this).f.l().f(((g) this).f.c(), \"error adding notification action : \" + t.getLocalizedMessage());\n                                         i2++;\n                                         channelId3 = channelId;\n                                         actions2 = actions3;\n                                         clazz222222 = clazz;\n                                         icoPath32 = icoPath;\n                                         isCTIntentServiceAvailable222222 = isCTIntentServiceAvailable;\n                                         str = str7;\n                                         priorityInt = priorityInt2;\n                                         channelId4 = str6;\n                                         actionsString = actionsString2;\n                                     }\n                                 }\n                                 isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                                 int requestCode2 = ((int) System.currentTimeMillis()) + i2;\n                                 PendingIntent actionIntent = sendToCTIntentService ? PendingIntent.getService(context, requestCode2, actionLaunchIntent, 134217728) : PendingIntent.getActivity(context, requestCode2, actionLaunchIntent, 134217728);\n                                 nb.addAction(icon, label, actionIntent);\n                                 i2++;\n                                 channelId3 = channelId;\n                                 actions2 = actions3;\n                                 clazz222222 = clazz;\n                                 icoPath32 = icoPath;\n                                 isCTIntentServiceAvailable222222 = isCTIntentServiceAvailable;\n                                 str = str7;\n                                 priorityInt = priorityInt2;\n                                 channelId4 = str6;\n                                 actionsString = actionsString2;\n                             }\n                             icon = 0;\n                             if (autoCancel) {\n                             }\n                             if (sendToCTIntentService) {\n                             }\n                             if (actionLaunchIntent != null) {\n                             }\n                             isCTIntentServiceAvailable = isCTIntentServiceAvailable222222;\n                             int requestCode22 = ((int) System.currentTimeMillis()) + i2;\n                             if (sendToCTIntentService) {\n                             }\n                             nb.addAction(icon, label, actionIntent);\n                             i2++;\n                             channelId3 = channelId;\n                             actions2 = actions3;\n                             clazz222222 = clazz;\n                             icoPath32 = icoPath;\n                             isCTIntentServiceAvailable222222 = isCTIntentServiceAvailable;\n                             str = str7;\n                             priorityInt = priorityInt2;\n                             channelId4 = str6;\n                             actionsString = actionsString2;\n                         }\n                         ((g) this).f.l().f(((g) this).f.c(), \"not adding push notification action: action label or id missing\");\n                         i2++;\n                         channelId3 = channelId;\n                         actions2 = actions3;\n                         clazz222222 = clazz;\n                         icoPath32 = icoPath;\n                         isCTIntentServiceAvailable222222 = isCTIntentServiceAvailable;\n                         str = str7;\n                         priorityInt = priorityInt2;\n                         channelId4 = str6;\n                         actionsString = actionsString2;\n                     }\n                 }\n                 Notification n22222 = nb.build();\n                 notificationManager.notify(notificationId2, n22222);\n                 ((g) this).f.l().f(((g) this).f.c(), \"Rendered notification: \" + n22222.toString());\n                 String ttl22222 = extras.getString(\"wzrk_ttl\", ((System.currentTimeMillis() + 345600000) / 1000) + \"\");\n                 long wzrk_ttl22222 = Long.parseLong(ttl22222);\n                 String wzrk_pid22222 = extras.getString(\"wzrk_pid\");\n                 f.c.a.a.j0.b dbAdapter22222 = ((g) this).e.c(context);\n                 ((g) this).f.l().r(\"Storing Push Notification...\" + wzrk_pid22222 + \" - with ttl - \" + ttl22222);\n                 dbAdapter22222.K(wzrk_pid22222, wzrk_ttl22222);\n                 notificationViewedEnabled = str5.equals(extras.getString(\"wzrk_rnv\", \"\"));\n                 if (notificationViewedEnabled) {\n                     ((g) this).d.G(extras);\n                     return;\n                 }\n                 b notificationViewedError = c.b(512, 10, new String[]{extras.toString()});\n                 ((g) this).f.l().e(notificationViewedError.b());\n                 ((g) this).h.b(notificationViewedError);\n                 return;\n             }\n             actions = null;\n             actions2 = actions;\n             intentServiceName = d0.h(context).i();\n             Class clazz2222222 = null;\n             if (intentServiceName != null) {\n             }\n             boolean isCTIntentServiceAvailable2222222 = G(context, clazz2222222);\n             if (actions2 == null) {\n             }\n             Notification n222222 = nb.build();\n             notificationManager.notify(notificationId2, n222222);\n             ((g) this).f.l().f(((g) this).f.c(), \"Rendered notification: \" + n222222.toString());\n             String ttl222222 = extras.getString(\"wzrk_ttl\", ((System.currentTimeMillis() + 345600000) / 1000) + \"\");\n             long wzrk_ttl222222 = Long.parseLong(ttl222222);\n             String wzrk_pid222222 = extras.getString(\"wzrk_pid\");\n             f.c.a.a.j0.b dbAdapter222222 = ((g) this).e.c(context);\n             ((g) this).f.l().r(\"Storing Push Notification...\" + wzrk_pid222222 + \" - with ttl - \" + ttl222222);\n             dbAdapter222222.K(wzrk_pid222222, wzrk_ttl222222);\n             notificationViewedEnabled = str5.equals(extras.getString(\"wzrk_rnv\", \"\"));\n             if (notificationViewedEnabled) {\n             }\n         } else {\n             str = \"ico\";\n         }\n         bigText = new NotificationCompat.BigTextStyle().bigText(notifMessage);\n         x = d0.h(context).j();\n         if (x == null) {\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/u0/g.java",
              "file_line": [
                3632
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.101-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "30eebd5a-3eab-451f-a1f9-c43c3e08d1ce",
              "value": "private void sendCurrentProfileChangedBroadcast(Profile oldProfile, Profile currentProfile) {\n         Intent intent = new Intent(\"com.facebook.sdk.ACTION_CURRENT_PROFILE_CHANGED\");\n         intent.putExtra(\"com.facebook.sdk.EXTRA_OLD_PROFILE\", (Parcelable) oldProfile);\n         intent.putExtra(\"com.facebook.sdk.EXTRA_NEW_PROFILE\", (Parcelable) currentProfile);\n         ((ProfileManager) this).localBroadcastManager.sendBroadcast(intent);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/ProfileManager.java",
              "file_line": [
                133
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.308-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5e0b11f9-503f-4150-8d80-24149b3a844a",
              "value": "public static boolean isAutoAppLinkSetup() {\n         try {\n             Intent intent = new Intent(\"android.intent.action.VIEW\");\n             intent.setData(Uri.parse(String.format(\"fb%s:\n             Context ctx = FacebookSdk.getApplicationContext();\n             PackageManager packageManager = ctx.getPackageManager();\n             String packageName = ctx.getPackageName();\n             List<ResolveInfo> activities = packageManager.queryIntentActivities(intent, 65536);\n             for (ResolveInfo info : activities) {\n                 if (packageName.equals(info.activityInfo.packageName)) {\n                     return true;\n                 }\n             }\n         } catch (Exception e) {\n         }\n         return false;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/Utility.java",
              "file_line": [
                2667
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.439-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "29a14c51-2a18-42cd-85b6-74086c565a7f",
              "value": "public final synchronized int zza() {\n         int i = ((zzr) this).zzc;\n         if (i != 0) {\n             return i;\n         }\n         PackageManager packageManager = ((zzr) this).zza.getPackageManager();\n         if (Wrappers.packageManager(((zzr) this).zza).checkPermission(\"com.google.android.c2dm.permission.SEND\", \"com.google.android.gms\") == -1) {\n             Log.e(\"Metadata\", \"Google Play services missing or without correct permission.\");\n             return 0;\n         }\n         if (!PlatformVersion.isAtLeastO()) {\n             Intent intent = new Intent(\"com.google.android.c2dm.intent.REGISTER\");\n             intent.setPackage(\"com.google.android.gms\");\n             List<ResolveInfo> queryIntentServices = packageManager.queryIntentServices(intent, 0);\n             if (queryIntentServices != null && queryIntentServices.size() > 0) {\n                 ((zzr) this).zzc = 1;\n                 return 1;\n             }\n         }\n         Intent intent2 = new Intent(\"com.google.iid.TOKEN_REQUEST\");\n         intent2.setPackage(\"com.google.android.gms\");\n         List<ResolveInfo> queryBroadcastReceivers = packageManager.queryBroadcastReceivers(intent2, 0);\n         if (queryBroadcastReceivers != null && queryBroadcastReceivers.size() > 0) {\n             ((zzr) this).zzc = 2;\n             return 2;\n         }\n         Log.w(\"Metadata\", \"Failed to resolve IID implementation package, falling back\");\n         if (PlatformVersion.isAtLeastO()) {\n             ((zzr) this).zzc = 2;\n         } else {\n             ((zzr) this).zzc = 1;\n         }\n         return ((zzr) this).zzc;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/cloudmessaging/zzr.java",
              "file_line": [
                189
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.520-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "03eae672-f038-4cbd-8bee-3be5b24bc31b",
              "value": "public static Intent zzc() {\n         Intent intent = new Intent(\"com.google.android.clockwork.home.UPDATE_ANDROID_WEAR_ACTION\");\n         intent.setPackage(\"com.google.android.wearable.app\");\n         return intent;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/common/internal/zzs.java",
              "file_line": [
                155
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.626-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f97b73ff-225e-4f4f-8253-289f3d143511",
              "value": "public synchronized int getIidImplementation() {\n         int i = ((Metadata) this).iidImplementation;\n         if (i != 0) {\n             return i;\n         }\n         PackageManager packageManager = ((Metadata) this).context.getPackageManager();\n         if (packageManager.checkPermission(\"com.google.android.c2dm.permission.SEND\", \"com.google.android.gms\") == -1) {\n             Log.e(\"FirebaseMessaging\", \"Google Play services missing or without correct permission.\");\n             return 0;\n         }\n         int i2 = 1;\n         if (!PlatformVersion.isAtLeastO()) {\n             Intent intent = new Intent(\"com.google.android.c2dm.intent.REGISTER\");\n             intent.setPackage(\"com.google.android.gms\");\n             List<ResolveInfo> queryIntentServices = packageManager.queryIntentServices(intent, 0);\n             if (queryIntentServices != null && queryIntentServices.size() > 0) {\n                 ((Metadata) this).iidImplementation = 1;\n                 return i2;\n             }\n         }\n         Intent intent2 = new Intent(\"com.google.iid.TOKEN_REQUEST\");\n         intent2.setPackage(\"com.google.android.gms\");\n         List<ResolveInfo> queryBroadcastReceivers = packageManager.queryBroadcastReceivers(intent2, 0);\n         if (queryBroadcastReceivers != null && queryBroadcastReceivers.size() > 0) {\n             ((Metadata) this).iidImplementation = 2;\n             return 2;\n         }\n         Log.w(\"FirebaseMessaging\", \"Failed to resolve IID implementation package, falling back\");\n         if (PlatformVersion.isAtLeastO()) {\n             ((Metadata) this).iidImplementation = 2;\n             i2 = 2;\n         } else {\n             ((Metadata) this).iidImplementation = 1;\n         }\n         return i2;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/firebase/messaging/Metadata.java",
              "file_line": [
                410
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.693-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "10c2e428-a24e-4511-96dc-d2ab9e0c56b2",
              "value": "public void backToMerchant(Activity activity, SdkResponse sdkResponse) {\n         Intent broadcastIntent = new Intent(\"responseEvent\");\n         broadcastIntent.putExtra(\"sdkResp\", (Serializable) sdkResponse);\n         LocalBroadcastManager.getInstance(activity).sendBroadcast(broadcastIntent);\n         activity.finish();\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/payfort/fort/android/sdk/activities/services/CreditPaymentService.java",
              "file_line": [
                88
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.835-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "25b528e2-5d97-4e10-bc70-f3ee6f8aff3a",
              "value": "private void handleActionButtonClick(Bundle extras) {\n         Intent launchIntent;\n         NotificationManager notificationManager;\n         try {\n             boolean autoCancel = extras.getBoolean(\"autoCancel\", false);\n             int notificationId = extras.getInt(\"notificationId\", -1);\n             String dl = extras.getString(\"dl\");\n             Context context = getApplicationContext();\n             if (dl != null) {\n                 launchIntent = new Intent(\"android.intent.action.VIEW\", Uri.parse(dl));\n                 h0.w(context, launchIntent);\n             } else {\n                 launchIntent = context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());\n             }\n             if (launchIntent == null) {\n                 c0.n(\"CTNotificationService: create launch intent.\");\n                 return;\n             }\n             launchIntent.setFlags(872415232);\n             launchIntent.putExtras(extras);\n             launchIntent.removeExtra(\"dl\");\n             if (autoCancel && notificationId > -1 && (notificationManager = (NotificationManager) getApplicationContext().getSystemService(\"notification\")) != null) {\n                 notificationManager.cancel(notificationId);\n             }\n             sendBroadcast(new Intent(\"android.intent.action.CLOSE_SYSTEM_DIALOGS\"));\n             startActivity(launchIntent);\n         } catch (Throwable t) {\n             c0.n(\"CTNotificationService: unable to process action button click:  \" + t.getLocalizedMessage());\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/clevertap/android/sdk/pushnotification/CTNotificationIntentService.java",
              "file_line": [
                159
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.939-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b2fa72e1-3456-43a0-9d91-151212ce176c",
              "value": "public static final void p(CouponDialogFragment this$0, Phone $this_run, View it) {\n         q.f(this$0, \"this$0\");\n         q.f($this_run, \"$this_run\");\n         Intent $this$setCouponView_u24lambda_u2d18_u24lambda_u2d14_u24lambda_u2d13_u24lambda_u2d12_u24lambda_u2d11 = new Intent(\"android.intent.action.DIAL\");\n         $this$setCouponView_u24lambda_u2d18_u24lambda_u2d14_u24lambda_u2d13_u24lambda_u2d12_u24lambda_u2d11.setData(Uri.parse(q.n(\"tel:\", $this_run.a())));\n         t tVar = t.a;\n         this$0.startActivity($this$setCouponView_u24lambda_u2d18_u24lambda_u2d14_u24lambda_u2d13_u24lambda_u2d12_u24lambda_u2d11);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/fake/app/offers/screens/redeem/CouponDialogFragment.java",
              "file_line": [
                323
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.961-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e20eee50-3ce8-4810-aa0a-5ead991e813b",
              "value": "public static final void s(CouponDialogFragment this$0, String $phone, View it) {\n         q.f(this$0, \"this$0\");\n         q.f($phone, \"$phone\");\n         Intent $this$setHardcodedCouponView_u24lambda_u2d21_u24lambda_u2d20_u24lambda_u2d19 = new Intent(\"android.intent.action.DIAL\");\n         $this$setHardcodedCouponView_u24lambda_u2d21_u24lambda_u2d20_u24lambda_u2d19.setData(Uri.parse(q.n(\"tel:\", $phone)));\n         t tVar = t.a;\n         this$0.startActivity($this$setHardcodedCouponView_u24lambda_u2d21_u24lambda_u2d20_u24lambda_u2d19);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/fake/app/offers/screens/redeem/CouponDialogFragment.java",
              "file_line": [
                464
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:05.981-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d113350c-3855-48a6-bcd1-10d9ab78e3c3",
              "value": "public final void H0(boolean isUserLoggedIn) {\n         Intent intent = new Intent(\"broadcast_login_state_changed\");\n         intent.putExtra(\"is_user_logged_in\", isUserLoggedIn);\n         LocalBroadcastManager.getInstance(q0().getContext()).sendBroadcast(intent);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/d/a/c/e/a/b/b.java",
              "file_line": [
                1393
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.222-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c319c432-ece2-4541-963e-cc009fcb2525",
              "value": "public void onNewIntent(Intent intent) {\n         super.onNewIntent(intent);\n         if (CustomTabMainActivity.REFRESH_ACTION.equals(intent.getAction())) {\n             Intent broadcast = new Intent(CustomTabActivity.DESTROY_ACTION);\n             LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);\n             sendResult(-1, intent);\n         } else if (CustomTabActivity.CUSTOM_TAB_REDIRECT_ACTION.equals(intent.getAction())) {\n             sendResult(-1, intent);\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/CustomTabMainActivity.java",
              "file_line": [
                496
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.289-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9ae69ba6-a786-4d71-b561-ee79a03b961c",
              "value": "private static AttributionIdentifiers getAndroidIdViaService(Context context) {\n         AttributionIdentifiers.GoogleAdServiceConnection connection = new AttributionIdentifiers.GoogleAdServiceConnection((AttributionIdentifiers.1) null);\n         Intent intent = new Intent(\"com.google.android.gms.ads.identifier.service.START\");\n         intent.setPackage(\"com.google.android.gms\");\n         if (context.bindService(intent, connection, 1)) {\n             try {\n                 AttributionIdentifiers.GoogleAdInfo adInfo = new AttributionIdentifiers.GoogleAdInfo(connection.getBinder());\n                 AttributionIdentifiers identifiers = new AttributionIdentifiers();\n                 identifiers.androidAdvertiserId = adInfo.getAdvertiserId();\n                 identifiers.limitTracking = adInfo.isTrackingLimited();\n                 return identifiers;\n             } catch (Exception exception) {\n                 Utility.logd(\"android_id\", exception);\n             } finally {\n                 context.unbindService(connection);\n             }\n         }\n         return null;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/AttributionIdentifiers.java",
              "file_line": [
                306
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.362-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ca402dd4-f413-4a36-90eb-67317bbcaf65",
              "value": "public static String getChromePackage() {\n         Context context = FacebookSdk.getApplicationContext();\n         Intent serviceIntent = new Intent(\"android.support.customtabs.action.CustomTabsService\");\n         List<ResolveInfo> resolveInfos = context.getPackageManager().queryIntentServices(serviceIntent, 0);\n         if (resolveInfos != null) {\n             Set<String> chromePackages = new HashSet<>(Arrays.asList(CustomTabUtils.CHROME_PACKAGES));\n             for (ResolveInfo resolveInfo : resolveInfos) {\n                 ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n                 if (serviceInfo != null && chromePackages.contains(serviceInfo.packageName)) {\n                     return serviceInfo.packageName;\n                 }\n             }\n             return null;\n         }\n         return null;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/internal/CustomTabUtils.java",
              "file_line": [
                58
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.382-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "209a750e-9de2-4e31-91da-a1f342276174",
              "value": "private static void broadcastAction(LikeActionController controller, String action, Bundle data) {\n         Intent broadcastIntent = new Intent(action);\n         if (controller != null) {\n             if (data == null) {\n                 data = new Bundle();\n             }\n             data.putString(\"com.facebook.sdk.LikeActionController.OBJECT_ID\", controller.getObjectId());\n         }\n         if (data != null) {\n             broadcastIntent.putExtras(data);\n         }\n         LocalBroadcastManager.getInstance(FacebookSdk.getApplicationContext()).sendBroadcast(broadcastIntent);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/share/internal/LikeActionController.java",
              "file_line": [
                578
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.501-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ccd27534-501a-41ca-a713-f5cdc8d88362",
              "value": "public Void a() {\n         if (((g.c) this).c.F()) {\n             c0.o(g.c(((g.c) this).c).c(), \"Token is not present, not running the Job\");\n             return null;\n         }\n         Calendar now = Calendar.getInstance();\n         int hour = now.get(11);\n         int minute = now.get(12);\n         g gVar = ((g.c) this).c;\n         Date currentTime = g.j(gVar, hour + \":\" + minute);\n         Date startTime = g.j(((g.c) this).c, \"22:00\");\n         Date endTime = g.j(((g.c) this).c, \"06:00\");\n         if (!g.k(((g.c) this).c, startTime, endTime, currentTime)) {\n             long lastTS = g.d(((g.c) this).c).c(((g.c) this).a).E();\n             if (lastTS == 0 || lastTS > System.currentTimeMillis() - 86400000) {\n                 try {\n                     JSONObject eventObject = new JSONObject();\n                     eventObject.put(\"bk\", 1);\n                     g.l(((g.c) this).c).N(eventObject);\n                     if (((g.c) this).b == null) {\n                         int pingFrequency = g.m(((g.c) this).c, ((g.c) this).a);\n                         AlarmManager alarmManager = (AlarmManager) ((g.c) this).a.getSystemService(\"alarm\");\n                         Intent cancelIntent = new Intent(\"com.clevertap.BG_EVENT\");\n                         cancelIntent.setPackage(((g.c) this).a.getPackageName());\n                         try {\n                             PendingIntent alarmPendingIntent = PendingIntent.getService(((g.c) this).a, g.c(((g.c) this).c).c().hashCode(), cancelIntent, 134217728);\n                             if (alarmManager != null) {\n                                 alarmManager.cancel(alarmPendingIntent);\n                             }\n                             Intent alarmIntent = new Intent(\"com.clevertap.BG_EVENT\");\n                             alarmIntent.setPackage(((g.c) this).a.getPackageName());\n                             PendingIntent alarmServicePendingIntent = PendingIntent.getService(((g.c) this).a, g.c(((g.c) this).c).c().hashCode(), alarmIntent, 134217728);\n                             if (alarmManager != null && pingFrequency != -1) {\n                                 alarmManager.setInexactRepeating(2, SystemClock.elapsedRealtime() + (pingFrequency * 60000), pingFrequency * 60000, alarmServicePendingIntent);\n                                 return null;\n                             }\n                             return null;\n                         } catch (JSONException e) {\n                             c0.n(\"Unable to raise background Ping event\");\n                             return null;\n                         }\n                     }\n                     return null;\n                 } catch (JSONException e2) {\n                 }\n             } else {\n                 return null;\n             }\n         } else {\n             c0.o(g.c(((g.c) this).c).c(), \"Job Service won't run in default DND hours\");\n             return null;\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/c/a/a/u0/g$c.java",
              "file_line": [
                287
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.003-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "41e71b10-52cb-4cef-ac73-e0165f40ca3f",
              "value": "public final Intent a(Context context, String message) {\n         q.f(context, \"context\");\n         Intent shareIntent = new Intent(\"android.intent.action.SEND\");\n         try {\n             shareIntent.setType(\"text/plain\");\n             shareIntent.putExtra(\"android.intent.extra.TEXT\", message);\n             Intent createChooser = Intent.createChooser(shareIntent, context.getString(2131952509));\n             q.e(createChooser, \"{\\n                shareI…share_btn))\\n            }\");\n             return createChooser;\n         } catch (ActivityNotFoundException exception) {\n             a.k(exception, \"Unable to resolve share intent\", new Object[0]);\n             return shareIntent;\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/f/d/a/e/h/e0$a.java",
              "file_line": [
                51
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.242-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c0e6a00b-a6c8-4604-8bd6-a9a349bccdf1",
              "value": "private static void initializeIfNotInitialized() {\n         if (InAppPurchaseActivityLifecycleTracker.hasBillingService != null) {\n             return;\n         }\n         try {\n             Class.forName(\"com.android.vending.billing.IInAppBillingService$Stub\");\n             InAppPurchaseActivityLifecycleTracker.hasBillingService = true;\n             try {\n                 Class.forName(\"com.android.billingclient.api.ProxyBillingActivity\");\n                 InAppPurchaseActivityLifecycleTracker.hasBiillingActivity = true;\n             } catch (ClassNotFoundException e) {\n                 InAppPurchaseActivityLifecycleTracker.hasBiillingActivity = false;\n             }\n             InAppPurchaseEventManager.clearSkuDetailsCache();\n             InAppPurchaseActivityLifecycleTracker.intent = new Intent(\"com.android.vending.billing.InAppBillingService.BIND\").setPackage(\"com.android.vending\");\n             InAppPurchaseActivityLifecycleTracker.serviceConnection = new InAppPurchaseActivityLifecycleTracker.1();\n             InAppPurchaseActivityLifecycleTracker.callbacks = new InAppPurchaseActivityLifecycleTracker.2();\n         } catch (ClassNotFoundException e2) {\n             InAppPurchaseActivityLifecycleTracker.hasBillingService = false;\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/appevents/internal/InAppPurchaseActivityLifecycleTracker.java",
              "file_line": [
                184
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.348-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "cdb200bf-8ff4-467f-a734-ff6f35428f86",
              "value": "public final void zac() {\n         Intent intent = new Intent(\"com.google.android.gms.common.images.LOAD_IMAGE\");\n         intent.setPackage(\"com.google.android.gms\");\n         intent.putExtra(\"com.google.android.gms.extras.uri\", ((ImageManager.ImageReceiver) this).zab);\n         intent.putExtra(\"com.google.android.gms.extras.resultReceiver\", (Parcelable) this);\n         intent.putExtra(\"com.google.android.gms.extras.priority\", 3);\n         ImageManager.zac(((ImageManager.ImageReceiver) this).zaa).sendBroadcast(intent);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/common/images/ImageManager$ImageReceiver.java",
              "file_line": [
                147
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.534-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9e82ddce-37d1-4edd-a388-a7d62f2a366e",
              "value": "private static Intent createTargetIntent(String str, NotificationParams notificationParams, PackageManager packageManager) {\n         String string = notificationParams.getString(\"gcm.n.click_action\");\n         if (!TextUtils.isEmpty(string)) {\n             Intent intent = new Intent(string);\n             intent.setPackage(str);\n             intent.setFlags(268435456);\n             return intent;\n         }\n         Uri link = notificationParams.getLink();\n         if (link != null) {\n             Intent intent2 = new Intent(\"android.intent.action.VIEW\");\n             intent2.setPackage(str);\n             intent2.setData(link);\n             return intent2;\n         }\n         Intent launchIntentForPackage = packageManager.getLaunchIntentForPackage(str);\n         if (launchIntentForPackage == null) {\n             Log.w(\"FirebaseMessaging\", \"No activity found to launch app\");\n         }\n         return launchIntentForPackage;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/firebase/messaging/CommonNotificationBuilder.java",
              "file_line": [
                615
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.659-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "965a6dec-ec40-4328-932c-f56e99b685b8",
              "value": "public void finish() {\n         super.finish();\n         Intent broadcastIntent = new Intent(\"responseEvent\");\n         broadcastIntent.putExtra(\"sdkResp\", (Serializable) ((CreditCardResponseActivity) this).sdkResponse);\n         LocalBroadcastManager.getInstance(this).sendBroadcast(broadcastIntent);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/payfort/fort/android/sdk/activities/CreditCardResponseActivity.java",
              "file_line": [
                321
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.728-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "02db5dd8-46c3-4d2f-b165-d8a039296d75",
              "value": "public static final void b(View $this$share, String content) {\n         q.g($this$share, \"$this$share\");\n         q.g(content, \"content\");\n         Intent intent = new Intent(\"android.intent.action.SEND\");\n         intent.setType(\"text/plain\");\n         intent.putExtra(\"android.intent.extra.TEXT\", content);\n         b.b($this$share).startActivity(Intent.createChooser(intent, $this$share.getResources().getString(R.string.leak_canary_share_with)));\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/a.java",
              "file_line": [
                36
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.877-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1f4aea96-78c0-4194-880f-724a5e6bcc34",
              "value": "public void onActivityResult(int requestCode, int resultCode, Intent data) {\n         super.onActivityResult(requestCode, resultCode, data);\n         if (resultCode == 0) {\n             Intent broadcast = new Intent(CustomTabActivity.CUSTOM_TAB_REDIRECT_ACTION);\n             broadcast.putExtra(CustomTabMainActivity.EXTRA_URL, getIntent().getDataString());\n             LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);\n             ((CustomTabActivity) this).closeReceiver = new CustomTabActivity.1(this);\n             LocalBroadcastManager.getInstance(this).registerReceiver(((CustomTabActivity) this).closeReceiver, new IntentFilter(CustomTabActivity.DESTROY_ACTION));\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/CustomTabActivity.java",
              "file_line": [
                102
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.273-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f9270711-9060-4c3d-a7e4-d8be7b28924f",
              "value": "private static void shareToMessenger20150314(Activity activity, int requestCode, ShareToMessengerParams shareToMessengerParams) {\n         try {\n             Intent shareIntent = new Intent(\"android.intent.action.SEND\");\n             shareIntent.setFlags(1);\n             shareIntent.setPackage(\"com.facebook.orca\");\n             shareIntent.putExtra(\"android.intent.extra.STREAM\", shareToMessengerParams.uri);\n             shareIntent.setType(shareToMessengerParams.mimeType);\n             String appId = FacebookSdk.getApplicationId();\n             if (appId != null) {\n                 shareIntent.putExtra(\"com.facebook.orca.extra.PROTOCOL_VERSION\", 20150314);\n                 shareIntent.putExtra(\"com.facebook.orca.extra.APPLICATION_ID\", appId);\n                 shareIntent.putExtra(\"com.facebook.orca.extra.METADATA\", shareToMessengerParams.metaData);\n                 shareIntent.putExtra(\"com.facebook.orca.extra.EXTERNAL_URI\", shareToMessengerParams.externalUri);\n             }\n             activity.startActivityForResult(shareIntent, requestCode);\n         } catch (ActivityNotFoundException e) {\n             Intent openMessenger = activity.getPackageManager().getLaunchIntentForPackage(\"com.facebook.orca\");\n             activity.startActivity(openMessenger);\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/messenger/MessengerUtils.java",
              "file_line": [
                640
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.481-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "697a431d-e497-48dc-9304-aa5d19a0afe2",
              "value": "public static Intent zza(String str) {\n         Uri fromParts = Uri.fromParts(\"package\", \"com.google.android.gms\", null);\n         Intent intent = new Intent(\"android.settings.APPLICATION_DETAILS_SETTINGS\");\n         intent.setData(fromParts);\n         return intent;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/android/gms/common/internal/zzs.java",
              "file_line": [
                70
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.601-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "888fff20-c3a9-4d72-b321-decb269b970e",
              "value": "public static ResolveInfo getAppInfoForFile(Context context, String fileName) {\n         PackageManager pm = context.getPackageManager();\n         MediaResult file = a.c(context).d(\"tmp\", fileName);\n         if (file == null) {\n             return null;\n         }\n         Intent intent = new Intent(\"android.intent.action.VIEW\");\n         intent.setData(file.j());\n         List<ResolveInfo> matchingApps = pm.queryIntentActivities(intent, 65536);\n         if (f.q.d.a.g(matchingApps)) {\n             return null;\n         }\n         return matchingApps.get(0);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/zendesk/support/request/UtilsAttachment.java",
              "file_line": [
                188
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.710-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3023ca7d-cd7d-47db-aa47-2845406fbacf",
              "value": "public static final void f(View $this$startShareIntentChooser, Uri uri) {\n         Intent intent = new Intent(\"android.intent.action.SEND\");\n         intent.setType(\"application/octet-stream\");\n         intent.putExtra(\"android.intent.extra.STREAM\", uri);\n         b.b($this$startShareIntentChooser).startActivity(Intent.createChooser(intent, $this$startShareIntentChooser.getResources().getString(R.string.leak_canary_share_with)));\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/a.java",
              "file_line": [
                383
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.896-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "02db881c-860c-48f3-9d72-8a79ec01f255",
              "value": "private void invokeOnTokenRefresh(String str) {\n         if (\"[DEFAULT]\".equals(((FirebaseMessaging) this).firebaseApp.getName())) {\n             if (Log.isLoggable(\"FirebaseMessaging\", 3)) {\n                 String valueOf = String.valueOf(((FirebaseMessaging) this).firebaseApp.getName());\n                 Log.d(\"FirebaseMessaging\", valueOf.length() != 0 ? \"Invoking onNewToken for app: \".concat(valueOf) : new String(\"Invoking onNewToken for app: \"));\n             }\n             Intent intent = new Intent(\"com.google.firebase.messaging.NEW_TOKEN\");\n             intent.putExtra(\"token\", str);\n             new FcmBroadcastProcessor(((FirebaseMessaging) this).context).process(intent);\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/google/firebase/messaging/FirebaseMessaging.java",
              "file_line": [
                668
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.676-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "fff6c881-c421-44a4-910b-71d02af5ac07",
              "value": "public void onActionClicked(c snackbar) {\n         ((CommonServiceUtil.1) this).val$activity.startActivity(new Intent(\"android.net.wifi.PICK_WIFI_NETWORK\"));\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/payfort/fort/android/sdk/activities/services/CommonServiceUtil$1.java",
              "file_line": [
                49
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.747-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "daef6cc5-0279-496b-997a-0f61a6a6e507",
              "value": "public void onClick(DialogInterface dialog, int which) {\n         LocalBroadcastManager.getInstance(((CreditPaymentService.1) this).val$activity).sendBroadcast(new Intent(\"responseEvent\"));\n         dialog.dismiss();\n         ((CreditPaymentService.1) this).val$activity.finish();\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/com/payfort/fort/android/sdk/activities/services/CreditPaymentService$1.java",
              "file_line": [
                59
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.814-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "89885eea-a387-4cb7-906a-d33fb3405e29",
              "value": "public final void a(View $this$updateUi) {\n         q.g($this$updateUi, \"$receiver\");\n         Intent intent = new Intent(\"android.intent.action.SEND\");\n         intent.setType(\"image/png\");\n         intent.putExtra(\"android.intent.extra.STREAM\", ((o.c.a.a.a) this).a);\n         b.b($this$updateUi).startActivity(Intent.createChooser(intent, $this$updateUi.getResources().getString(R.string.leak_canary_share_heap_dump_bitmap_screen_title)));\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/l/r/g0/c/o$c$a$a$a.java",
              "file_line": [
                62
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.913-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7f5358bc-25ec-4ba5-8ed2-b107d37685d9",
              "value": "public ClsXUX619PG4WWP3JH(Context context, Uri uri) {\n         ((BrowserActionsIntent.Builder) this).mIntent = new Intent(\"androidx.browser.browseractions.browser_action_open\");\n         ((BrowserActionsIntent.Builder) this).mMenuItems = null;\n         ((BrowserActionsIntent.Builder) this).mOnItemSelectedPendingIntent = null;\n         ((BrowserActionsIntent.Builder) this).mContext = context;\n         ((BrowserActionsIntent.Builder) this).mUri = uri;\n         ((BrowserActionsIntent.Builder) this).mType = 0;\n         ((BrowserActionsIntent.Builder) this).mMenuItems = new ArrayList();\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/browser/browseractions/BrowserActionsIntent$Builder.java",
              "file_line": [
                53
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.032-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7da9fbc9-3632-4fff-838f-4e320b776888",
              "value": "public final void s() {\n         Intent requestFileIntent = new Intent(\"android.intent.action.GET_CONTENT\");\n         requestFileIntent.setType(\"*/*\");\n         requestFileIntent.addCategory(\"android.intent.category.OPENABLE\");\n         Intent chooserIntent = Intent.createChooser(requestFileIntent, getResources().getString(R.string.leak_canary_import_from_title));\n         startActivityForResult(chooserIntent, 0);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/leakcanary/internal/activity/LeakActivity.java",
              "file_line": [
                1091
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.931-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d53ce08a-7c0d-4616-81f4-82ca15e68032",
              "value": "public final ResolveInfo h(String fileName, Context context) {\n         PackageManager pm = context.getPackageManager();\n         MediaResult file = a.c(context).d(\"tmp\", fileName);\n         if (file == null) {\n             return null;\n         }\n         Intent intent = new Intent(\"android.intent.action.VIEW\");\n         intent.setData(file.j());\n         List<ResolveInfo> matchingApps = pm.queryIntentActivities(intent, 65536);\n         if (matchingApps == null || matchingApps.size() <= 0) {\n             return null;\n         }\n         return matchingApps.get(0);\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/s/a/g$d.java",
              "file_line": [
                272
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.947-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f0ebb7ff-5f87-4ccc-9ddd-204063d31cbe",
              "value": "public ClsJN9JMKFCUM4G0VS(Context context, String tag, ComponentName mbrComponent, PendingIntent mbrIntent, Bundle token2Bundle) {\n         new ArrayList();\n         if (context == null) {\n             throw new IllegalArgumentException(\"context must not be null\");\n         }\n         if (TextUtils.isEmpty(tag)) {\n             throw new IllegalArgumentException(\"tag must not be null or empty\");\n         }\n         if (mbrComponent == null && (mbrComponent = MediaButtonReceiver.getMediaButtonReceiverComponent(context)) == null) {\n             Log.w(\"MediaSessionCompat\", \"Couldn't find a unique registered media button receiver in the given context.\");\n         }\n         if (mbrComponent != null && mbrIntent == null) {\n             Intent mediaButtonIntent = new Intent(\"android.intent.action.MEDIA_BUTTON\");\n             mediaButtonIntent.setComponent(mbrComponent);\n             mbrIntent = PendingIntent.getBroadcast(context, 0, mediaButtonIntent, 0);\n         }\n         if (Build.VERSION.SDK_INT >= 28) {\n             MediaSessionCompat.f fVar = new MediaSessionCompat.f(context, tag, token2Bundle);\n             ((MediaSessionCompat) this).b = fVar;\n             e(new MediaSessionCompat.a(this));\n             fVar.d(mbrIntent);\n         } else {\n             MediaSessionCompat.e eVar = new MediaSessionCompat.e(context, tag, token2Bundle);\n             ((MediaSessionCompat) this).b = eVar;\n             e(new MediaSessionCompat.b(this));\n             eVar.d(mbrIntent);\n         }\n         ((MediaSessionCompat) this).c = new MediaControllerCompat(context, this);\n         if (MediaSessionCompat.a == 0) {\n             MediaSessionCompat.a = (int) (TypedValue.applyDimension(1, 320.0f, context.getResources().getDisplayMetrics()) + 0.5f);\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaSessionCompat.java",
              "file_line": [
                126
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.002-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "58658cd1-f0bf-40c5-a96e-d2ec947a304f",
              "value": "public static Drawable getAppIconForFile(Context context, String fileName, Drawable defaultDrawable) {\n         PackageManager pm = context.getPackageManager();\n         MediaResult file = a.c(context).d(\"tmp\", fileName);\n         if (file == null) {\n             return null;\n         }\n         Intent intent = new Intent(\"android.intent.action.VIEW\");\n         intent.setData(file.j());\n         List<ResolveInfo> matchingApps = pm.queryIntentActivities(intent, 65536);\n         if (!f.q.d.a.g(matchingApps)) {\n             return UtilsAttachment.getAppIcon(context, matchingApps.get(0));\n         }\n         return defaultDrawable;\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/zendesk/messaging/ui/UtilsAttachment.java",
              "file_line": [
                134
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.962-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "95df3109-3f62-4df6-8ddc-cc6ca5b9e623",
              "value": "public static void openAttachment(View view, String filePath) {\n         Context context = view.getContext();\n         Uri fileUrl = Uri.parse(filePath);\n         String contentType = UtilsAttachment.getMimeTypeForFile(filePath);\n         Intent intent = new Intent(\"android.intent.action.VIEW\");\n         intent.setDataAndType(fileUrl, contentType);\n         if (intent.resolveActivity(context.getPackageManager()) != null) {\n             context.startActivity(intent);\n             return;\n         }\n         intent.setData(fileUrl);\n         if (intent.resolveActivity(context.getPackageManager()) != null) {\n             context.startActivity(intent);\n             return;\n         }\n         a.e(\"AttachmentUtils\", \"Unable to open attachment. No app found that can receive the implicit intent\", new Object[0]);\n         Snackbar.make(view, R.string.zui_unable_open_file, -1).show();\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes3/zendesk/messaging/ui/UtilsAttachment.java",
              "file_line": [
                226
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:06.980-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b06759f3-1dec-4065-951f-ebc4665d8c51",
              "value": "public GraphResponse get() {\n         String uniqueID = UUID.randomUUID().toString();\n         try {\n             DaemonRequest.access$100(((DaemonRequest.2) this).this$0).put(\"requestID\", uniqueID);\n             Intent intent = new Intent();\n             String functionType = DaemonRequest.access$100(((DaemonRequest.2) this).this$0).getString(\"type\");\n             DaemonRequest.access$200(((DaemonRequest.2) this).this$0).logPreparingRequest(functionType, uniqueID, DaemonRequest.access$100(((DaemonRequest.2) this).this$0));\n             if (!functionType.equals(SDKMessageEnum.GET_ACCESS_TOKEN.toString()) && !functionType.equals(SDKMessageEnum.IS_ENV_READY.toString())) {\n                 SharedPreferences sharedPreferences = DaemonRequest.access$300(((DaemonRequest.2) this).this$0).getSharedPreferences(\"com.facebook.gamingservices.cloudgaming:preferences\", 0);\n                 String daemonPackageName = sharedPreferences.getString(\"daemonPackageName\", null);\n                 if (daemonPackageName == null) {\n                     FacebookRequestError error = new FacebookRequestError(-1, \"DAEMON_REQUEST_EXECUTE_ASYNC_FAILED\", \"Unable to correctly create the request with a secure connection\");\n                     return DaemonReceiver.createErrorResponse(error, uniqueID);\n                 }\n                 intent.setPackage(daemonPackageName);\n             }\n             intent.setAction(\"com.facebook.gamingservices.DAEMON_REQUEST\");\n             Iterator iter = DaemonRequest.access$100(((DaemonRequest.2) this).this$0).keys();\n             while (iter.hasNext()) {\n                 String key = iter.next();\n                 String value = DaemonRequest.access$100(((DaemonRequest.2) this).this$0).getString(key);\n                 intent.putExtra(key, value);\n             }\n             DaemonRequest.access$300(((DaemonRequest.2) this).this$0).sendBroadcast(intent);\n             DaemonRequest.access$200(((DaemonRequest.2) this).this$0).logSentRequest(functionType, uniqueID, DaemonRequest.access$100(((DaemonRequest.2) this).this$0));\n             CompletableFuture<GraphResponse> future = new CompletableFuture<>();\n             DaemonRequest.access$400(((DaemonRequest.2) this).this$0).put(uniqueID, future);\n             return future.get();\n         } catch (InterruptedException | ExecutionException | JSONException e) {\n             FacebookRequestError error2 = new FacebookRequestError(-1, \"DAEMON_REQUEST_EXECUTE_ASYNC_FAILED\", \"Unable to correctly create the request or obtain response\");\n             return DaemonReceiver.createErrorResponse(error2, uniqueID);\n         }\n     }",
              "vulnerability_id": "e09f3d02-871f-4b55-9b40-694f5492be61",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/gamingservices/cloudgaming/DaemonRequest$2.java",
              "file_line": [
                255
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.091-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "7082ea14-d3c8-49b3-9eb5-293287f9132e",
          "title": "Firebase Database Detect",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team discovered a potential security concern in the Firebase Database implementation within the <b>Fake App</b> application. Firebase Database, a real-time NoSQL cloud database offered by Google, enables developers to store and sync data across users and devices. However, if Firebase Database is not securely implemented, it could expose the application to various security vulnerabilities.</p>\n<p>The code snippet below demonstrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends securing the Firebase Database implementation with several key measures:</p>\n<p>Strong Authentication: Implement strong authentication mechanisms to control access to the database effectively.</p>\n<p>Input Validation: Rigorously validate all inputs to prevent injection attacks or unauthorized data manipulation.</p>\n<p>Access Controls: Establish strict access controls to regulate who can access or modify the database.</p>\n<p>Data Encryption: Employ data encryption to protect sensitive information both in transit and at rest.</p>\n<p>Robust Error Handling: Implement robust error handling to prevent leakage of sensitive information through error messages.</p>\n<p>Regular Security Audits: Conduct regular security audits of the database to identify and address potential vulnerabilities.</p>\n<p>Update Firebase SDK Regularly: Keep the Firebase SDK updated to ensure you have the latest security patches and enhancements.</p>\n<p>Implementing these measures will enhance the security of the Firebase Database, safeguard user data, and maintain the integrity of the application.</p>\n",
              "impact": "<p>If the Firebase Database implementation is not adequately secured, it can become vulnerable to exploitation by attackers. They may perform unauthorized data access, manipulation, or deletion. As a result, sensitive user information or critical application data could be exposed, potentially leading to significant data breaches or unauthorized actions. Such vulnerabilities pose a substantial threat to user privacy and the integrity of the application.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió una posible preocupación de seguridad en la implementación de Firebase Database dentro de la aplicación <b>Fake App</b>. Firebase Database, una base de datos en la nube NoSQL en tiempo real ofrecida por Google, permite a los desarrolladores almacenar y sincronizar datos entre usuarios y dispositivos. Sin embargo, si Firebase Database no se implementa de manera segura, podría exponer la aplicación a varias vulnerabilidades de seguridad.</p>\n<p>El fragmento de código a continuación muestra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda asegurar la implementación de Firebase Database con varias medidas clave:</p>\n<p>Autenticación Robusta: Implementar mecanismos de autenticación fuertes para controlar el acceso a la base de datos de manera efectiva.</p>\n<p>Validación de Entradas: Validar rigurosamente todas las entradas para prevenir ataques de inyección o manipulación no autorizada de datos.</p>\n<p>Controles de Acceso: Establecer controles de acceso estrictos para regular quién puede acceder o modificar la base de datos.</p>\n<p>Encriptación de Datos: Emplear encriptación de datos para proteger la información sensible tanto en tránsito como en reposo.</p>\n<p>Manejo de Errores Robusto: Implementar un manejo de errores robusto para evitar la filtración de información sensible a través de mensajes de error.</p>\n<p>Auditorías de Seguridad Regulares: Realizar auditorías de seguridad regulares de la base de datos para identificar y abordar posibles vulnerabilidades.</p>\n<p>Actualizar Regularmente el SDK de Firebase: Mantener actualizado el SDK de Firebase para asegurar las últimas mejoras y parches de seguridad.</p>\n<p>La implementación de estas medidas mejorará la seguridad de Firebase Database, protegerá los datos de los usuarios y mantendrá la integridad de la aplicación.</p>\n",
              "impact": "<p>Si la implementación de Firebase Database no está adecuadamente asegurada, puede volverse vulnerable a la explotación por parte de atacantes. Ellos podrían realizar acceso, manipulación o eliminación de datos no autorizados. Como resultado, la información sensible de los usuarios o datos críticos de la aplicación podrían quedar expuestos, lo que podría conducir a violaciones de datos significativas o acciones no autorizadas. Tales vulnerabilidades representan una amenaza sustancial para la privacidad del usuario y la integridad de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Best practices for Cloud Firestore  |  Firebase",
              "url": "https://firebase.google.com/docs/firestore/best-practices"
            },
            {
              "label": "Firebase security checklist",
              "url": "https://firebase.google.com/support/guides/security-checklist"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-AUTH-1",
            "maswe": "MASWE-0005"
          },
          "evidences": [
            {
              "id": "65dd2d81-8b76-4dfa-8a7b-6707c4098824",
              "value": "<string name=\"filters_count\">(%s)</string>\n    <string name=\"finish\">Finish</string>\n    <string name=\"firebase_database_url\">https://fake-bef7e.firebaseio.com</string>\n    <string name=\"floor\">Floor</string>\n    <string name=\"floorMissing\">Floor missing</string>",
              "vulnerability_id": "7082ea14-d3c8-49b3-9eb5-293287f9132e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/res/values/strings.xml",
              "file_line": [
                467
              ],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T21:09:10.557-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "216ab218-5ca3-4270-9e19-df7705593083",
          "title": "Webview addJavascript Interface Usage",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team identified a vulnerability in the <b>Fake App</b> application involving the use of the <b>addJavascriptInterface</b> method within a WebView. This method exposes Java objects to JavaScript, presenting significant security risks if the WebView loads content from untrusted sources. The exposed interface can potentially allow malicious JavaScript to invoke Java methods, leading to arbitrary code execution within the application. This issue is particularly critical in applications targeting Android API levels below 17, where the interface is more susceptible to abuse via reflection techniques.</p>\n<p>The following code snippet shows the insecure implementation:</p>\n",
              "remediation": "<p>The assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Target API Level 17 or Higher: Ensure the application targets at least Android API level 17, which introduces enhanced security features that restrict JavaScript access to the Java Reflection API, mitigating the risk of arbitrary code execution.\n</li>\n<li>Validate WebView Content: Implement stringent validation of all content loaded into WebViews. Only load content from trusted sources, and avoid dynamically loading JavaScript from unknown or unverified sources.\n</li>\n<li>Use WebView Safely: If <b>addJavascriptInterface</b> must be used, ensure it is done in a context that does not compromise security. Carefully consider what functionalities are exposed to JavaScript and restrict access to essential methods only.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit this vulnerability by executing arbitrary Java code through JavaScript within the application&#39;s WebView. This risk is particularly severe in applications targeting Android API levels below 17, as these versions do not adequately restrict JavaScript&#39;s access to the Java Reflection API. The potential for unauthorized actions includes data theft, session hijacking, and the injection of malicious content, significantly compromising the application&#39;s integrity and user data security.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó una vulnerabilidad en la aplicación <b>Fake App</b> relacionada con el uso del método <b>addJavascriptInterface</b> en un visor web. Este método expone a los objetos de Java a JavaScript y supone importantes riesgos de seguridad si el visor web carga contenido de fuentes no confiables. La interfaz expuesta podría permitir que un JavaScript malintencionado invoque métodos de Java y que se ejecute código arbitrario en la aplicación. Este problema es particularmente grave en las aplicación que utilizan niveles de API de Android inferiores a 17, en los que la interfaz es más susceptible a ser vulnerada con técnicas de reflexión.</p>\n<p>El siguiente fragmento de código muestras la implementación insegura:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Utilizar nivel de API 17 o posterior: asegúrese de que la aplicación utiliza, por lo menos, una API de Android de nivel 17. Esta versión introduce funciones de seguridad mejoradas que restringen el acceso de JavaScript a la API de Java Reflection y mitigan el riesgo de ejecución de código arbitrario.\n</li>\n<li>Validar el contenido del visor web: implemente una validación estricta de todo el contenido que se carga en los visores web. Solo cargue contenido de fuentes confiables y evite cargar JavaScript de manera dinámica desde fuentes desconocidas o no verificadas.\n</li>\n<li>Utilizar el visor web de manera segura: si debe utilizar <b>addJavascriptInterface</b>, asegúrese de hacerlo en un contexto que no ponga en riesgo la seguridad. Considere cuidadosamente qué funciones se exponen a JavaScript y limite el acceso a los métodos esenciales.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría explotar esta vulnerabilidad para ejecutar código arbitrario de Java a través de JavaScript en el visor web de la aplicación. Esto es muy grave en las aplicaciones que utilizan niveles de API de Android inferiores a 17, ya que estas versiones no restringen adecuadamente el acceso de JavaScript a la API de Java Reflection. Las posibles acciones no autorizadas incluyen robo de datos, secuestro de sesión y la inyección de contenido malintencionado. Esto comprometería seriamente la integrad de la aplicación y la seguridad de los datos de los usuarios.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Testing for Java Objects Exposed Through WebViews | OWASP Mobile Application Security",
              "url": "https://mas.owasp.org/MASTG/tests/android/MASVS-PLATFORM/MASTG-TEST-0033/"
            },
            {
              "label": "Testing Platform Interaction | OWASP MSTG",
              "url": "https://github.com/Expertasif/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md"
            },
            {
              "label": "Security Control Verification Requirements | OWASP MASVS",
              "url": "https://mas.owasp.org/MASWE/MASVS-PLATFORM/MASWE-0068/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-2",
            "maswe": "MASWE-0068"
          },
          "evidences": [
            {
              "id": "1cc82715-341c-4ebe-b241-dce9db88cf72",
              "value": "public static void augmentWebView(WebView webView, Context context) {\n         String[] parts = Build.VERSION.RELEASE.split(\"\\\\.\");\n         int majorRelease = parts.length > 0 ? Integer.parseInt(parts[0]) : 0;\n         int minorRelease = parts.length > 1 ? Integer.parseInt(parts[1]) : 0;\n         if (majorRelease < 4 || (majorRelease == 4 && minorRelease <= 1)) {\n             Logger.log(LoggingBehavior.DEVELOPER_ERRORS, AppEventsLoggerImpl.TAG, \"augmentWebView is only available for Android SDK version >= 17 on devices running Android >= 4.2\");\n             return;\n         }\n         FacebookSDKJSInterface facebookSDKJSInterface = new FacebookSDKJSInterface(context);\n         webView.addJavascriptInterface(facebookSDKJSInterface, \"fbmq_\" + FacebookSdk.getApplicationId());\n     }",
              "vulnerability_id": "216ab218-5ca3-4270-9e19-df7705593083",
              "vulnerability_evidence_types_id": 1,
              "file_path": "_classes2/com/facebook/appevents/AppEventsLoggerImpl.java",
              "file_line": [
                317
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T21:09:07.195-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        }
      ],
      "severityDistribution": {
        "high": 40,
        "info": 20,
        "medium": 30,
        "low": 10
      },
      "severityCount": {
        "high": 8,
        "medium": 6,
        "info": 4,
        "low": 2
      },
      "properties": {
        "MIN_SDK": 21,
        "MD5": "d4b4f21083c809d414f078155bf2d7a1",
        "SHA1": "8b8aba9b66b5f9a2caa7c9de57d5e283de450a46",
        "SHA256": "5cc88fb428ddff7323bf89355f9992d543e67334f2678f079c9ee86dd87755f7",
        "VERSION": "3.20.0-BETA",
        "ANDROID_VERSION_CODE": "3.20.0-BETA",
        "FRAMEWORK": "Native (Java / Kotlin)",
        "MAIN_ACTIVITY": "com.fake.app.beta.screens.mainscreens.single.SingleFakeAppActivity",
        "BINARY_PROTECTIONS": null
      },
      "permissions": [
        "android.permission.ACCESS_COARSE_LOCATION",
        "android.permission.ACCESS_FINE_LOCATION",
        "android.permission.INTERNET",
        "android.permission.ACCESS_WIFI_STATE",
        "android.permission.WRITE_EXTERNAL_STORAGE",
        "android.permission.CAMERA",
        "android.permission.READ_PHONE_STATE",
        "android.permission.ACCESS_NETWORK_STATE",
        "android.permission.READ_CONTACTS",
        "android.permission.WAKE_LOCK",
        "android.permission.READ_EXTERNAL_STORAGE",
        "com.google.android.finsky.permission.BIND_GET_INSTALL_REFERRER_SERVICE",
        "android.permission.VIBRATE",
        "com.google.android.c2dm.permission.RECEIVE",
        "android.permission.FOREGROUND_SERVICE"
      ],
      "components": [
        {
          "name": "com.fake.app.screens.mainscreens.Wallet.WalletPayment.AddFundsActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": true
        },
        {
          "name": "com.paymob.acceptsdk.PayActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.paymob.acceptsdk.ThreeDSecureWebViewActivty",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.screens.mainscreens.single.SingleFakeAppActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": true
        },
        {
          "name": "com.facebook.FacebookActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.facebook.CustomTabActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": true
        },
        {
          "name": "com.fake.app.screens.debug.DebugAppConfigActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.payfort.fort.android.sdk.activities.InitSecureConnectionActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.payfort.fort.android.sdk.activities.CreditCardPaymentActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.payfort.fort.android.sdk.activities.CreditCardResponseActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.home.screens.debug.DebugBaseOffersActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.pay.screens.debug.DebugMobileRechargeActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.pay.screens.p2p.debug.P2pDebugActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.pay.screens.serviceproviders.debug.ServiceProvidersDebugActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.wallet.screens.debug.DebugWalletActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.onboarding.screens.debug.DebugOnboardingActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "zendesk.messaging.MessagingActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "zendesk.answerbot.AnswerBotArticleActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.search.screens.debug.DebugSearchActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.offers.screens.merchants.debug.DebugOffersActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.navigation.components.onboarding.debug.EducationalOnboardingDebugActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.authentication.screens.plans.debug.DebugPlansActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.authentication.screens.AuthenticationActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.common.screens.RenderActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.common.components.complete.screens.debug.DebugCompleteActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.common.components.emptystate.screens.debug.DebugEmptyStateActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.basemodule.base.platform.result.TestResultActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.uikit.screens.UiKitActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.verygoodsecurity.vgscollect.app.FilePickerActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "zendesk.support.request.RequestActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "zendesk.support.guide.ViewArticleActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "zendesk.support.guide.HelpCenterActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "zendesk.support.requestlist.RequestListActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.gms.common.api.GoogleApiActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.clevertap.android.sdk.InAppNotificationActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.clevertap.android.sdk.inbox.CTInboxActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.facebook.CustomTabMainActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "io.card.payment.CardIOActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "io.card.payment.DataEntryActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "leakcanary.internal.activity.LeakActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "leakcanary.internal.RequestStoragePermissionActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.appsflyer.SingleInstallBroadcastReceiver",
          "type": "R",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.clevertap.android.sdk.pushnotification.CTPushNotificationReceiver",
          "type": "R",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "zendesk.support.DeepLinkingBroadcastReceiver",
          "type": "R",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.facebook.CurrentAccessTokenExpirationBroadcastReceiver",
          "type": "R",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.firebase.iid.FirebaseInstanceIdReceiver",
          "type": "R",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.gms.measurement.AppMeasurementReceiver",
          "type": "R",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.datatransport.runtime.scheduling.jobscheduling.AlarmManagerSchedulerBroadcastReceiver",
          "type": "R",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "leakcanary.internal.NotificationReceiver",
          "type": "R",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.clevertap.android.sdk.pushnotification.CTNotificationIntentService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.push.gms.GmsMessagingService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.push.hms.HmsMessagingService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.search.common.UpdateSearchFiltersIntentService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.fake.app.authentication.common.UpdateRefreshTokenIntentService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "leakcanary.internal.HeapAnalyzerService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.clevertap.android.sdk.pushnotification.amp.CTBackgroundIntentService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.clevertap.android.sdk.pushnotification.amp.CTBackgroundJobService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.firebase.components.ComponentDiscoveryService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.firebase.messaging.FirebaseMessagingService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.datatransport.runtime.backends.TransportBackendDiscovery",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.gms.measurement.AppMeasurementService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.gms.measurement.AppMeasurementJobService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.datatransport.runtime.scheduling.jobscheduling.JobInfoSchedulerService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "zendesk.support.SupportSdkStartupProvider",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.facebook.internal.FacebookInitProvider",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.firebase.perf.provider.FirebasePerfProvider",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.firebase.provider.FirebaseInitProvider",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "zendesk.belvedere.BelvedereFileProvider",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.squareup.picasso.PicassoProvider",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "androidx.lifecycle.ProcessLifecycleOwnerInitializer",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "leakcanary.internal.LeakCanaryFileProvider",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "leakcanary.internal.AppWatcherInstaller$MainProcess",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "leakcanary.internal.PlumberInstaller",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        }
      ],
      "protections": [
        {
          "type": "has_ssl_pinning",
          "name": "Certificate Pinning",
          "category": [
            "MASVS-NETWORK-1"
          ],
          "protectors": [
            {
              "name": "TrustedCertificate",
              "files": [
                "classes3.dex"
              ]
            },
            {
              "name": "X509Certificate",
              "files": [
                "classes3.dex"
              ]
            }
          ]
        },
        {
          "type": "anti_debug",
          "name": "Debug Detection",
          "category": [
            "MASVS-RESILIENCE-4"
          ],
          "protectors": [
            {
              "name": "Debug.isDebuggerConnected()",
              "files": [
                "classes2.dex",
                "classes3.dex"
              ]
            }
          ]
        },
        {
          "type": "anti_vm",
          "name": "Emulation Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": [
            {
              "name": "Build.FINGERPRINT",
              "files": [
                "classes.dex",
                "classes2.dex"
              ]
            },
            {
              "name": "Build.HARDWARE",
              "files": [
                "classes2.dex"
              ]
            },
            {
              "name": "Build.MANUFACTURER",
              "files": [
                "classes.dex",
                "classes2.dex",
                "classes3.dex"
              ]
            },
            {
              "name": "Build.MODEL",
              "files": [
                "classes.dex",
                "classes2.dex",
                "classes3.dex"
              ]
            },
            {
              "name": "Build.PRODUCT",
              "files": [
                "classes.dex",
                "classes2.dex",
                "classes3.dex"
              ]
            },
            {
              "name": "Build.TAGS",
              "files": [
                "classes2.dex"
              ]
            },
            {
              "name": "device ID",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "network operator name",
              "files": [
                "classes.dex",
                "classes2.dex"
              ]
            },
            {
              "name": "possible VM",
              "files": [
                "classes2.dex"
              ]
            },
            {
              "name": "ro.kernel.qemu",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "SIM operator",
              "files": [
                "classes2.dex"
              ]
            }
          ]
        },
        {
          "type": "anti_root",
          "name": "Root Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": [
            {
              "name": "Custom Rom",
              "files": [
                "classes2.dex"
              ]
            },
            {
              "name": "SU binary",
              "files": [
                "classes2.dex"
              ]
            },
            {
              "name": "SuperUser APK",
              "files": [
                "classes2.dex"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": 6,
      "status": "COMPLETED",
      "start_at": "2025-06-14T00:00:00.000-03:00",
      "end_at": "2025-06-15T23:59:59.999-03:00",
      "created_at": "2025-06-14T20:56:14.882-03:00",
      "updated_at": "2025-06-14T20:59:47.661-03:00",
      "platform": "ANDROID",
      "services": {
        "id": 0,
        "name": "Mobile Penetration Testing"
      },
      "assessment": {
        "status": "COMPLETED",
        "id": "803e0fe0-dafb-4d3f-ba97-97a2481845a6",
        "name": null,
        "company_id": 1,
        "company": {
          "id": 1,
          "name": "Just Mobile Security"
        }
      },
      "scans": [
        {
          "id": "492745cf-771c-4cc4-a698-7ef84d02aaee",
          "aat_version": "0.1.0-beta-2",
          "scan_status": "FINISHED",
          "created_at": "2025-06-14T20:56:16.373-03:00",
          "updated_at": "2025-06-14T20:59:47.645-03:00",
          "type": "SAST",
          "app_id": "73ba1643-a5d9-488f-9da8-8e6418d0fc3f",
          "assessment_service_id": 6,
          "app": {
            "id": "73ba1643-a5d9-488f-9da8-8e6418d0fc3f",
            "name": "project1",
            "description": "com.jms.project1",
            "created_at": "2025-06-14T20:56:16.365-03:00",
            "updated_at": "2025-06-14T20:56:37.053-03:00",
            "version": null,
            "icon": {
              "url": "http://storage.fakedomain.com/bucket-storage/assessments/803e0fe0-dafb-4d3f-ba97-97a2481845a6/service/6/icon.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T012947Z&X-Amz-Expires=600&X-Amz-Signature=850b870562f8fdfde6ec93e4d463cebbe6c25b41625c67190a98e4567cbfbafe&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
              "name": "assessments/803e0fe0-dafb-4d3f-ba97-97a2481845a6/service/6/icon.webp",
              "extname": "webp",
              "size": 2884,
              "mimeType": "image/webp"
            }
          }
        }
      ],
      "summary": {
        "appId": "73ba1643-a5d9-488f-9da8-8e6418d0fc3f",
        "name": "project1",
        "description": "com.jms.project1",
        "platform": "ANDROID",
        "version": "",
        "createdAt": "2025-06-14T20:56:16.373-03:00",
        "finishedAt": "2025-06-14T20:59:47.645-03:00",
        "statusId": 5,
        "status": "Incomplete",
        "duration": {
          "days": 0,
          "hours": 0,
          "minutes": 3,
          "seconds": 31,
          "milliseconds": 272,
          "human": "4 minutes"
        },
        "file": {
          "name": "assessments/803e0fe0-dafb-4d3f-ba97-97a2481845a6/service/6/android.apk",
          "size": "11.17 MB"
        },
        "icon": "http://storage.fakedomain.com/bucket-storage/assessments/803e0fe0-dafb-4d3f-ba97-97a2481845a6/service/6/icon.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T034141Z&X-Amz-Expires=600&X-Amz-Signature=a96cc4235a7c8dc6a0e7ede6428f1987f290cbb413b6a41775abec1f905df9a3&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
        "start_date": "2025-06-14T00:00:00.000-03:00",
        "end_date": "2025-06-15T23:59:59.999-03:00"
      },
      "vulnerabilities": [
        {
          "vulnerabilityId": "c554983f-482c-4671-a598-995ec73f5d8e",
          "title": "External Result Receiver",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The vulnerability known as &quot;External Result Receiver&quot; in Android involves a significant security risk where exported components improperly handle ResultReceiver objects passed via intents. This issue allows external entities to send intents with ResultReceiver objects to the <b>project1</b> application, which could then be manipulated to execute unintended actions or retrieve sensitive information. The core vulnerability arises from the application&#39;s exported components, which do not adequately validate or restrict the incoming ResultReceiver objects, potentially leading to unauthorized access or control over the application&#39;s internal states and functionalities. This vulnerability underscores the need for strict validation and limitation of exported components in handling intent-based communications. \nThe following code snippet shows the insecure implementation</p>\n",
              "remediation": "<p>The assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Restrict Component Exportation: Modify the application's manifest to ensure that components intended to receive ResultReceiver objects are not exported unless absolutely necessary. Use the android:exported=false attribute to prevent unintended external access.\n</li>\n<li>Implement Intent Validation: Enhance the validation process for incoming intents within the application. Verify any ResultReceiver received through intents to ensure it originates from a trusted source, and confirm that its usage aligns with secure and intended operational parameters.</li>\n</ul>\n",
              "impact": "<p>An attacker can exploit the &quot;External Result Receiver&quot; vulnerability to execute unintended actions within the application or access sensitive information by manipulating ResultReceiver objects sent via intents. This could lead to unauthorized actions being performed, such as altering application data or behavior, which might compromise the app’s functionality and user data security. The ability to intercept and modify these communications also raises concerns about the integrity and confidentiality of the data processed by the application, potentially leading to further security breaches within the system.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>La vulnerabilidad conocida como &quot;External Result Receiver&quot; en Android implica un riesgo de seguridad significativo, ya que los componentes importados controlan inadecuadamente los objetos ResultReceiver que se envían a través de las intenciones. Este problema permite que entidades externas envíen intenciones con objetos ResultReceiver a la aplicación <b>project1</b>, que luego podrían manipularse para llevar a cabo acciones no deseadas o recuperar información sensible. La vulnerabilidad surge de los componentes exportados de la aplicación, que no validan o limitan adecuadamente los objetos ResultReceiver entrantes. Esto podría facilitar el acceso no autorizado y la pérdida de control de los estados y funcionamientos internos de la aplicación. Esta vulnerabilidad resalta la necesidad de una validación y limitación estrictas de los componentes exportados en la comunicación basada en intenciones.\nEl siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Restringir la exportación de componentes: modifique el manifiesto de la aplicación para garantizar que los componentes destinados a recibir objetos ResultReceiver no se exporten a menos que sea absolutamente necesario. Utilice el atributo android:exported=false para evitar el acceso externo no deseado.\n</li>\n<li>Implementar la validación de intenciones: mejore el proceso de validación de intenciones entrantes dentro de la aplicación. Verifique cualquier ResultReceiver recibido a través de intenciones para asegurarse de que provenga de una fuente confiable y confirmar que su uso se alinea con los parámetros operativos seguros previstos.</li>\n</ul>\n",
              "impact": "<p>Un atacante puede aprovechar la vulnerabilidad &quot;External Result Receiver&quot; para llevar a cabo acciones no deseadas dentro de la aplicación o acceder a información sensible manipulando objetos ResultReceiver enviados mediante intenciones. Esto podría dar lugar a que se realicen acciones no autorizadas, como alterar los datos o el comportamiento de la aplicación, y podría comprometer la funcionalidad de la aplicación y la seguridad de los datos de los usuarios. La capacidad de interceptar y modificar estas comunicaciones pone en riesgo la integridad y confidencialidad de los datos procesados por la aplicación y puede generar más violaciones de seguridad dentro del sistema.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "ResultReceiver | Android Developers",
              "url": "https://developer.android.com/reference/android/os/ResultReceiver#send(int,%20android.os.Bundle)"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0084"
          },
          "evidences": [
            {
              "id": "95eae7bd-7084-4201-a1b3-aa7c0da0582f",
              "value": "public final Bitmap parseResult(int resultCode, Intent intent) {\n         Intent intent2 = resultCode == -1 ? intent : null;\n         if (intent2 != null) {\n             return (Bitmap) intent2.getParcelableExtra(\"data\");\n         }\n         return null;\n     }",
              "vulnerability_id": "c554983f-482c-4671-a598-995ec73f5d8e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$TakePicturePreview.java",
              "file_line": [
                197
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.423-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b02e613b-96dd-4165-82b0-30c9a61a4628",
              "value": "public Uri getStream(int index) {\n         if (((ShareCompat.IntentReader) this).mStreams == null && isMultipleShare()) {\n             ((ShareCompat.IntentReader) this).mStreams = ((ShareCompat.IntentReader) this).mIntent.getParcelableArrayListExtra(\"android.intent.extra.STREAM\");\n         }\n         if (((ShareCompat.IntentReader) this).mStreams != null) {\n             return (Uri) ((ShareCompat.IntentReader) this).mStreams.get(index);\n         }\n         if (index == 0) {\n             return (Uri) ((ShareCompat.IntentReader) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n         }\n         throw new IndexOutOfBoundsException(\"Stream items available: \" + getStreamCount() + \" index requested: \" + index);\n     }",
              "vulnerability_id": "c554983f-482c-4671-a598-995ec73f5d8e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat$IntentReader.java",
              "file_line": [
                606
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.449-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "81520df6-3e8c-4753-81f3-e1dad64b7459",
              "value": "public Uri getStream() {\n         return (Uri) ((ShareCompat.IntentReader) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n     }",
              "vulnerability_id": "c554983f-482c-4671-a598-995ec73f5d8e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat$IntentReader.java",
              "file_line": [
                547
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.435-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "62cbdebe-7211-433c-b48c-0f90b9c5c647",
              "value": "public static NetworkInfo getNetworkInfoFromBroadcast(ConnectivityManager cm, Intent intent) {\n         NetworkInfo info = (NetworkInfo) intent.getParcelableExtra(\"networkInfo\");\n         if (info != null) {\n             return cm.getNetworkInfo(info.getType());\n         }\n         return null;\n     }",
              "vulnerability_id": "c554983f-482c-4671-a598-995ec73f5d8e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/net/ConnectivityManagerCompat.java",
              "file_line": [
                42
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.485-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6805e76c-7406-499a-8932-67a6ae27da49",
              "value": "static ComponentName getCallingActivity(Intent intent) {\n         ComponentName result = (ComponentName) intent.getParcelableExtra(\"androidx.core.app.EXTRA_CALLING_ACTIVITY\");\n         if (result == null) {\n             return (ComponentName) intent.getParcelableExtra(\"android.support.v4.app.EXTRA_CALLING_ACTIVITY\");\n         }\n         return result;\n     }",
              "vulnerability_id": "c554983f-482c-4671-a598-995ec73f5d8e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat.java",
              "file_line": [
                221
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.471-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "34f44dc8-37d9-4a77-98db-61997c8d66ee",
              "value": "static boolean handlePerformPrivateCommand(String action, Bundle data, InputConnectionCompat.OnCommitContentListener onCommitContentListener) {\n         boolean interop;\n         String str;\n         String str2;\n         String str3;\n         String str4;\n         String str5;\n         String str6;\n         if (data == null) {\n             return false;\n         }\n         if (TextUtils.equals(\"androidx.core.view.inputmethod.InputConnectionCompat.COMMIT_CONTENT\", action)) {\n             interop = false;\n         } else if (!TextUtils.equals(\"android.support.v13.view.inputmethod.InputConnectionCompat.COMMIT_CONTENT\", action)) {\n             return false;\n         } else {\n             interop = true;\n         }\n         ResultReceiver resultReceiver = null;\n         boolean result = false;\n         if (interop) {\n             str = \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_RESULT_RECEIVER\";\n         } else {\n             str = \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_RESULT_RECEIVER\";\n         }\n         try {\n             resultReceiver = (ResultReceiver) data.getParcelable(str);\n             if (interop) {\n                 str2 = \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_URI\";\n             } else {\n                 str2 = \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_URI\";\n             }\n             Uri contentUri = (Uri) data.getParcelable(str2);\n             if (interop) {\n                 str3 = \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_DESCRIPTION\";\n             } else {\n                 str3 = \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_DESCRIPTION\";\n             }\n             ClipDescription description = (ClipDescription) data.getParcelable(str3);\n             if (interop) {\n                 str4 = \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_LINK_URI\";\n             } else {\n                 str4 = \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_LINK_URI\";\n             }\n             Uri linkUri = (Uri) data.getParcelable(str4);\n             if (interop) {\n                 str5 = \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_FLAGS\";\n             } else {\n                 str5 = \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_FLAGS\";\n             }\n             int flags = data.getInt(str5);\n             if (interop) {\n                 str6 = \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_OPTS\";\n             } else {\n                 str6 = \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_OPTS\";\n             }\n             Bundle opts = (Bundle) data.getParcelable(str6);\n             if (contentUri != null && description != null) {\n                 InputContentInfoCompat inputContentInfo = new InputContentInfoCompat(contentUri, description, linkUri);\n                 result = onCommitContentListener.onCommitContent(inputContentInfo, flags, opts);\n             }\n             if (resultReceiver != null) {\n                 resultReceiver.send(result ? 1 : 0, null);\n             }\n             return result;\n         } catch (Throwable th) {\n             if (resultReceiver != null) {\n                 resultReceiver.send(0, null);\n             }\n             throw th;\n         }\n     }",
              "vulnerability_id": "c554983f-482c-4671-a598-995ec73f5d8e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/view/inputmethod/InputConnectionCompat.java",
              "file_line": [
                389
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.499-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "ca3d8e30-a4dc-4883-b280-6ac8a23e8cf8",
          "title": "Memory Corruption",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>project1</b> utilizes native methods within its codebase. Native methods, often written in languages like C or C++, are integrated into Android applications to enhance performance or access specific hardware features. However, these languages are prone to memory management issues, such as buffer overflows, use-after-free errors, and null pointer dereferences, which can lead to memory corruption vulnerabilities. Such vulnerabilities can compromise the application&#39;s stability and security, potentially allowing attackers to execute arbitrary code or escalate privileges.</p>\n",
              "remediation": "<p>The assessment team recommends the following measures to mitigate memory corruption risks:</p>\n<ul>\n<li>Adopt Memory-Safe Languages: Utilize languages like Java or Kotlin for application development, minimizing direct memory management.​</li>\n<li>Implement Secure Coding Practices: When native code is necessary, adhere to secure coding standards, such as input validation and proper memory handling.​</li>\n<li>Enable Compiler Security Features: Use compiler options like _FORTIFY_SOURCE to detect and prevent buffer overflows and other memory issues at compile-time or runtime. ​</li>\n<li>Apply Address Space Layout Randomization (ASLR): Ensure ASLR is enabled to randomize memory addresses, making exploitation more challenging.</li>\n</ul>\n",
              "impact": "<p>Exploitation of memory corruption vulnerabilities can result in:</p>\n<ul>\n<li>Remote Code Execution (RCE): Attackers may execute arbitrary code within the application's context, leading to unauthorized actions or data breaches.​</li>\n<li>Denial of Service (DoS): Memory corruption can cause application crashes or instability, disrupting service availability.​</li>\n<li>Privilege Escalation: Attackers might gain elevated privileges, accessing restricted areas of the system or other applications' data.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>project1</b> utiliza métodos nativos dentro de su código base. Los métodos nativos, a menudo escritos en lenguajes como C o C++, se integran en aplicaciones de Android para mejorar el rendimiento o acceder a funciones de hardware específicas. Sin embargo, estos lenguajes son propensos a sufrir problemas de gestión de la memoria, como desbordamientos del búfer, errores de uso después de la liberación y desreferencias de puntero nulo, lo que puede provocar vulnerabilidades de corrupción de la memoria. Estas vulnerabilidades pueden comprometer la estabilidad y la seguridad de la aplicación, permitiendo potencialmente a los atacantes ejecutar código arbitrario o escalar privilegios.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes medidas para mitigar los riesgos de corrupción de la memoria:</p>\n<ul>\n<li>Adopte lenguajes seguros para la memoria: utilice lenguajes como Java o Kotlin para el desarrollo de aplicaciones, minimizando la administración directa de la memoria.</li>\n<li>Implementar prácticas de codificación segura: cuando sea necesario el código nativo, cumpla con los estándares de codificación segura, como la validación de entradas y el manejo adecuado de la memoria.</li>\n<li>Habilite las funciones de seguridad del compilador: use opciones del compilador como _FORTIFY_SOURCE para detectar y evitar desbordamientos del búfer y otros problemas de memoria en tiempo de compilación o ejecución. ​</li>\n<li>Aplicar aleatorización del diseño del espacio de direcciones (ASLR): asegúrese de que ASLR esté habilitado para aleatorizar las direcciones de memoria, lo que hace que la explotación sea más desafiante.</li>\n</ul>\n",
              "impact": "<p>La explotación de vulnerabilidades de corrupción de memoria puede resultar en:</p>\n<ul>\n<li>Ejecución remota de código (RCE): los atacantes pueden ejecutar código arbitrario dentro del contexto de la aplicación, lo que lleva a acciones no autorizadas o violaciones de datos.</li>\n<li>Denegación de servicio (DoS): la corrupción de la memoria puede provocar fallos o inestabilidad de las aplicaciones, lo que altera la disponibilidad del servicio.</li>\n<li>Escalada de privilegios: los atacantes pueden obtener privilegios elevados, accediendo a áreas restringidas del sistema o a datos de otras aplicaciones.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Native Memory Usage Debugging | Android Open Source Project",
              "url": "https://source.android.com/docs/core/tests/debug/native-memory?hl=es"
            },
            {
              "label": "Use of Native Code | Security | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/use-of-native-code?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-3",
            "maswe": "MASWE-0116"
          },
          "evidences": [
            {
              "id": "0b00afde-4fd6-445d-8cb0-e117f9341645",
              "value": "private static long nativeCreateFromTypefaceWithExactStyle(long nativeInstance, int weight, boolean italic) {\n         try {\n             return ((Long) WeightTypefaceApi26.sNativeCreateFromTypefaceWithExactStyle.invoke(null, Long.valueOf(nativeInstance), Integer.valueOf(weight), Boolean.valueOf(italic))).longValue();\n         } catch (IllegalAccessException e) {\n             throw new RuntimeException(e);\n         } catch (InvocationTargetException e2) {\n             throw new RuntimeException(e2);\n         }\n     }",
              "vulnerability_id": "ca3d8e30-a4dc-4883-b280-6ac8a23e8cf8",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/graphics/WeightTypefaceApi26.java",
              "file_line": [
                424
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.391-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "290ce8ed-e08f-4df8-9ec5-ae1bed9bd1fb",
              "value": "private static long nativeCreateWeightAlias(long nativeInstance, int weight) {\n         try {\n             return ((Long) WeightTypefaceApi21.sNativeCreateWeightAlias.invoke(null, Long.valueOf(nativeInstance), Integer.valueOf(weight))).longValue();\n         } catch (IllegalAccessException e) {\n             throw new RuntimeException(e);\n         } catch (InvocationTargetException e2) {\n             throw new RuntimeException(e2);\n         }\n     }",
              "vulnerability_id": "ca3d8e30-a4dc-4883-b280-6ac8a23e8cf8",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/graphics/WeightTypefaceApi21.java",
              "file_line": [
                591
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.369-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0482acd6-cc2c-4f56-9b00-a6c4f9c67117",
              "value": "private static long nativeCreateFromTypefaceWithExactStyle(long nativeInstance, int weight, boolean italic) {\n         int style = italic ? 2 : 0;\n         try {\n             return ((Long) WeightTypefaceApi21.sNativeCreateWeightAlias.invoke(null, Long.valueOf(((Long) WeightTypefaceApi21.sNativeCreateFromTypeface.invoke(null, Long.valueOf(nativeInstance), Integer.valueOf(style))).longValue()), Integer.valueOf(weight))).longValue();\n         } catch (IllegalAccessException e) {\n             throw new RuntimeException(e);\n         } catch (InvocationTargetException e2) {\n             throw new RuntimeException(e2);\n         }\n     }",
              "vulnerability_id": "ca3d8e30-a4dc-4883-b280-6ac8a23e8cf8",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/graphics/WeightTypefaceApi21.java",
              "file_line": [
                486
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.355-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "3cf6af56-c656-48de-9a73-56fd2ea4f90c",
          "title": "Use of External Storage with Media Types",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>project1</b> processes media files using external storage. External storage in Android is publicly accessible, meaning any application with the necessary permissions can read or modify files stored there. If sensitive data is stored or handled insecurely in external storage, the application may be exposed to security risks.</p>\n",
              "remediation": "<p>The assessment team recommends storing sensitive media files in internal storage whenever possible to prevent unauthorized access. Applications targeting Android 10 (API level 29) and above should implement scoped storage to restrict access to external storage. Additionally, it is essential to validate and sanitize files read from external storage to prevent injection attacks and to limit the use of permissions such as READ_EXTERNAL_STORAGE and WRITE_EXTERNAL_STORAGE to only essential cases.</p>\n",
              "impact": "<p>Improper use of external storage can lead to:</p>\n<ul>\n<li>Data Tampering: Malicious applications can modify media files stored in external storage, potentially altering their content.</li>\n<li>Data Leakage: Sensitive information stored in external storage may be accessed by unauthorized applications.</li>\n<li>Code Injection: If the application processes media files from external storage without validation, an attacker could introduce malicious payloads.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>project1</b> procesa archivos multimedia utilizando almacenamiento externo. El almacenamiento externo en Android es de acceso público, lo que significa que cualquier aplicación con los permisos necesarios puede leer o modificar los archivos almacenados allí. Si los datos confidenciales se almacenan o manejan de manera insegura en un almacenamiento externo, la aplicación puede quedar expuesta a riesgos de seguridad.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda almacenar archivos multimedia confidenciales en un almacenamiento interno siempre que sea posible para evitar el acceso no autorizado. Las aplicaciones destinadas a Android 10 (nivel de API 29) y superiores deben implementar almacenamiento con alcance para restringir el acceso al almacenamiento externo. Además, es esencial validar y desinfectar los archivos leídos desde el almacenamiento externo para evitar ataques de inyección y limitar el uso de permisos como READ_EXTERNAL_STORAGE y WRITE_EXTERNAL_STORAGE solo a casos esenciales.</p>\n",
              "impact": "<p>El uso inadecuado del almacenamiento externo puede provocar:</p>\n<ul>\n<li>Manipulación de datos: las aplicaciones maliciosas pueden modificar archivos multimedia almacenados en un almacenamiento externo, alterando potencialmente su contenido.</li>\n<li>Fuga de datos: aplicaciones no autorizadas pueden acceder a la información confidencial almacenada en un almacenamiento externo.</li>\n<li>Inyección de código: si la aplicación procesa archivos multimedia desde un almacenamiento externo sin validación, un atacante podría introducir cargas útiles maliciosas.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#external-storage"
            },
            {
              "label": "Sensitive Data Stored in External Storage | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sensitive-data-external-storage"
            },
            {
              "label": "MASTG-TEST-0201: Runtime Use of APIs to Access External Storage | OWASP Mobile Application Security",
              "url": "https://mas.owasp.org/MASTG/tests-beta/android/MASVS-STORAGE/MASTG-TEST-0201/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "1f1b0bca-0f1c-49e1-ac4e-8d976968eb74",
              "value": "Cursor getSearchManagerSuggestions(SearchableInfo searchable, String query, int limit) {\n         String authority;\n         String[] selArgs;\n         if (searchable == null || (authority = searchable.getSuggestAuthority()) == null) {\n             return null;\n         }\n         Uri.Builder uriBuilder = new Uri.Builder().scheme(\"content\").authority(authority).query(\"\").fragment(\"\");\n         String contentPath = searchable.getSuggestPath();\n         if (contentPath != null) {\n             uriBuilder.appendEncodedPath(contentPath);\n         }\n         uriBuilder.appendPath(\"search_suggest_query\");\n         String selection = searchable.getSuggestSelection();\n         if (selection != null) {\n             String[] selArgs2 = {query};\n             selArgs = selArgs2;\n         } else {\n             uriBuilder.appendPath(query);\n             selArgs = null;\n         }\n         if (limit > 0) {\n             uriBuilder.appendQueryParameter(\"limit\", String.valueOf(limit));\n         }\n         Uri uri = uriBuilder.build();\n         return ((SuggestionsAdapter) this).mProviderContext.getContentResolver().query(uri, null, selection, selArgs, null);\n     }",
              "vulnerability_id": "3cf6af56-c656-48de-9a73-56fd2ea4f90c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SuggestionsAdapter.java",
              "file_line": [
                2176
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.571-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6da8193e-5bb6-4787-bef5-acad4c3100cf",
              "value": "private static long queryForLong(Context context, Uri self, String column, long defaultValue) {\n         ContentResolver resolver = context.getContentResolver();\n         Cursor c = null;\n         try {\n             c = resolver.query(self, new String[]{column}, null, null, null);\n             return (!c.moveToFirst() || c.isNull(0)) ? defaultValue : c.getLong(0);\n         } catch (Exception e) {\n             Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             return defaultValue;\n         } finally {\n             DocumentsContractApi19.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "3cf6af56-c656-48de-9a73-56fd2ea4f90c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/DocumentsContractApi19.java",
              "file_line": [
                578
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.608-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1fdfbed8-84ba-41d6-b6b1-1a63843067eb",
              "value": "private static String queryForString(Context context, Uri self, String column, String defaultValue) {\n         ContentResolver resolver = context.getContentResolver();\n         Cursor c = null;\n         try {\n             c = resolver.query(self, new String[]{column}, null, null, null);\n             return (!c.moveToFirst() || c.isNull(0)) ? defaultValue : c.getString(0);\n         } catch (Exception e) {\n             Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             return defaultValue;\n         } finally {\n             DocumentsContractApi19.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "3cf6af56-c656-48de-9a73-56fd2ea4f90c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/DocumentsContractApi19.java",
              "file_line": [
                707
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.621-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c305f928-3ad2-4ba1-b4f1-c8f03c8eee13",
              "value": "public static boolean exists(Context context, Uri self) {\n         ContentResolver resolver = context.getContentResolver();\n         Cursor c = null;\n         try {\n             c = resolver.query(self, new String[]{\"document_id\"}, null, null, null);\n             return c.getCount() > 0;\n         } catch (Exception e) {\n             Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             return false;\n         } finally {\n             DocumentsContractApi19.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "3cf6af56-c656-48de-9a73-56fd2ea4f90c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/DocumentsContractApi19.java",
              "file_line": [
                229
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.586-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8501283b-4a8a-44a5-8a43-c17738c4033b",
              "value": "public DocumentFile[] listFiles() {\n         ContentResolver resolver = ((TreeDocumentFile) this).mContext.getContentResolver();\n         Uri childrenUri = DocumentsContract.buildChildDocumentsUriUsingTree(((TreeDocumentFile) this).mUri, DocumentsContract.getDocumentId(((TreeDocumentFile) this).mUri));\n         ArrayList<Uri> results = new ArrayList<>();\n         Cursor c = null;\n         try {\n             try {\n                 c = resolver.query(childrenUri, new String[]{\"document_id\"}, null, null, null);\n                 while (c.moveToNext()) {\n                     String documentId = c.getString(0);\n                     Uri documentUri = DocumentsContract.buildDocumentUriUsingTree(((TreeDocumentFile) this).mUri, documentId);\n                     results.add(documentUri);\n                 }\n             } catch (Exception e) {\n                 Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             }\n             Uri[] result = (Uri[]) results.toArray(new Uri[results.size()]);\n             DocumentFile[] resultFiles = new DocumentFile[result.length];\n             for (int i = 0; i < result.length; i++) {\n                 resultFiles[i] = new TreeDocumentFile(this, ((TreeDocumentFile) this).mContext, result[i]);\n             }\n             return resultFiles;\n         } finally {\n             TreeDocumentFile.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "3cf6af56-c656-48de-9a73-56fd2ea4f90c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/TreeDocumentFile.java",
              "file_line": [
                423
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.635-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "f916069d-f408-4809-a2bf-48c06a49abae",
          "title": "Access External Storage",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>project1</b> application utilizes external storage for reading and writing data. Storing data externally poses a risk as it can be accessed and modified by malicious applications on the same device. This vulnerability can lead to information disclosure, data tampering, or other forms of malicious behavior.</p>\n<p>The code snippet below illustrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends not storing executable files, configuration files, or sensitive user data on the external storage if its possible otherwise it should be strongly encrypted to avoid sensitive information to be disclosed.</p>\n",
              "impact": "<p>An attacker or a malicious application could exploit this vulnerability to access or modify the data stored in the external storage. This unauthorized access or modification could lead to serious security issues, including data breaches, information disclosure, and compromising the integrity of the application&#39;s data.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación <b>project1</b> utiliza almacenamiento externo para leer y escribir datos. El almacenamiento de datos de forma externa representa un riesgo, ya que puede ser accedido y modificado por aplicaciones maliciosas en el mismo dispositivo. Esta vulnerabilidad puede llevar a la divulgación de información, manipulación de datos u otras formas de comportamiento malicioso.</p>\n<p>El fragmento de código a continuación ilustra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda evitar almacenar archivos ejecutables, archivos de configuración o datos sensibles de usuarios en el almacenamiento externo siempre que sea posible. Si es necesario utilizar almacenamiento externo, es crucial emplear encriptación fuerte para prevenir la divulgación de información sensible.</p>\n",
              "impact": "<p>Un atacante o una aplicación maliciosa podría aprovechar esta vulnerabilidad para acceder o modificar los datos almacenados en el almacenamiento externo. Este acceso o modificación no autorizados podrían conducir a graves problemas de seguridad, incluyendo violaciones de datos, divulgación de información y compromiso de la integridad de los datos de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "M2: Insecure Data Storage | OWASP Foundation",
              "url": "https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage"
            },
            {
              "label": "MSTG- Testing Data Storage",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#external-storage"
            },
            {
              "label": "CWE - CWE-921: Storage of Sensitive Data in a Mechanism without Access Control (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/921.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "c0c1837b-5f7c-4c25-b877-0660e670e084",
              "value": "static File[] getExternalCacheDirs(Context obj) {\n         return obj.getExternalCacheDirs();\n     }",
              "vulnerability_id": "f916069d-f408-4809-a2bf-48c06a49abae",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/ContextCompat$Api19Impl.java",
              "file_line": [
                33
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.287-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ac069d5d-9e84-494f-a72b-1b0a261f0682",
              "value": "static File[] getExternalFilesDirs(Context obj, String type) {\n         return obj.getExternalFilesDirs(type);\n     }",
              "vulnerability_id": "f916069d-f408-4809-a2bf-48c06a49abae",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/ContextCompat$Api19Impl.java",
              "file_line": [
                46
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.303-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "edf5baaf-dda9-4732-a07e-11de0a2dbb28",
              "value": "static File[] getExternalMediaDirs(Context context) {\n         return context.getExternalMediaDirs();\n     }",
              "vulnerability_id": "f916069d-f408-4809-a2bf-48c06a49abae",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/FileProvider$Api21Impl.java",
              "file_line": [
                33
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.323-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "8f5d57c8-5945-4df6-a2c6-1816aa588458",
          "title": "Debug Enabled For App [android:debuggable=true]",
          "severity": "low",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>project1</b> application has the &#39;debuggable&#39; flag set to &#39;true&#39; in its <b>AndroidManifest.xml</b> file. Enabling debugging in the application simplifies the process for reverse engineers to analyze it and attach a debugger. This exposes the app to risks such as dumping stack traces and accessing debugging helper classes.</p>\n<p>The flag is evident in the following snippet from the Android Manifest file:</p>\n",
              "remediation": "<p>The assessment team strongly recommends ensuring that the <b>android:debuggable</b> flag is set to &#39;false&#39; when releasing your application. This practice is crucial for maintaining security and preventing unauthorized access or reverse engineering of the app.</p>\n",
              "impact": "<p>Setting the <b>android:debuggable</b> flag to &#39;true&#39; in the application <b>project1</b> allows debugging, which makes it easier for attackers to gain access to secure parts of the application. This setting increases the risk of sensitive functionalities and data being exposed, as it simplifies reverse engineering and unauthorized access.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación <b>project1</b> tiene el &#39;flag&#39; &#39;debuggable&#39; configurado en &#39;true&#39; en su archivo <b>AndroidManifest.xml</b>. Habilitar la depuración en la aplicación facilita a los analistas de ingeniería inversa para analizarla y conectar un depurador. Esto expone la aplicación a riesgos como el volcado de &#39;stack traces&#39; y el acceso a clases de ayuda para la depuración.</p>\n<p>El &#39;flag&#39; se puede ver en el siguiente fragmento del archivo Android Manifest:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda encarecidamente asegurarse de que el &#39;flag&#39; <b>android:debuggable</b> esté configurado en &#39;false&#39; al lanzar su aplicación. Esta práctica es crucial para mantener la seguridad y prevenir el acceso no autorizado o la ingeniería inversa de la app.</p>\n",
              "impact": "<p>Configurar el &#39;flag&#39; <b>android:debuggable</b> en &#39;true&#39; en la aplicación <b>project1</b> permite la depuración, lo que facilita que los atacantes accedan a partes seguras de la aplicación. Esta configuración aumenta el riesgo de que se expongan funcionalidades y datos sensibles, ya que simplifica la ingeniería inversa y el acceso no autorizado.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "android:debuggable  |  App quality  |  Android Developers",
              "url": "https://developer.android.com/topic/security/risks/android-debuggable"
            },
            {
              "label": "Exploiting debuggable android applications | Infosec",
              "url": "https://resources.infosecinstitute.com/topic/android-hacking-security-part-6-exploiting-debuggable-android-applications/"
            },
            {
              "label": "MSTG - Testing Code Quality",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#debuggable-apps"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0067"
          },
          "evidences": [
            {
              "id": "9af7f6eb-16e0-45d1-84ba-cdd2d62345a6",
              "value": "<permission android:name=\"com.jms.project1.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION\" android:protectionLevel=\"signature\" />\n    <uses-permission android:name=\"com.jms.project1.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION\" />\n    <application android:theme=\"@style/Theme.Project1\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:debuggable=\"true\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:extractNativeLibs=\"false\" android:fullBackupContent=\"@xml/backup_rules\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:appComponentFactory=\"androidx.core.app.CoreComponentFactory\" android:dataExtractionRules=\"@xml/data_extraction_rules\">\n        <activity android:name=\"com.jms.project1.SecretActivity\" android:exported=\"true\">",
              "vulnerability_id": "8f5d57c8-5945-4df6-a2c6-1816aa588458",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/AndroidManifest.xml",
              "file_line": [],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T20:59:46.684-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "5577f272-b797-40a0-a1bd-7f4b317e6e0d",
          "title": "Application Allows Execution of Backups",
          "severity": "low",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>android:allowBackup</b> attribute is set to true in the Android Manifest file of the <b>project1</b> application. This setting determines if a user can back up and restore the application&#39;s data. When the backup flag is true, it permits an attacker to extract a backup of the application&#39;s data through adb/USB, even on unrooted devices.</p>\n",
              "remediation": "<p>To prevent unauthorized backup of the app data, set the <b>android:allowBackup</b> attribute to false. By default, the allowBackup setting is enabled if this attribute is not explicitly defined, necessitating manual deactivation. It&#39;s important to regularly review the <b>AndroidManifest.xml</b> file to ensure that the developer framework does not inadvertently include insecure default settings.</p>\n",
              "impact": "<p>Android includes an <b>allowBackup</b> attribute, used to enable the backup of all application data. This attribute is defined in the <b>AndroidManifest.xml</b> file. When its value is set to true, it permits users to back up the application data using the Android Debug Bridge (ADB). However, this setting can potentially expose sensitive data, as it allows for data backup without strong security controls, potentially leading to data leakage or unauthorized access if exploited.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que el atributo <b>android:allowBackup</b> está configurado como true en el archivo Android Manifest de la aplicación <b>project1</b>. Esta configuración determina si los datos de la aplicación pueden ser respaldados y restaurados por el usuario. Cuando el flag allowBackup está en true, permite a un atacante realizar un backup de los datos de la aplicación a través de adb/USB, incluso en dispositivos que no están rooteados.</p>\n",
              "remediation": "<p>Para prevenir el respaldo no autorizado de los datos de la aplicación, configure el atributo <b>android:allowBackup</b> en false. Por defecto, la configuración allowBackup está habilitada si este atributo no se define explícitamente, lo que requiere una desactivación manual. Es importante revisar regularmente el archivo <b>AndroidManifest.xml</b> para asegurarse de que el marco de desarrollo no incluya por error configuraciones predeterminadas inseguras.</p>\n",
              "impact": "<p>Android incluye un atributo llamado <b>allowBackup</b>, utilizado para habilitar el respaldo de todos los datos de una aplicación. Este atributo se define en el archivo <b>AndroidManifest.xml</b>. Cuando su valor está configurado en true, permite a los usuarios respaldar los datos de la aplicación utilizando el Android Debug Bridge (ADB). Sin embargo, esta configuración puede exponer datos sensibles, ya que permite realizar copias de seguridad de datos sin controles de seguridad estrictos, lo que podría llevar a la filtración de datos o acceso no autorizado si se explota.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "MSTG - Testing Backups",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-backups-for-sensitive-data-mstg-storage-8"
            },
            {
              "label": "Back up user data with Auto Backup  |  Android Developers",
              "url": "https://developer.android.com/guide/topics/data/autobackup"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-2",
            "maswe": "MASWE-0003"
          },
          "evidences": [
            {
              "id": "bd6d07c3-5d3a-4b88-aba1-b92b0d373a86",
              "value": "<permission android:name=\"com.jms.project1.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION\" android:protectionLevel=\"signature\" />\n    <uses-permission android:name=\"com.jms.project1.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION\" />\n    <application android:theme=\"@style/Theme.Project1\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:debuggable=\"true\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:extractNativeLibs=\"false\" android:fullBackupContent=\"@xml/backup_rules\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:appComponentFactory=\"androidx.core.app.CoreComponentFactory\" android:dataExtractionRules=\"@xml/data_extraction_rules\">\n        <activity android:name=\"com.jms.project1.SecretActivity\" android:exported=\"true\">",
              "vulnerability_id": "5577f272-b797-40a0-a1bd-7f4b317e6e0d",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/AndroidManifest.xml",
              "file_line": [],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T20:59:47.540-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "9a0af386-09aa-447f-977b-1689491f7c14",
          "title": "Dynamic Receiver Registration",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team discovered a vulnerability in the <b>project1</b> application related to the dynamic registration of broadcast receivers. This issue arises due to the application&#39;s use of the registerReceiver() method, which can register broadcast receivers dynamically at runtime instead of declaring them statically in the Android manifest. While dynamic registration provides flexibility, it also introduces potential security risks if not properly managed.</p>\n<p>Specifically, dynamically registered broadcast receivers do not benefit from the Android system&#39;s manifest-based security checks, which can lead to unintended broadcast exposure. If the intent filters associated with these receivers are not carefully specified, it could allow external applications to send broadcasts to the receivers, potentially leading to information leakage or triggering unintended behavior within the app.</p>\n<p>The following code snippet shows the insecure implementation:</p>\n",
              "remediation": "<p>To mitigate the risks associated with dynamically registered broadcast receivers the assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Explicit Intent Filters: Ensure that all dynamically registered broadcast receivers use explicit intent filters that clearly define what actions the receiver is intended to respond to. This helps prevent malicious apps from sending broadcasts that could trigger unintended behavior.\n</li>\n<li>Validate Broadcast Origin: Implement checks within the broadcast receiver to validate the origin of the broadcast. This ensures that only broadcasts from trusted sources are processed, reducing the risk of unauthorized access or manipulation.\n</li>\n<li>Limit Receiver Exposure: Where possible, avoid dynamic registration of broadcast receivers and instead declare them statically in the Android manifest with the necessary permission settings. This leverages the platform's built-in security features to control who can send broadcasts to the receivers.\n</li>\n<li>Use Local Broadcast Manager: For intra-app communication, use Android's Local Broadcast Manager to handle broadcasts. This confines broadcast messages to the app itself, preventing external applications from sending messages to the receivers.\n</li>\n<li>Unregister Receivers: Always ensure that dynamically registered receivers are unregistered when not needed, especially when the app is not in the foreground. This prevents dormant receivers from being triggered unexpectedly.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit the dynamically registered broadcast receivers to send unauthorized broadcasts that trigger unintended actions or manipulate the application’s behavior. This vulnerability could lead to the leakage of sensitive information if broadcasts are intercepted, or could cause the application to perform unintended operations. Such exposures can compromise user data privacy and application functionality</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió una vulnerabilidad en la aplicación <b>project1</b> relacionada con el registro dinámico de receptores de transmisión. Este problema surge debido al uso por parte de la aplicación del método RegisterReceiver(), que puede registrar receptores de transmisión dinámicamente en tiempo de ejecución en lugar de declararlos estáticamente en el manifiesto de Android. Si bien el registro dinámico proporciona flexibilidad, también introduce riesgos potenciales de seguridad si no se gestiona adecuadamente.</p>\n<p>Específicamente, los receptores de transmisión registrados dinámicamente no se benefician de las comprobaciones de seguridad basadas en manifiestos del sistema Android, lo que puede provocar una exposición involuntaria de la transmisión. Si los filtros de intención asociados con estos receptores no se especifican cuidadosamente, podría permitir que aplicaciones externas envíen transmisiones a los receptores, lo que podría provocar una fuga de información o desencadenar un comportamiento no deseado dentro de la aplicación.</p>\n<p>El siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>Para mitigar los riesgos asociados con los receptores de transmisión registrados dinámicamente, el equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Filtros de intención explícitos: asegúrese de que todos los receptores de transmisión registrados dinámicamente utilicen filtros de intención explícitos que definan claramente a qué acciones debe responder el receptor. Esto ayuda a evitar que aplicaciones maliciosas envíen difusiones que podrían desencadenar un comportamiento no deseado.\n</li>\n<li>Validar origen de transmisión: implemente comprobaciones dentro del receptor de transmisión para validar el origen de la transmisión. Esto garantiza que solo se procesen transmisiones de fuentes confiables, lo que reduce el riesgo de acceso o manipulación no autorizados.\n</li>\n<li>Limitar la exposición del receptor: cuando sea posible, evite el registro dinámico de los receptores de transmisión y, en cambio, declárelos estáticamente en el manifiesto de Android con la configuración de permisos necesaria. Esto aprovecha las funciones de seguridad integradas de la plataforma para controlar quién puede enviar transmisiones a los receptores.\n</li>\n<li>Utilizar el Administrador de transmisiones locales: para la comunicación dentro de la aplicación, use el Administrador de transmisiones locales de Android para manejar las transmisiones. Esto limita los mensajes de difusión a la propia aplicación y evita que aplicaciones externas envíen mensajes a los receptores.\n</li>\n<li>Cancelar receptores: asegúrese siempre de cancelar el registro de los receptores registrados dinámicamente cuando no sean necesarios, especialmente cuando la aplicación no esté en primer plano. Esto evita que los receptores inactivos se activen inesperadamente.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar los receptores de transmisión registrados dinámicamente para enviar transmisiones no autorizadas que desencadenen acciones no deseadas o manipulen el comportamiento de la aplicación. Esta vulnerabilidad podría provocar la fuga de información confidencial si se interceptan las transmisiones o podría provocar que la aplicación realice operaciones no deseadas. Estas exposiciones pueden comprometer la privacidad de los datos del usuario y la funcionalidad de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Transmisiones persistentes | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sticky-broadcast?hl=es-419"
            },
            {
              "label": "Insecure Broadcast Receiver Configuration - Ostorlab: Mobile application security testing for android and ios",
              "url": "https://docs.ostorlab.co/kb/INSECURE_REGISTER_RECEIVER_FLAG/index.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0063"
          },
          "evidences": [
            {
              "id": "1f708893-1e64-4e36-a757-20915dc4b313",
              "value": "void setup() {\n         cleanup();\n         IntentFilter filter = createIntentFilterForBroadcastReceiver();\n         if (filter == null || filter.countActions() == 0) {\n             return;\n         }\n         if (((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver == null) {\n             ((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver = new AppCompatDelegateImpl.AutoNightModeManager.1(this);\n         }\n         ((AppCompatDelegateImpl.AutoNightModeManager) this).this$0.mContext.registerReceiver(((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver, filter);\n     }",
              "vulnerability_id": "9a0af386-09aa-447f-977b-1689491f7c14",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/app/AppCompatDelegateImpl$AutoNightModeManager.java",
              "file_line": [
                148
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.732-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "72f5fcd0-5540-4b31-ba01-1e25ce2dc33a",
              "value": "static Intent registerReceiver(Context obj, BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler, int flags) {\n         if ((flags & 4) != 0 && broadcastPermission == null) {\n             String permission = ContextCompat.obtainAndCheckReceiverPermission(obj);\n             return obj.registerReceiver(receiver, filter, permission, scheduler);\n         }\n         return obj.registerReceiver(receiver, filter, broadcastPermission, scheduler, flags & 1);\n     }",
              "vulnerability_id": "9a0af386-09aa-447f-977b-1689491f7c14",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/ContextCompat$Api26Impl.java",
              "file_line": [
                51
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.747-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7b34e2e0-50c8-465d-b788-ee2d6ef90bf7",
              "value": "static Intent registerReceiver(Context obj, BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler, int flags) {\n         return obj.registerReceiver(receiver, filter, broadcastPermission, scheduler, flags);\n     }",
              "vulnerability_id": "9a0af386-09aa-447f-977b-1689491f7c14",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/ContextCompat$Api33Impl.java",
              "file_line": [
                38
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.761-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "e31139ef-52f8-407e-9e72-c1bc12d43210",
          "title": "Implicit Intent Detected",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>project1</b> uses implicit intents, which allow the Android system to determine which component, potentially from another application, should handle an intent. While this enables flexible inter-application communication, insecure implementation can lead to unintended exposure of sensitive functionality.</p>\n",
              "remediation": "<p>The assessment team recommends using explicit intents whenever possible to ensure that only intended application components handle them. If implicit intents are required, developers should restrict exposed components by properly configuring intent filters and setting the exported attribute to false when external access is not necessary. Additionally, all incoming intents should be validated to prevent unauthorized access or data manipulation.</p>\n",
              "impact": "<p>Improper handling of implicit intents can result in intent hijacking, where malicious applications intercept and manipulate intents that were not explicitly directed to a specific component. This could lead to unauthorized access to sensitive data or unintended execution of actions triggered by an attacker.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>project1</b> utiliza intenciones implícitas, que permiten al sistema Android determinar qué componente, potencialmente de otra aplicación, debe manejar una intención. Si bien esto permite una comunicación flexible entre aplicaciones, una implementación insegura puede provocar una exposición involuntaria de funciones confidenciales.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda utilizar intenciones explícitas siempre que sea posible para garantizar que solo los componentes de la aplicación previstos las manejen. Si se requieren intenciones implícitas, los desarrolladores deben restringir los componentes expuestos configurando correctamente los filtros de intención y estableciendo el atributo exportado en falso cuando no sea necesario el acceso externo. Además, todos los intents entrantes deben validarse para evitar el acceso no autorizado o la manipulación de datos.</p>\n",
              "impact": "<p>El manejo inadecuado de intenciones implícitas puede resultar en secuestro de intenciones, donde aplicaciones maliciosas interceptan y manipulan intenciones que no estaban dirigidas explícitamente a un componente específico. Esto podría dar lugar a un acceso no autorizado a datos confidenciales o a la ejecución involuntaria de acciones provocadas por un atacante.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Intents and Intent Filters | App architecture - Android Developers",
              "url": "https://developer.android.com/guide/components/intents-filters?hl=es-419"
            },
            {
              "label": "Implicit Intent Hijacking | Security - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/implicit-intent-hijacking?hl=es-419"
            },
            {
              "label": "Mitigate security risks in your app - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "1bc1f922-a2d3-4d8b-927d-2c0c66dc6480",
              "value": "public Intent createIntent(Context context, Uri input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         Intent putExtra = new Intent(\"android.media.action.VIDEO_CAPTURE\").putExtra(\"output\", input);\n         Intrinsics.checkNotNullExpressionValue(putExtra, \"Intent(MediaStore.ACTION…tore.EXTRA_OUTPUT, input)\");\n         return putExtra;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$CaptureVideo.java",
              "file_line": [
                89
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.800-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7ba9e9ec-35ee-4970-b5cb-d94fc8c28045",
              "value": "public Intent createIntent(Context context, String input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         Intent putExtra = new Intent(\"android.intent.action.CREATE_DOCUMENT\").setType(((ActivityResultContracts.CreateDocument) this).mimeType).putExtra(\"android.intent.extra.TITLE\", input);\n         Intrinsics.checkNotNullExpressionValue(putExtra, \"Intent(Intent.ACTION_CRE…ntent.EXTRA_TITLE, input)\");\n         return putExtra;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$CreateDocument.java",
              "file_line": [
                142
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.815-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3cc5f76e-815c-40a7-8b08-fc3cd6d952be",
              "value": "public Intent createIntent(Context context, String input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         Intent type = new Intent(\"android.intent.action.GET_CONTENT\").addCategory(\"android.intent.category.OPENABLE\").setType(input);\n         Intrinsics.checkNotNullExpressionValue(type, \"Intent(Intent.ACTION_GET…          .setType(input)\");\n         return type;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$GetContent.java",
              "file_line": [
                109
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.831-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2a24e90b-ee7b-4b79-8be5-7a29fd8e0c28",
              "value": "public Intent createIntent(Context context, String input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         Intent putExtra = new Intent(\"android.intent.action.GET_CONTENT\").addCategory(\"android.intent.category.OPENABLE\").setType(input).putExtra(\"android.intent.extra.ALLOW_MULTIPLE\", true);\n         Intrinsics.checkNotNullExpressionValue(putExtra, \"Intent(Intent.ACTION_GET…TRA_ALLOW_MULTIPLE, true)\");\n         return putExtra;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$GetMultipleContents.java",
              "file_line": [
                134
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.845-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ac47c123-38ba-467e-b05e-1b7fc61fcdad",
              "value": "public Intent createIntent(Context context, String[] input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         Intent type = new Intent(\"android.intent.action.OPEN_DOCUMENT\").putExtra(\"android.intent.extra.MIME_TYPES\", input).setType(\"**\\\")\");\n         return type;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$OpenDocument.java",
              "file_line": [
                113
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.874-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ef82c417-d947-45fd-b642-5fb942625ace",
              "value": "private boolean ensureServiceBound(NotificationManagerCompat.SideChannelManager.ListenerRecord record) {\n         if (record.bound) {\n             return true;\n         }\n         Intent intent = new Intent(\"android.support.BIND_NOTIFICATION_SIDE_CHANNEL\").setComponent(record.componentName);\n         record.bound = ((NotificationManagerCompat.SideChannelManager) this).mContext.bindService(intent, this, 33);\n         if (record.bound) {\n             record.retryCount = 0;\n         } else {\n             Log.w(\"NotifManCompat\", \"Unable to bind to listener \" + record.componentName);\n             ((NotificationManagerCompat.SideChannelManager) this).mContext.unbindService(this);\n         }\n         return record.bound;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/NotificationManagerCompat$SideChannelManager.java",
              "file_line": [
                142
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.141-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0d300cd8-1d6f-4e09-8cd2-6fa72cf2f011",
              "value": "public ClsD4AOO6DE47HEJ3G(Context context, AttributeSet attrs, int defStyleAttr) {\n         super(context, attrs, defStyleAttr);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         ((SearchView) this).mOnClickListener = new SearchView.5(this);\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         ((SearchView) this).mOnEditorActionListener = new SearchView.7(this);\n         ((SearchView) this).mOnItemClickListener = new SearchView.8(this);\n         ((SearchView) this).mOnItemSelectedListener = new SearchView.9(this);\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.SearchView, defStyleAttr, 0);\n         ViewCompat.saveAttributeDataForStyleable(this, context, R.styleable.SearchView, attrs, a.getWrappedTypeArray(), defStyleAttr, 0);\n         LayoutInflater inflater = LayoutInflater.from(context);\n         int layoutResId = a.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view);\n         inflater.inflate(layoutResId, (ViewGroup) this, true);\n         ((SearchView) this).mSearchSrcTextView = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         ((SearchView) this).mSearchPlate = findViewById(R.id.search_plate);\n         ((SearchView) this).mSubmitArea = findViewById(R.id.submit_area);\n         ((SearchView) this).mSearchButton = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mGoButton = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mCloseButton = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mVoiceButton = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mCollapsedIcon = (ImageView) findViewById(R.id.search_mag_icon);\n         ViewCompat.setBackground(((SearchView) this).mSearchPlate, a.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(((SearchView) this).mSubmitArea, a.getDrawable(R.styleable.SearchView_submitBackground));\n         ((SearchView) this).mSearchButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mGoButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_goIcon));\n         ((SearchView) this).mCloseButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_closeIcon));\n         ((SearchView) this).mVoiceButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_voiceIcon));\n         ((SearchView) this).mCollapsedIcon.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = a.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(((SearchView) this).mSearchButton, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = a.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = a.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         ((SearchView) this).mSearchButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mCloseButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mGoButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mVoiceButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.addTextChangedListener(((SearchView) this).mTextWatcher);\n         ((SearchView) this).mSearchSrcTextView.setOnEditorActionListener(((SearchView) this).mOnEditorActionListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemClickListener(((SearchView) this).mOnItemClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemSelectedListener(((SearchView) this).mOnItemSelectedListener);\n         ((SearchView) this).mSearchSrcTextView.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         ((SearchView) this).mSearchSrcTextView.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (maxWidth != -1) {\n             setMaxWidth(maxWidth);\n         }\n         ((SearchView) this).mDefaultQueryHint = a.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = a.getText(R.styleable.SearchView_queryHint);\n         int imeOptions = a.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (imeOptions != -1) {\n             setImeOptions(imeOptions);\n         }\n         int inputType = a.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (inputType != -1) {\n             setInputType(inputType);\n         }\n         boolean focusable = a.getBoolean(R.styleable.SearchView_android_focusable, true);\n         setFocusable(focusable);\n         a.recycle();\n         ((SearchView) this).mVoiceWebSearchIntent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent.addFlags(268435456);\n         ((SearchView) this).mVoiceWebSearchIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         ((SearchView) this).mVoiceAppSearchIntent = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent.addFlags(268435456);\n         ((SearchView) this).mDropDownAnchor = findViewById(((SearchView) this).mSearchSrcTextView.getDropDownAnchor());\n         if (((SearchView) this).mDropDownAnchor != null) {\n             ((SearchView) this).mDropDownAnchor.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                735
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.223-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "a2911c86-d327-4fb0-a3c2-4930b783023b",
              "value": "public Cls5281FK8SVCH355A(Context context, AttributeSet attrs, int defStyleAttr) {\n         super(context, attrs, defStyleAttr);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         ((SearchView) this).mOnClickListener = new SearchView.5(this);\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         ((SearchView) this).mOnEditorActionListener = new SearchView.7(this);\n         ((SearchView) this).mOnItemClickListener = new SearchView.8(this);\n         ((SearchView) this).mOnItemSelectedListener = new SearchView.9(this);\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.SearchView, defStyleAttr, 0);\n         ViewCompat.saveAttributeDataForStyleable(this, context, R.styleable.SearchView, attrs, a.getWrappedTypeArray(), defStyleAttr, 0);\n         LayoutInflater inflater = LayoutInflater.from(context);\n         int layoutResId = a.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view);\n         inflater.inflate(layoutResId, (ViewGroup) this, true);\n         ((SearchView) this).mSearchSrcTextView = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         ((SearchView) this).mSearchPlate = findViewById(R.id.search_plate);\n         ((SearchView) this).mSubmitArea = findViewById(R.id.submit_area);\n         ((SearchView) this).mSearchButton = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mGoButton = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mCloseButton = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mVoiceButton = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mCollapsedIcon = (ImageView) findViewById(R.id.search_mag_icon);\n         ViewCompat.setBackground(((SearchView) this).mSearchPlate, a.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(((SearchView) this).mSubmitArea, a.getDrawable(R.styleable.SearchView_submitBackground));\n         ((SearchView) this).mSearchButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mGoButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_goIcon));\n         ((SearchView) this).mCloseButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_closeIcon));\n         ((SearchView) this).mVoiceButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_voiceIcon));\n         ((SearchView) this).mCollapsedIcon.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = a.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(((SearchView) this).mSearchButton, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = a.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = a.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         ((SearchView) this).mSearchButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mCloseButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mGoButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mVoiceButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.addTextChangedListener(((SearchView) this).mTextWatcher);\n         ((SearchView) this).mSearchSrcTextView.setOnEditorActionListener(((SearchView) this).mOnEditorActionListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemClickListener(((SearchView) this).mOnItemClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemSelectedListener(((SearchView) this).mOnItemSelectedListener);\n         ((SearchView) this).mSearchSrcTextView.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         ((SearchView) this).mSearchSrcTextView.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (maxWidth != -1) {\n             setMaxWidth(maxWidth);\n         }\n         ((SearchView) this).mDefaultQueryHint = a.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = a.getText(R.styleable.SearchView_queryHint);\n         int imeOptions = a.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (imeOptions != -1) {\n             setImeOptions(imeOptions);\n         }\n         int inputType = a.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (inputType != -1) {\n             setInputType(inputType);\n         }\n         boolean focusable = a.getBoolean(R.styleable.SearchView_android_focusable, true);\n         setFocusable(focusable);\n         a.recycle();\n         ((SearchView) this).mVoiceWebSearchIntent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent.addFlags(268435456);\n         ((SearchView) this).mVoiceWebSearchIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         ((SearchView) this).mVoiceAppSearchIntent = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent.addFlags(268435456);\n         ((SearchView) this).mDropDownAnchor = findViewById(((SearchView) this).mSearchSrcTextView.getDropDownAnchor());\n         if (((SearchView) this).mDropDownAnchor != null) {\n             ((SearchView) this).mDropDownAnchor.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                760
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.251-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0669c945-ae7f-4279-a001-c22f29c3dd47",
              "value": "public Intent createIntent(Context context, Uri input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intent intent = new Intent(\"android.intent.action.OPEN_DOCUMENT_TREE\");\n         if (input != null) {\n             intent.putExtra(\"android.provider.extra.INITIAL_URI\", input);\n         }\n         return intent;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$OpenDocumentTree.java",
              "file_line": [
                87
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.901-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6cb262bd-4ffa-4674-92e6-d7ed357704ff",
              "value": "public Intent createIntent(Context context, PickVisualMediaRequest input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         if (ActivityResultContracts.PickVisualMedia.Companion.isSystemPickerAvailable$activity_release()) {\n             Intent $this$createIntent_u24lambda_u242 = new Intent(\"android.provider.action.PICK_IMAGES\");\n             $this$createIntent_u24lambda_u242.setType(ActivityResultContracts.PickVisualMedia.Companion.getVisualMimeType$activity_release(input.getMediaType()));\n             if (!(((ActivityResultContracts.PickMultipleVisualMedia) this).maxItems <= MediaStore.getPickImagesMaxLimit())) {\n                 throw new IllegalArgumentException(\"Max items must be less or equals MediaStore.getPickImagesMaxLimit()\".toString());\n             }\n             $this$createIntent_u24lambda_u242.putExtra(\"android.provider.extra.PICK_IMAGES_MAX\", ((ActivityResultContracts.PickMultipleVisualMedia) this).maxItems);\n             return $this$createIntent_u24lambda_u242;\n         } else if (ActivityResultContracts.PickVisualMedia.Companion.isSystemFallbackPickerAvailable$activity_release(context)) {\n             ResolveInfo systemFallbackPicker$activity_release = ActivityResultContracts.PickVisualMedia.Companion.getSystemFallbackPicker$activity_release(context);\n             if (systemFallbackPicker$activity_release == null) {\n                 throw new IllegalStateException(\"Required value was null.\".toString());\n             }\n             ActivityInfo fallbackPicker = systemFallbackPicker$activity_release.activityInfo;\n             Intent $this$createIntent_u24lambda_u243 = new Intent(\"androidx.activity.result.contract.action.PICK_IMAGES\");\n             $this$createIntent_u24lambda_u243.setClassName(fallbackPicker.applicationInfo.packageName, fallbackPicker.name);\n             $this$createIntent_u24lambda_u243.setType(ActivityResultContracts.PickVisualMedia.Companion.getVisualMimeType$activity_release(input.getMediaType()));\n             $this$createIntent_u24lambda_u243.putExtra(\"com.google.android.gms.provider.extra.PICK_IMAGES_MAX\", ((ActivityResultContracts.PickMultipleVisualMedia) this).maxItems);\n             return $this$createIntent_u24lambda_u243;\n         } else if (ActivityResultContracts.PickVisualMedia.Companion.isGmsPickerAvailable$activity_release(context)) {\n             ResolveInfo gmsPicker$activity_release = ActivityResultContracts.PickVisualMedia.Companion.getGmsPicker$activity_release(context);\n             if (gmsPicker$activity_release == null) {\n                 throw new IllegalStateException(\"Required value was null.\".toString());\n             }\n             ActivityInfo gmsPicker = gmsPicker$activity_release.activityInfo;\n             Intent $this$createIntent_u24lambda_u244 = new Intent(\"com.google.android.gms.provider.action.PICK_IMAGES\");\n             $this$createIntent_u24lambda_u244.setClassName(gmsPicker.applicationInfo.packageName, gmsPicker.name);\n             $this$createIntent_u24lambda_u244.putExtra(\"com.google.android.gms.provider.extra.PICK_IMAGES_MAX\", ((ActivityResultContracts.PickMultipleVisualMedia) this).maxItems);\n             return $this$createIntent_u24lambda_u244;\n         } else {\n             Intent $this$createIntent_u24lambda_u245 = new Intent(\"android.intent.action.OPEN_DOCUMENT\");\n             $this$createIntent_u24lambda_u245.setType(ActivityResultContracts.PickVisualMedia.Companion.getVisualMimeType$activity_release(input.getMediaType()));\n             $this$createIntent_u24lambda_u245.putExtra(\"android.intent.extra.ALLOW_MULTIPLE\", true);\n             if ($this$createIntent_u24lambda_u245.getType() != null) {\n                 return $this$createIntent_u24lambda_u245;\n             }\n             $this$createIntent_u24lambda_u245.setType(\"*/*\");\n             $this$createIntent_u24lambda_u245.putExtra(\"android.intent.extra.MIME_TYPES\", new String[]{\"image/*\", \"video/*\"});\n             return $this$createIntent_u24lambda_u245;\n         }\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$PickMultipleVisualMedia.java",
              "file_line": [
                219
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.945-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2e430f8d-7431-47da-95ce-82f9b16edcaa",
              "value": "public Intent createIntent(Context context, Void input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         return new Intent(\"android.media.action.IMAGE_CAPTURE\");\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$TakePicturePreview.java",
              "file_line": [
                105
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.042-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "27a7ece7-e2fa-43b7-a747-63cdb2cc6697",
              "value": "public static Intent createManageUnusedAppRestrictionsIntent(Context context, String packageName) {\n         if (!PackageManagerCompat.areUnusedAppRestrictionsAvailable(context.getPackageManager())) {\n             throw new UnsupportedOperationException(\"Unused App Restriction features are not available on this device\");\n         }\n         if (Build.VERSION.SDK_INT >= 31) {\n             return new Intent(\"android.settings.APPLICATION_DETAILS_SETTINGS\").setData(Uri.fromParts(\"package\", packageName, null));\n         }\n         Intent permissionRevocationSettingsIntent = new Intent(\"android.intent.action.AUTO_REVOKE_PERMISSIONS\").setData(Uri.fromParts(\"package\", packageName, null));\n         return permissionRevocationSettingsIntent;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/IntentCompat.java",
              "file_line": [
                69
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.156-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b445b5fb-b581-43a4-9f74-8b3d5ab4e11f",
              "value": "public Intent createIntent(Context context, IntentSenderRequest input) {\n         Bundle activityOptions;\n         Intent result = new Intent(\"androidx.activity.result.contract.action.INTENT_SENDER_REQUEST\");\n         Intent fillInIntent = input.getFillInIntent();\n         if (fillInIntent != null && (activityOptions = fillInIntent.getBundleExtra(\"androidx.activity.result.contract.extra.ACTIVITY_OPTIONS_BUNDLE\")) != null) {\n             result.putExtra(\"androidx.activity.result.contract.extra.ACTIVITY_OPTIONS_BUNDLE\", activityOptions);\n             fillInIntent.removeExtra(\"androidx.activity.result.contract.extra.ACTIVITY_OPTIONS_BUNDLE\");\n             if (fillInIntent.getBooleanExtra(\"androidx.fragment.extra.ACTIVITY_OPTIONS_BUNDLE\", false)) {\n                 input = new IntentSenderRequest.Builder(input.getIntentSender()).setFillInIntent((Intent) null).setFlags(input.getFlagsValues(), input.getFlagsMask()).build();\n             }\n         }\n         result.putExtra(\"androidx.activity.result.contract.extra.INTENT_SENDER_REQUEST\", (Parcelable) input);\n         if (FragmentManager.isLoggingEnabled(2)) {\n             Log.v(\"FragmentManager\", \"CreateIntent created the following intent: \" + result);\n         }\n         return result;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/fragment/app/FragmentManager$FragmentIntentSenderContract.java",
              "file_line": [
                48
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.207-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "93e43a69-3afd-4ca5-928f-0b929bfb8040",
              "value": "public Intent createIntent(Context context, String[] input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         Intent type = new Intent(\"android.intent.action.OPEN_DOCUMENT\").putExtra(\"android.intent.extra.MIME_TYPES\", input).putExtra(\"android.intent.extra.ALLOW_MULTIPLE\", true).setType(\"**\\\")\");\n         return type;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$OpenMultipleDocuments.java",
              "file_line": [
                113
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.916-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "de48ef9c-10ad-40ba-b979-e5701a43ecd6",
              "value": "public Intent createIntent(Context context, Void input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intent type = new Intent(\"android.intent.action.PICK\").setType(\"vnd.android.cursor.dir/contact\");\n         Intrinsics.checkNotNullExpressionValue(type, \"Intent(Intent.ACTION_PIC…ct.Contacts.CONTENT_TYPE)\");\n         return type;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$PickContact.java",
              "file_line": [
                103
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.930-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b2479c19-4dc9-4965-9b27-512bcb5846dc",
              "value": "public final Intent createIntent$activity_release(String[] input) {\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         Intent putExtra = new Intent(\"androidx.activity.result.contract.action.REQUEST_PERMISSIONS\").putExtra(\"androidx.activity.result.contract.extra.PERMISSIONS\", input);\n         Intrinsics.checkNotNullExpressionValue(putExtra, \"Intent(ACTION_REQUEST_PE…EXTRA_PERMISSIONS, input)\");\n         return putExtra;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$RequestMultiplePermissions$Companion.java",
              "file_line": [
                79
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.981-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c2742a30-9a66-4d11-8025-aa4a8241ab15",
              "value": "public Intent createIntent(Context context, IntentSenderRequest input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         Intent putExtra = new Intent(\"androidx.activity.result.contract.action.INTENT_SENDER_REQUEST\").putExtra(\"androidx.activity.result.contract.extra.INTENT_SENDER_REQUEST\", (Parcelable) input);\n         Intrinsics.checkNotNullExpressionValue(putExtra, \"Intent(ACTION_INTENT_SEN…NT_SENDER_REQUEST, input)\");\n         return putExtra;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$StartIntentSenderForResult.java",
              "file_line": [
                118
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.995-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8fa5c370-9912-42ac-996d-31b576485263",
              "value": "public ClsRRM68Z1F4HCCEU4(Context context, AttributeSet attrs, int defStyleAttr) {\n         super(context, attrs, defStyleAttr);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         ((SearchView) this).mOnClickListener = new SearchView.5(this);\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         ((SearchView) this).mOnEditorActionListener = new SearchView.7(this);\n         ((SearchView) this).mOnItemClickListener = new SearchView.8(this);\n         ((SearchView) this).mOnItemSelectedListener = new SearchView.9(this);\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.SearchView, defStyleAttr, 0);\n         ViewCompat.saveAttributeDataForStyleable(this, context, R.styleable.SearchView, attrs, a.getWrappedTypeArray(), defStyleAttr, 0);\n         LayoutInflater inflater = LayoutInflater.from(context);\n         int layoutResId = a.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view);\n         inflater.inflate(layoutResId, (ViewGroup) this, true);\n         ((SearchView) this).mSearchSrcTextView = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         ((SearchView) this).mSearchPlate = findViewById(R.id.search_plate);\n         ((SearchView) this).mSubmitArea = findViewById(R.id.submit_area);\n         ((SearchView) this).mSearchButton = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mGoButton = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mCloseButton = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mVoiceButton = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mCollapsedIcon = (ImageView) findViewById(R.id.search_mag_icon);\n         ViewCompat.setBackground(((SearchView) this).mSearchPlate, a.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(((SearchView) this).mSubmitArea, a.getDrawable(R.styleable.SearchView_submitBackground));\n         ((SearchView) this).mSearchButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mGoButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_goIcon));\n         ((SearchView) this).mCloseButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_closeIcon));\n         ((SearchView) this).mVoiceButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_voiceIcon));\n         ((SearchView) this).mCollapsedIcon.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = a.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(((SearchView) this).mSearchButton, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = a.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = a.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         ((SearchView) this).mSearchButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mCloseButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mGoButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mVoiceButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.addTextChangedListener(((SearchView) this).mTextWatcher);\n         ((SearchView) this).mSearchSrcTextView.setOnEditorActionListener(((SearchView) this).mOnEditorActionListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemClickListener(((SearchView) this).mOnItemClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemSelectedListener(((SearchView) this).mOnItemSelectedListener);\n         ((SearchView) this).mSearchSrcTextView.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         ((SearchView) this).mSearchSrcTextView.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (maxWidth != -1) {\n             setMaxWidth(maxWidth);\n         }\n         ((SearchView) this).mDefaultQueryHint = a.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = a.getText(R.styleable.SearchView_queryHint);\n         int imeOptions = a.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (imeOptions != -1) {\n             setImeOptions(imeOptions);\n         }\n         int inputType = a.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (inputType != -1) {\n             setInputType(inputType);\n         }\n         boolean focusable = a.getBoolean(R.styleable.SearchView_android_focusable, true);\n         setFocusable(focusable);\n         a.recycle();\n         ((SearchView) this).mVoiceWebSearchIntent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent.addFlags(268435456);\n         ((SearchView) this).mVoiceWebSearchIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         ((SearchView) this).mVoiceAppSearchIntent = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent.addFlags(268435456);\n         ((SearchView) this).mDropDownAnchor = findViewById(((SearchView) this).mSearchSrcTextView.getDropDownAnchor());\n         if (((SearchView) this).mDropDownAnchor != null) {\n             ((SearchView) this).mDropDownAnchor.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                735
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.064-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "43914492-6990-499a-8c26-3b9cab963f2a",
              "value": "private Intent createVoiceAppSearchIntent(Intent baseIntent, SearchableInfo searchable) {\n         ComponentName searchActivity = searchable.getSearchActivity();\n         Intent queryIntent = new Intent(\"android.intent.action.SEARCH\");\n         queryIntent.setComponent(searchActivity);\n         PendingIntent pending = PendingIntent.getActivity(getContext(), 0, queryIntent, 1107296256);\n         Bundle queryExtras = new Bundle();\n         if (((SearchView) this).mAppSearchData != null) {\n             queryExtras.putParcelable(\"app_data\", ((SearchView) this).mAppSearchData);\n         }\n         Intent voiceIntent = new Intent(baseIntent);\n         String languageModel = \"free_form\";\n         String prompt = null;\n         String language = null;\n         int maxResults = 1;\n         Resources resources = getResources();\n         if (searchable.getVoiceLanguageModeId() != 0) {\n             languageModel = resources.getString(searchable.getVoiceLanguageModeId());\n         }\n         if (searchable.getVoicePromptTextId() != 0) {\n             prompt = resources.getString(searchable.getVoicePromptTextId());\n         }\n         if (searchable.getVoiceLanguageId() != 0) {\n             language = resources.getString(searchable.getVoiceLanguageId());\n         }\n         if (searchable.getVoiceMaxResults() != 0) {\n             maxResults = searchable.getVoiceMaxResults();\n         }\n         voiceIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", languageModel);\n         voiceIntent.putExtra(\"android.speech.extra.PROMPT\", prompt);\n         voiceIntent.putExtra(\"android.speech.extra.LANGUAGE\", language);\n         voiceIntent.putExtra(\"android.speech.extra.MAX_RESULTS\", maxResults);\n         voiceIntent.putExtra(\"calling_package\", searchActivity == null ? null : searchActivity.flattenToShortString());\n         voiceIntent.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT\", pending);\n         voiceIntent.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT_BUNDLE\", queryExtras);\n         return voiceIntent;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                1148
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.126-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7a6796b8-9b9b-41e6-9ebe-34225854ace0",
              "value": "public Intent createIntent(Context context, PickVisualMediaRequest input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         if (ActivityResultContracts.PickVisualMedia.Companion.isSystemPickerAvailable$activity_release()) {\n             Intent $this$createIntent_u24lambda_u240 = new Intent(\"android.provider.action.PICK_IMAGES\");\n             $this$createIntent_u24lambda_u240.setType(ActivityResultContracts.PickVisualMedia.Companion.getVisualMimeType$activity_release(input.getMediaType()));\n             return $this$createIntent_u24lambda_u240;\n         } else if (ActivityResultContracts.PickVisualMedia.Companion.isSystemFallbackPickerAvailable$activity_release(context)) {\n             ResolveInfo systemFallbackPicker$activity_release = ActivityResultContracts.PickVisualMedia.Companion.getSystemFallbackPicker$activity_release(context);\n             if (systemFallbackPicker$activity_release == null) {\n                 throw new IllegalStateException(\"Required value was null.\".toString());\n             }\n             ActivityInfo fallbackPicker = systemFallbackPicker$activity_release.activityInfo;\n             Intent $this$createIntent_u24lambda_u241 = new Intent(\"androidx.activity.result.contract.action.PICK_IMAGES\");\n             $this$createIntent_u24lambda_u241.setClassName(fallbackPicker.applicationInfo.packageName, fallbackPicker.name);\n             $this$createIntent_u24lambda_u241.setType(ActivityResultContracts.PickVisualMedia.Companion.getVisualMimeType$activity_release(input.getMediaType()));\n             return $this$createIntent_u24lambda_u241;\n         } else if (ActivityResultContracts.PickVisualMedia.Companion.isGmsPickerAvailable$activity_release(context)) {\n             ResolveInfo gmsPicker$activity_release = ActivityResultContracts.PickVisualMedia.Companion.getGmsPicker$activity_release(context);\n             if (gmsPicker$activity_release == null) {\n                 throw new IllegalStateException(\"Required value was null.\".toString());\n             }\n             ActivityInfo gmsPicker = gmsPicker$activity_release.activityInfo;\n             Intent $this$createIntent_u24lambda_u242 = new Intent(\"com.google.android.gms.provider.action.PICK_IMAGES\");\n             $this$createIntent_u24lambda_u242.setClassName(gmsPicker.applicationInfo.packageName, gmsPicker.name);\n             $this$createIntent_u24lambda_u242.setType(ActivityResultContracts.PickVisualMedia.Companion.getVisualMimeType$activity_release(input.getMediaType()));\n             return $this$createIntent_u24lambda_u242;\n         } else {\n             Intent $this$createIntent_u24lambda_u243 = new Intent(\"android.intent.action.OPEN_DOCUMENT\");\n             $this$createIntent_u24lambda_u243.setType(ActivityResultContracts.PickVisualMedia.Companion.getVisualMimeType$activity_release(input.getMediaType()));\n             if ($this$createIntent_u24lambda_u243.getType() != null) {\n                 return $this$createIntent_u24lambda_u243;\n             }\n             $this$createIntent_u24lambda_u243.setType(\"*/*\");\n             $this$createIntent_u24lambda_u243.putExtra(\"android.intent.extra.MIME_TYPES\", new String[]{\"image/*\", \"video/*\"});\n             return $this$createIntent_u24lambda_u243;\n         }\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$PickVisualMedia.java",
              "file_line": [
                250
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:46.967-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "92c58b9a-cbe1-4772-b0f5-30913f405b71",
              "value": "public Intent createIntent(Context context, Uri input) {\n         Intrinsics.checkNotNullParameter(context, \"context\");\n         Intrinsics.checkNotNullParameter(input, \"input\");\n         Intent putExtra = new Intent(\"android.media.action.IMAGE_CAPTURE\").putExtra(\"output\", input);\n         Intrinsics.checkNotNullExpressionValue(putExtra, \"Intent(MediaStore.ACTION…tore.EXTRA_OUTPUT, input)\");\n         return putExtra;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/activity/result/contract/ActivityResultContracts$TakePicture.java",
              "file_line": [
                89
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.010-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b2f5ab40-30da-4de2-bc18-6c072d3dc7d3",
              "value": "public Cls7C84X40IW9URADN(Context context, AttributeSet attrs, int defStyleAttr) {\n         super(context, attrs, defStyleAttr);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         ((SearchView) this).mOnClickListener = new SearchView.5(this);\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         ((SearchView) this).mOnEditorActionListener = new SearchView.7(this);\n         ((SearchView) this).mOnItemClickListener = new SearchView.8(this);\n         ((SearchView) this).mOnItemSelectedListener = new SearchView.9(this);\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.SearchView, defStyleAttr, 0);\n         ViewCompat.saveAttributeDataForStyleable(this, context, R.styleable.SearchView, attrs, a.getWrappedTypeArray(), defStyleAttr, 0);\n         LayoutInflater inflater = LayoutInflater.from(context);\n         int layoutResId = a.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view);\n         inflater.inflate(layoutResId, (ViewGroup) this, true);\n         ((SearchView) this).mSearchSrcTextView = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         ((SearchView) this).mSearchPlate = findViewById(R.id.search_plate);\n         ((SearchView) this).mSubmitArea = findViewById(R.id.submit_area);\n         ((SearchView) this).mSearchButton = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mGoButton = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mCloseButton = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mVoiceButton = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mCollapsedIcon = (ImageView) findViewById(R.id.search_mag_icon);\n         ViewCompat.setBackground(((SearchView) this).mSearchPlate, a.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(((SearchView) this).mSubmitArea, a.getDrawable(R.styleable.SearchView_submitBackground));\n         ((SearchView) this).mSearchButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mGoButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_goIcon));\n         ((SearchView) this).mCloseButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_closeIcon));\n         ((SearchView) this).mVoiceButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_voiceIcon));\n         ((SearchView) this).mCollapsedIcon.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = a.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(((SearchView) this).mSearchButton, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = a.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = a.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         ((SearchView) this).mSearchButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mCloseButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mGoButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mVoiceButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.addTextChangedListener(((SearchView) this).mTextWatcher);\n         ((SearchView) this).mSearchSrcTextView.setOnEditorActionListener(((SearchView) this).mOnEditorActionListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemClickListener(((SearchView) this).mOnItemClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemSelectedListener(((SearchView) this).mOnItemSelectedListener);\n         ((SearchView) this).mSearchSrcTextView.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         ((SearchView) this).mSearchSrcTextView.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (maxWidth != -1) {\n             setMaxWidth(maxWidth);\n         }\n         ((SearchView) this).mDefaultQueryHint = a.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = a.getText(R.styleable.SearchView_queryHint);\n         int imeOptions = a.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (imeOptions != -1) {\n             setImeOptions(imeOptions);\n         }\n         int inputType = a.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (inputType != -1) {\n             setInputType(inputType);\n         }\n         boolean focusable = a.getBoolean(R.styleable.SearchView_android_focusable, true);\n         setFocusable(focusable);\n         a.recycle();\n         ((SearchView) this).mVoiceWebSearchIntent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent.addFlags(268435456);\n         ((SearchView) this).mVoiceWebSearchIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         ((SearchView) this).mVoiceAppSearchIntent = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent.addFlags(268435456);\n         ((SearchView) this).mDropDownAnchor = findViewById(((SearchView) this).mSearchSrcTextView.getDropDownAnchor());\n         if (((SearchView) this).mDropDownAnchor != null) {\n             ((SearchView) this).mDropDownAnchor.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                760
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.085-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8ab8bffe-e480-419a-8d8e-1150411dbdf8",
              "value": "private Intent createIntent(String action, Uri data, String extraData, String query, int actionKey, String actionMsg) {\n         Intent intent = new Intent(action);\n         intent.addFlags(268435456);\n         if (data != null) {\n             intent.setData(data);\n         }\n         intent.putExtra(\"user_query\", ((SearchView) this).mUserQuery);\n         if (query != null) {\n             intent.putExtra(\"query\", query);\n         }\n         if (extraData != null) {\n             intent.putExtra(\"intent_extra_data_key\", extraData);\n         }\n         if (((SearchView) this).mAppSearchData != null) {\n             intent.putExtra(\"app_data\", ((SearchView) this).mAppSearchData);\n         }\n         if (actionKey != 0) {\n             intent.putExtra(\"action_key\", actionKey);\n             intent.putExtra(\"action_msg\", actionMsg);\n         }\n         intent.setComponent(((SearchView) this).mSearchable.getSearchActivity());\n         return intent;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                821
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.112-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0bcf0877-a250-4ef8-94b0-47ca937ae6fc",
              "value": "public static String getPermissionRevocationVerifierApp(PackageManager packageManager) {\n         Intent permissionRevocationSettingsIntent = new Intent(\"android.intent.action.AUTO_REVOKE_PERMISSIONS\").setData(Uri.fromParts(\"package\", \"com.example\", null));\n         List<ResolveInfo> intentResolvers = packageManager.queryIntentActivities(permissionRevocationSettingsIntent, 0);\n         String verifierPackageName = null;\n         for (ResolveInfo intentResolver : intentResolvers) {\n             String packageName = intentResolver.activityInfo.packageName;\n             if (packageManager.checkPermission(\"android.permission.PACKAGE_VERIFICATION_AGENT\", packageName) == 0) {\n                 if (verifierPackageName != null) {\n                     return verifierPackageName;\n                 }\n                 verifierPackageName = packageName;\n             }\n         }\n         return verifierPackageName;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/PackageManagerCompat.java",
              "file_line": [
                90
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.178-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6d052a49-f048-42e7-acfb-24881062106c",
              "value": "private ProviderInfo queryDefaultInstalledContentProvider(PackageManager packageManager) {\n         List<ResolveInfo> providers = ((DefaultEmojiCompatConfig.DefaultEmojiCompatConfigFactory) this).mHelper.queryIntentContentProviders(packageManager, new Intent(\"androidx.content.action.LOAD_EMOJI_FONT\"), 0);\n         for (ResolveInfo resolveInfo : providers) {\n             ProviderInfo providerInfo = ((DefaultEmojiCompatConfig.DefaultEmojiCompatConfigFactory) this).mHelper.getProviderInfo(resolveInfo);\n             if (hasFlagSystem(providerInfo)) {\n                 return providerInfo;\n             }\n         }\n         return null;\n     }",
              "vulnerability_id": "e31139ef-52f8-407e-9e72-c1bc12d43210",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory.java",
              "file_line": [
                228
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:59:47.193-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        }
      ],
      "severityDistribution": {
        "high": 25,
        "info": 25,
        "medium": 25,
        "low": 25
      },
      "severityCount": {
        "high": 2,
        "info": 2,
        "medium": 2,
        "low": 2
      },
      "properties": {
        "MIN_SDK": 30,
        "MD5": "cbe966675f863616aa1f2995eab4ef30",
        "SHA1": "80006340153dc397e68d2d7232227c9ffd489fce",
        "SHA256": "ae4ca6b5588908270d9b105152dac1c8484ffa1df8949e0485a4b3462c1580da",
        "VERSION": 1,
        "MAIN_ACTIVITY": "com.jms.project1.MainActivity",
        "ANDROID_VERSION_CODE": 1,
        "FRAMEWORK": "Native (Java / Kotlin)",
        "BINARY_PROTECTIONS": null
      },
      "permissions": [
        "com.jms.project1.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
      ],
      "components": [
        {
          "name": "com.jms.project1.SecretActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": true
        },
        {
          "name": "com.jms.project1.MainActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": true
        },
        {
          "name": "androidx.profileinstaller.ProfileInstallReceiver",
          "type": "R",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "androidx.startup.InitializationProvider",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        }
      ],
      "protections": [
        {
          "type": "anti_vm",
          "name": "Emulation Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": [
            {
              "name": "Build.BRAND",
              "files": [
                "classes3.dex"
              ]
            },
            {
              "name": "Build.DEVICE",
              "files": [
                "classes3.dex"
              ]
            },
            {
              "name": "Build.FINGERPRINT",
              "files": [
                "classes3.dex",
                "classes.dex"
              ]
            },
            {
              "name": "Build.MANUFACTURER",
              "files": [
                "classes3.dex",
                "classes.dex"
              ]
            },
            {
              "name": "Build.MODEL",
              "files": [
                "classes3.dex",
                "classes.dex"
              ]
            },
            {
              "name": "Build.PRODUCT",
              "files": [
                "classes3.dex"
              ]
            },
            {
              "name": "possible VM",
              "files": [
                "android.apk",
                "classes3.dex"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": 5,
      "status": "COMPLETED",
      "start_at": "2025-06-14T00:00:00.000-03:00",
      "end_at": "2025-06-15T23:59:59.999-03:00",
      "created_at": "2025-06-14T20:54:47.107-03:00",
      "updated_at": "2025-06-14T20:57:12.573-03:00",
      "platform": "ANDROID",
      "services": {
        "id": 0,
        "name": "Mobile Penetration Testing"
      },
      "assessment": {
        "status": "COMPLETED",
        "id": "8ef3efee-e8d8-46b2-ac97-78a3030e2f6d",
        "name": null,
        "company_id": 1,
        "company": {
          "id": 1,
          "name": "Just Mobile Security"
        }
      },
      "scans": [
        {
          "id": "2f3773ba-9f79-4940-afa5-78b6e30f89b7",
          "aat_version": "0.1.0-beta-2",
          "scan_status": "FINISHED",
          "created_at": "2025-06-14T20:54:47.481-03:00",
          "updated_at": "2025-06-14T20:57:12.558-03:00",
          "type": "SAST",
          "app_id": "2c3f2bda-a801-4ca2-9fb8-3a41354f91c4",
          "assessment_service_id": 5,
          "app": {
            "id": "2c3f2bda-a801-4ca2-9fb8-3a41354f91c4",
            "name": "Noisiv",
            "description": "com.matrix.noisiv",
            "created_at": "2025-06-14T20:54:47.480-03:00",
            "updated_at": "2025-06-14T20:55:08.661-03:00",
            "version": null,
            "icon": {
              "url": "http://storage.fakedomain.com/bucket-storage/assessments/8ef3efee-e8d8-46b2-ac97-78a3030e2f6d/service/5/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T012947Z&X-Amz-Expires=600&X-Amz-Signature=c5c2a5fb19b4321e416df5c3b5dd97955d8c0107579b645cc3adb13c9adc1e27&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
              "name": "assessments/8ef3efee-e8d8-46b2-ac97-78a3030e2f6d/service/5/icon.png",
              "extname": "png",
              "size": 4985,
              "mimeType": "image/png"
            }
          }
        }
      ],
      "summary": {
        "appId": "2c3f2bda-a801-4ca2-9fb8-3a41354f91c4",
        "name": "Noisiv",
        "description": "com.matrix.noisiv",
        "platform": "ANDROID",
        "version": "",
        "createdAt": "2025-06-14T20:54:47.481-03:00",
        "finishedAt": "2025-06-14T20:57:12.558-03:00",
        "statusId": 5,
        "status": "Incomplete",
        "duration": {
          "days": 0,
          "hours": 0,
          "minutes": 2,
          "seconds": 25,
          "milliseconds": 77,
          "human": "2 minutes"
        },
        "file": {
          "name": "assessments/8ef3efee-e8d8-46b2-ac97-78a3030e2f6d/service/5/noisiv-(1).apk",
          "size": "7.79 MB"
        },
        "icon": "http://storage.fakedomain.com/bucket-storage/assessments/8ef3efee-e8d8-46b2-ac97-78a3030e2f6d/service/5/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T034107Z&X-Amz-Expires=600&X-Amz-Signature=e6d35658afbe42feee6e05866f95d9d0702ef406396211153989a716b15d607e&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
        "start_date": "2025-06-14T00:00:00.000-03:00",
        "end_date": "2025-06-15T23:59:59.999-03:00"
      },
      "vulnerabilities": [
        {
          "vulnerabilityId": "76f49cc0-99a6-4525-8310-87148d504872",
          "title": "SQL Injection",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team discovered potential SQL Injection (SQLi) vulnerabilities in the decompiled source code of the <b>Noisiv</b> Android application, specifically in how the application handles SQL database operations. The critical findings include the use of methods such as insert, delete, query, execSQL, and rawQuery without proper input validation or parameterization. This opens up possible attack vectors if these database operations interact with external inputs. For example, if these methods are triggered via deeplinks, interceptable network communications, or manipulated within insecure WebViews, they could potentially be exploited remotely. Such vulnerabilities are particularly concerning as they could allow an attacker to inject malicious SQL queries to manipulate or exfiltrate data from the application’s local databases, posing significant risks to data integrity and security.</p>\n<p>The following code snippet shows the insecure implementation.</p>\n",
              "remediation": "<p>The assessment team recommends the following:</p>\n<ul>\n<li>Implement Parameterized Queries: Replace all raw SQL query constructions with parameterized queries to prevent SQL injection. This practice ensures that input values are treated as data, not executable code.\n</li>\n<li>Validate and Sanitize Inputs: Rigorously validate and sanitize all inputs, especially those obtained from external sources such as deeplinks, network communications, or WebViews. Ensure that inputs conform to expected formats and do not contain malicious SQL code.\n</li>\n<li>Secure WebViews: If the application uses WebViews, ensure they are configured securely. Disable JavaScript execution if not needed, and restrict interaction between the WebView and the application to minimize exposure to injection attacks.\n</li>\n<li>Review and Restrict Database Permissions: Restrict the database permissions to the minimum necessary for the application to function. This minimizes the potential damage from an SQL injection attack by limiting what an attacker can do within the database.</li>\n</ul>\n",
              "impact": "<p>An attacker could potentially execute unauthorized SQL commands, leading to data manipulation or exfiltration. This could result in the compromise of sensitive user data stored within the application&#39;s databases, such as personal details, credentials, financial information or disrupt application functionality. The ability to exploit these vulnerabilities remotely via methods like deeplinks or insecure WebViews significantly increases the severity of the threat, expanding the potential for widespread impact on users.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación halló una posible vulnerabilidad de inyección de SQL (SQLi) en el código fuente sin compilar de la aplicación Android <b>Noisiv</b>, específicamente, en la manera en la que la aplicación maneja las operaciones de bases de datos de SQL. Estos hallazgos críticos incluyen el uso de métodos (como insert, delete, query, execSQL y rawQuery) sin una validación o parametrización apropiada de las entradas. Esto habilita posibles vectores de ataque si estas operaciones de base de datos interactúan con entradas externas. Por ejemplo, si estos métodos son activadios a través enlaces profundos o comunicaciones de red interceptables, o si se manipulan en vistas web inseguras, podrían explotarse de manera remota. Estas vulnerabilidades son particularmente preocupantes, ya que podrían permitirle a un atacante inyectar consultas SQL malintencionadas para manipular o extraer información de las bases de datos locales de la aplicación, lo cual implica un gran riesgo para la seguridad y la integridad de la información.</p>\n<p>El siguiente fragmento de código muestra la implementación segura.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda lo siguiente:</p>\n<ul>\n<li>Implementar consultas parametrizadas: reemplace todas las construcciones de consultas SQL sin formato con consultas parametrizadas para evitar la inyección de SQL. Esta práctica garantiza que los valores de entrada se traten como datos, y no como código ejecutable.\n</li>\n<li>Validar y desinfectar entradas: valide y desinfecte rigurosamente todas las entradas, especialmente aquellas obtenidas de fuentes externas, como enlaces profundos, comunicaciones de red o vistas web. Asegúrese de que las entradas se ajusten a los formatos esperados y no contengan código SQL malintencionado.\n</li>\n<li>Vistas web seguras: si la aplicación utiliza vistas web, asegúrese de que estén configurados de manera segura. Deshabilite la ejecución de JavaScript si no es necesario y restrinja la interacción entre las vistas web y la aplicación para minimizar la exposición a ataques de inyección.\n</li>\n<li>Revisar y restringir los permisos de la base de datos: mantenga los permisos de la base de datos al mínimo necesario para que la aplicación funcione. Esto minimiza el daño potencial de un ataque de inyección SQL al limitar lo que un atacante puede hacer dentro de la base de datos</li>\n</ul>\n",
              "impact": "<p>Un atacante podría ejecutar comandos SQL no autorizados, lo que llevaría a la manipulación o extracción de datos. Esto podría poner en peligro la información sensible de los usuarios almacenada en las bases de datos de la aplicación (como detalles personales, credenciales, información financiera) o interrumpir la funcionalidad de la aplicación. La capacidad de explotar estas vulnerabilidades de manera remota mediante enlaces profundos o vistas web inseguras aumenta significativamente la gravedad de la amenaza y amplía el potencial de un impacto generalizado en los usuarios.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "SQL injection | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sql-injection"
            },
            {
              "label": "V10: Code Quality Requirements - OWASP MASVS",
              "url": "https://mas.owasp.org/MASVS/10-MASVS-CODE/"
            },
            {
              "label": "MASVS-CODE-2.5: Security Control Verification Requirements | OWASP MASTG",
              "url": "https://mas.owasp.org/MASTG/tests/android/MASVS-CODE/MASTG-TEST-0025/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0086"
          },
          "evidences": [
            {
              "id": "ac3c5948-0487-47e4-be27-b36224725078",
              "value": "public int delete(Uri uri, String selection, String[] selectionArgs) {\n         int uriType = ((TransferDBBase) this).uriMatcher.match(uri);\n         ensureDatabaseOpen();\n         if (uriType == 10) {\n             int rowsDeleted = ((TransferDBBase) this).database.delete(\"awstransfer\", selection, selectionArgs);\n             return rowsDeleted;\n         } else if (uriType == 20) {\n             String id = uri.getLastPathSegment();\n             if (TextUtils.isEmpty(selection)) {\n                 SQLiteDatabase sQLiteDatabase = ((TransferDBBase) this).database;\n                 int rowsDeleted2 = sQLiteDatabase.delete(\"awstransfer\", \"_id=\" + id, null);\n                 return rowsDeleted2;\n             }\n             SQLiteDatabase sQLiteDatabase2 = ((TransferDBBase) this).database;\n             int rowsDeleted3 = sQLiteDatabase2.delete(\"awstransfer\", \"_id=\" + id + \" and \" + selection, selectionArgs);\n             return rowsDeleted3;\n         } else {\n             throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n         }\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBBase.java",
              "file_line": [
                454
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.392-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "01da276c-7c0c-4787-a19a-cbbaf10edd91",
              "value": "public void onCreate(SQLiteDatabase database) {\n         database.execSQL(AppSyncMutationsSqlHelper.DATABASE_CREATE);\n         database.execSQL(AppSyncMutationsSqlHelper.CREATE_KEY_INDEX);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/appsync/AppSyncMutationsSqlHelper.java",
              "file_line": [
                218
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.493-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "bf649d82-bba7-42e1-9a68-82d77bec2b91",
              "value": "private static void addVersion5Columns(SQLiteDatabase database) {\n         database.execSQL(\"ALTER TABLE awstransfer ADD COLUMN header_storage_class text;\");\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java",
              "file_line": [
                198
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.634-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f4f21f07-caa4-49ec-8f8f-ed0152c569f5",
              "value": "ClsPM7ITAOUODQ04MG(RecordFieldJsonAdapter recordFieldAdapter, SQLiteOpenHelper dbHelper) {\n         ((SqlNormalizedCache) this).allColumns = new String[]{\"_id\", \"key\", \"record\"};\n         ((SqlNormalizedCache) this).recordFieldAdapter = recordFieldAdapter;\n         ((SqlNormalizedCache) this).dbHelper = dbHelper;\n         ((SqlNormalizedCache) this).database = dbHelper.getWritableDatabase();\n         ((SqlNormalizedCache) this).insertStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.INSERT_STATEMENT);\n         ((SqlNormalizedCache) this).updateStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.UPDATE_STATEMENT);\n         ((SqlNormalizedCache) this).deleteStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.DELETE_STATEMENT);\n         ((SqlNormalizedCache) this).deleteAllRecordsStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.DELETE_ALL_RECORD_STATEMENT);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.java",
              "file_line": [
                188
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.701-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3bd34327-c9ad-4df3-93a6-600155a5c169",
              "value": "ClsO4XTYTZNCEHEY5G(SQLiteOpenHelper dbHelper) {\n         ((AppSyncMutationSqlCacheOperations) this).allColumns = new String[]{\"_id\", \"record_id\", \"record\", \"response_class\", \"client_state\", \"bucket\", \"key\", \"region\", \"local_uri\", \"mime_type\"};\n         ((AppSyncMutationSqlCacheOperations) this).dbHelper = dbHelper;\n         ((AppSyncMutationSqlCacheOperations) this).database = dbHelper.getWritableDatabase();\n         ((AppSyncMutationSqlCacheOperations) this).insertStatement = ((AppSyncMutationSqlCacheOperations) this).database.compileStatement(AppSyncMutationSqlCacheOperations.INSERT_STATEMENT);\n         ((AppSyncMutationSqlCacheOperations) this).deleteStatement = ((AppSyncMutationSqlCacheOperations) this).database.compileStatement(AppSyncMutationSqlCacheOperations.DELETE_STATEMENT);\n         ((AppSyncMutationSqlCacheOperations) this).deleteAllRecordsStatement = ((AppSyncMutationSqlCacheOperations) this).database.compileStatement(AppSyncMutationSqlCacheOperations.DELETE_ALL_RECORD_STATEMENT);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/appsync/AppSyncMutationSqlCacheOperations.java",
              "file_line": [
                193
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.429-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2ea014dd-914d-46fe-a408-cd5cce6ec4a3",
              "value": "ClsB48WVDG2Z36OEU0(SQLiteOpenHelper dbHelper) {\n         ((AppSyncMutationSqlCacheOperations) this).allColumns = new String[]{\"_id\", \"record_id\", \"record\", \"response_class\", \"client_state\", \"bucket\", \"key\", \"region\", \"local_uri\", \"mime_type\"};\n         ((AppSyncMutationSqlCacheOperations) this).dbHelper = dbHelper;\n         ((AppSyncMutationSqlCacheOperations) this).database = dbHelper.getWritableDatabase();\n         ((AppSyncMutationSqlCacheOperations) this).insertStatement = ((AppSyncMutationSqlCacheOperations) this).database.compileStatement(AppSyncMutationSqlCacheOperations.INSERT_STATEMENT);\n         ((AppSyncMutationSqlCacheOperations) this).deleteStatement = ((AppSyncMutationSqlCacheOperations) this).database.compileStatement(AppSyncMutationSqlCacheOperations.DELETE_STATEMENT);\n         ((AppSyncMutationSqlCacheOperations) this).deleteAllRecordsStatement = ((AppSyncMutationSqlCacheOperations) this).database.compileStatement(AppSyncMutationSqlCacheOperations.DELETE_ALL_RECORD_STATEMENT);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/appsync/AppSyncMutationSqlCacheOperations.java",
              "file_line": [
                204
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.445-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "374f6b0c-6370-4991-98cc-12e6390d1c4f",
              "value": "ClsEGF7KNUTXW4KOCH(SQLiteOpenHelper dbHelper) {\n         ((AppSyncMutationSqlCacheOperations) this).allColumns = new String[]{\"_id\", \"record_id\", \"record\", \"response_class\", \"client_state\", \"bucket\", \"key\", \"region\", \"local_uri\", \"mime_type\"};\n         ((AppSyncMutationSqlCacheOperations) this).dbHelper = dbHelper;\n         ((AppSyncMutationSqlCacheOperations) this).database = dbHelper.getWritableDatabase();\n         ((AppSyncMutationSqlCacheOperations) this).insertStatement = ((AppSyncMutationSqlCacheOperations) this).database.compileStatement(AppSyncMutationSqlCacheOperations.INSERT_STATEMENT);\n         ((AppSyncMutationSqlCacheOperations) this).deleteStatement = ((AppSyncMutationSqlCacheOperations) this).database.compileStatement(AppSyncMutationSqlCacheOperations.DELETE_STATEMENT);\n         ((AppSyncMutationSqlCacheOperations) this).deleteAllRecordsStatement = ((AppSyncMutationSqlCacheOperations) this).database.compileStatement(AppSyncMutationSqlCacheOperations.DELETE_ALL_RECORD_STATEMENT);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/appsync/AppSyncMutationSqlCacheOperations.java",
              "file_line": [
                215
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.463-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f8c54640-2978-4fd8-b1ba-7a46100b5008",
              "value": "public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n         db.execSQL(\"DROP TABLE IF EXISTS mutation_records\");\n         onCreate(db);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/appsync/AppSyncMutationsSqlHelper.java",
              "file_line": [
                238
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.510-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "64d13d01-4fdc-47ad-bc75-3c06bf93acbc",
              "value": "public void onCreate(SQLiteDatabase database) {\n         database.execSQL(AppSyncSqlHelper.DATABASE_CREATE);\n         database.execSQL(AppSyncSqlHelper.CREATE_KEY_INDEX);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/appsync/cache/normalized/sql/AppSyncSqlHelper.java",
              "file_line": [
                162
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.529-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4f4afdd2-370b-42ed-97ea-51e285a3d4c7",
              "value": "public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n         db.execSQL(\"DROP TABLE IF EXISTS records\");\n         onCreate(db);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/appsync/cache/normalized/sql/AppSyncSqlHelper.java",
              "file_line": [
                182
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.546-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3895b8b0-da85-4664-b8b8-eff33ae381d2",
              "value": "private static void addVersion2Columns(SQLiteDatabase database) {\n         database.execSQL(\"ALTER TABLE awstransfer ADD COLUMN user_metadata text;\");\n         database.execSQL(\"ALTER TABLE awstransfer ADD COLUMN expiration_time_rule_id text;\");\n         database.execSQL(\"ALTER TABLE awstransfer ADD COLUMN http_expires_date text;\");\n         database.execSQL(\"ALTER TABLE awstransfer ADD COLUMN sse_algorithm text;\");\n         database.execSQL(\"ALTER TABLE awstransfer ADD COLUMN content_md5 text;\");\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java",
              "file_line": [
                127
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.571-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b8185f3c-d722-401d-bd7c-6551c6db0053",
              "value": "private static void addVersion3Columns(SQLiteDatabase database) {\n         database.execSQL(\"ALTER TABLE awstransfer ADD COLUMN kms_key text;\");\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java",
              "file_line": [
                164
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.588-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "06f29a64-fbe0-41c7-9f35-e6f2632f89df",
              "value": "private static void addVersion4Columns(SQLiteDatabase database) {\n         database.execSQL(\"ALTER TABLE awstransfer ADD COLUMN canned_acl text;\");\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java",
              "file_line": [
                181
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.608-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "52e56a0b-9b95-46ed-a5e0-169913d00fad",
              "value": "public static void onCreate(SQLiteDatabase database, int version) {\n         database.execSQL(\"create table awstransfer(_id integer primary key autoincrement, main_upload_id integer, type text not null, state text not null, bucket_name text not null, key text not null, version_id text, bytes_total bigint, bytes_current bigint, speed bigint, is_requester_pays integer, is_encrypted integer, file text not null, file_offset bigint, is_multipart int, part_num int not null, is_last_part integer, multipart_id text, etag text, range_start bigint, range_last bigint, header_content_type text, header_content_language text, header_content_disposition text, header_content_encoding text, header_cache_control text, header_expire text);\");\n         TransferTable.onUpgrade(database, 1, version);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java",
              "file_line": [
                212
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.655-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "cc477936-a359-4acc-beee-44dd7e28dddb",
              "value": "Cls42R7ISYTXK6B6SI(RecordFieldJsonAdapter recordFieldAdapter, SQLiteOpenHelper dbHelper) {\n         ((SqlNormalizedCache) this).allColumns = new String[]{\"_id\", \"key\", \"record\"};\n         ((SqlNormalizedCache) this).recordFieldAdapter = recordFieldAdapter;\n         ((SqlNormalizedCache) this).dbHelper = dbHelper;\n         ((SqlNormalizedCache) this).database = dbHelper.getWritableDatabase();\n         ((SqlNormalizedCache) this).insertStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.INSERT_STATEMENT);\n         ((SqlNormalizedCache) this).updateStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.UPDATE_STATEMENT);\n         ((SqlNormalizedCache) this).deleteStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.DELETE_STATEMENT);\n         ((SqlNormalizedCache) this).deleteAllRecordsStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.DELETE_ALL_RECORD_STATEMENT);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.java",
              "file_line": [
                177
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.675-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "782c3a00-32d2-4317-8062-df00e66b7bf4",
              "value": "ClsL7BQLACYHYRJXGU(RecordFieldJsonAdapter recordFieldAdapter, SQLiteOpenHelper dbHelper) {\n         ((SqlNormalizedCache) this).allColumns = new String[]{\"_id\", \"key\", \"record\"};\n         ((SqlNormalizedCache) this).recordFieldAdapter = recordFieldAdapter;\n         ((SqlNormalizedCache) this).dbHelper = dbHelper;\n         ((SqlNormalizedCache) this).database = dbHelper.getWritableDatabase();\n         ((SqlNormalizedCache) this).insertStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.INSERT_STATEMENT);\n         ((SqlNormalizedCache) this).updateStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.UPDATE_STATEMENT);\n         ((SqlNormalizedCache) this).deleteStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.DELETE_STATEMENT);\n         ((SqlNormalizedCache) this).deleteAllRecordsStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.DELETE_ALL_RECORD_STATEMENT);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.java",
              "file_line": [
                199
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.725-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "50b715e7-3a74-4339-b279-6e848f3123e6",
              "value": "Cls4SSXPI4ZQSB6WLK(RecordFieldJsonAdapter recordFieldAdapter, SQLiteOpenHelper dbHelper) {\n         ((SqlNormalizedCache) this).allColumns = new String[]{\"_id\", \"key\", \"record\"};\n         ((SqlNormalizedCache) this).recordFieldAdapter = recordFieldAdapter;\n         ((SqlNormalizedCache) this).dbHelper = dbHelper;\n         ((SqlNormalizedCache) this).database = dbHelper.getWritableDatabase();\n         ((SqlNormalizedCache) this).insertStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.INSERT_STATEMENT);\n         ((SqlNormalizedCache) this).updateStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.UPDATE_STATEMENT);\n         ((SqlNormalizedCache) this).deleteStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.DELETE_STATEMENT);\n         ((SqlNormalizedCache) this).deleteAllRecordsStatement = ((SqlNormalizedCache) this).database.compileStatement(SqlNormalizedCache.DELETE_ALL_RECORD_STATEMENT);\n     }",
              "vulnerability_id": "76f49cc0-99a6-4525-8310-87148d504872",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.java",
              "file_line": [
                210
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.745-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "40d674a4-7f74-43e9-a96f-83b8f4506cc7",
          "title": "External Result Receiver",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The vulnerability known as &quot;External Result Receiver&quot; in Android involves a significant security risk where exported components improperly handle ResultReceiver objects passed via intents. This issue allows external entities to send intents with ResultReceiver objects to the <b>Noisiv</b> application, which could then be manipulated to execute unintended actions or retrieve sensitive information. The core vulnerability arises from the application&#39;s exported components, which do not adequately validate or restrict the incoming ResultReceiver objects, potentially leading to unauthorized access or control over the application&#39;s internal states and functionalities. This vulnerability underscores the need for strict validation and limitation of exported components in handling intent-based communications. \nThe following code snippet shows the insecure implementation</p>\n",
              "remediation": "<p>The assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Restrict Component Exportation: Modify the application's manifest to ensure that components intended to receive ResultReceiver objects are not exported unless absolutely necessary. Use the android:exported=false attribute to prevent unintended external access.\n</li>\n<li>Implement Intent Validation: Enhance the validation process for incoming intents within the application. Verify any ResultReceiver received through intents to ensure it originates from a trusted source, and confirm that its usage aligns with secure and intended operational parameters.</li>\n</ul>\n",
              "impact": "<p>An attacker can exploit the &quot;External Result Receiver&quot; vulnerability to execute unintended actions within the application or access sensitive information by manipulating ResultReceiver objects sent via intents. This could lead to unauthorized actions being performed, such as altering application data or behavior, which might compromise the app’s functionality and user data security. The ability to intercept and modify these communications also raises concerns about the integrity and confidentiality of the data processed by the application, potentially leading to further security breaches within the system.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>La vulnerabilidad conocida como &quot;External Result Receiver&quot; en Android implica un riesgo de seguridad significativo, ya que los componentes importados controlan inadecuadamente los objetos ResultReceiver que se envían a través de las intenciones. Este problema permite que entidades externas envíen intenciones con objetos ResultReceiver a la aplicación <b>Noisiv</b>, que luego podrían manipularse para llevar a cabo acciones no deseadas o recuperar información sensible. La vulnerabilidad surge de los componentes exportados de la aplicación, que no validan o limitan adecuadamente los objetos ResultReceiver entrantes. Esto podría facilitar el acceso no autorizado y la pérdida de control de los estados y funcionamientos internos de la aplicación. Esta vulnerabilidad resalta la necesidad de una validación y limitación estrictas de los componentes exportados en la comunicación basada en intenciones.\nEl siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Restringir la exportación de componentes: modifique el manifiesto de la aplicación para garantizar que los componentes destinados a recibir objetos ResultReceiver no se exporten a menos que sea absolutamente necesario. Utilice el atributo android:exported=false para evitar el acceso externo no deseado.\n</li>\n<li>Implementar la validación de intenciones: mejore el proceso de validación de intenciones entrantes dentro de la aplicación. Verifique cualquier ResultReceiver recibido a través de intenciones para asegurarse de que provenga de una fuente confiable y confirmar que su uso se alinea con los parámetros operativos seguros previstos.</li>\n</ul>\n",
              "impact": "<p>Un atacante puede aprovechar la vulnerabilidad &quot;External Result Receiver&quot; para llevar a cabo acciones no deseadas dentro de la aplicación o acceder a información sensible manipulando objetos ResultReceiver enviados mediante intenciones. Esto podría dar lugar a que se realicen acciones no autorizadas, como alterar los datos o el comportamiento de la aplicación, y podría comprometer la funcionalidad de la aplicación y la seguridad de los datos de los usuarios. La capacidad de interceptar y modificar estas comunicaciones pone en riesgo la integridad y confidencialidad de los datos procesados por la aplicación y puede generar más violaciones de seguridad dentro del sistema.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "ResultReceiver | Android Developers",
              "url": "https://developer.android.com/reference/android/os/ResultReceiver#send(int,%20android.os.Bundle)"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0084"
          },
          "evidences": [
            {
              "id": "03ddd16d-4a93-4ee2-8782-62f14a543f2e",
              "value": "public Uri getStream(int index) {\n         if (((ShareCompat.IntentReader) this).mStreams == null && isMultipleShare()) {\n             ((ShareCompat.IntentReader) this).mStreams = ((ShareCompat.IntentReader) this).mIntent.getParcelableArrayListExtra(\"android.intent.extra.STREAM\");\n         }\n         if (((ShareCompat.IntentReader) this).mStreams != null) {\n             return (Uri) ((ShareCompat.IntentReader) this).mStreams.get(index);\n         }\n         if (index == 0) {\n             return (Uri) ((ShareCompat.IntentReader) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n         }\n         throw new IndexOutOfBoundsException(\"Stream items available: \" + getStreamCount() + \" index requested: \" + index);\n     }",
              "vulnerability_id": "40d674a4-7f74-43e9-a96f-83b8f4506cc7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/app/ShareCompat$IntentReader.java",
              "file_line": [
                614
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.224-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "35e1af13-530e-49b4-8273-1fbd817240b7",
              "value": "public Uri getStream() {\n         return (Uri) ((ShareCompat.IntentReader) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n     }",
              "vulnerability_id": "40d674a4-7f74-43e9-a96f-83b8f4506cc7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/app/ShareCompat$IntentReader.java",
              "file_line": [
                553
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.209-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3621d2fe-a446-48a0-ad80-88560dad8375",
              "value": "public void onCommand(String command, Bundle extras, ResultReceiver cb) {\n         try {\n             IBinder iBinder = null;\n             if (command.equals(\"android.support.v4.media.session.command.GET_EXTRA_BINDER\")) {\n                 MediaSessionCompat.MediaSessionImplApi21 impl = (MediaSessionCompat.MediaSessionImplApi21) MediaSessionCompat.Callback.access$100(((MediaSessionCompat.Callback.StubApi21) this).this$0).get();\n                 if (impl != null) {\n                     Bundle result = new Bundle();\n                     IMediaSession extraBinder = impl.getSessionToken().getExtraBinder();\n                     if (extraBinder != null) {\n                         iBinder = extraBinder.asBinder();\n                     }\n                     BundleCompat.putBinder(result, \"android.support.v4.media.session.EXTRA_BINDER\", iBinder);\n                     cb.send(0, result);\n                 }\n             } else if (command.equals(\"android.support.v4.media.session.command.ADD_QUEUE_ITEM\")) {\n                 extras.setClassLoader(MediaDescriptionCompat.class.getClassLoader());\n                 ((MediaSessionCompat.Callback.StubApi21) this).this$0.onAddQueueItem(extras.getParcelable(\"android.support.v4.media.session.command.ARGUMENT_MEDIA_DESCRIPTION\"));\n             } else if (command.equals(\"android.support.v4.media.session.command.ADD_QUEUE_ITEM_AT\")) {\n                 extras.setClassLoader(MediaDescriptionCompat.class.getClassLoader());\n                 ((MediaSessionCompat.Callback.StubApi21) this).this$0.onAddQueueItem(extras.getParcelable(\"android.support.v4.media.session.command.ARGUMENT_MEDIA_DESCRIPTION\"), extras.getInt(\"android.support.v4.media.session.command.ARGUMENT_INDEX\"));\n             } else if (command.equals(\"android.support.v4.media.session.command.REMOVE_QUEUE_ITEM\")) {\n                 extras.setClassLoader(MediaDescriptionCompat.class.getClassLoader());\n                 ((MediaSessionCompat.Callback.StubApi21) this).this$0.onRemoveQueueItem(extras.getParcelable(\"android.support.v4.media.session.command.ARGUMENT_MEDIA_DESCRIPTION\"));\n             } else if (command.equals(\"android.support.v4.media.session.command.REMOVE_QUEUE_ITEM_AT\")) {\n                 MediaSessionCompat.MediaSessionImplApi21 impl2 = (MediaSessionCompat.MediaSessionImplApi21) MediaSessionCompat.Callback.access$100(((MediaSessionCompat.Callback.StubApi21) this).this$0).get();\n                 if (impl2 != null && MediaSessionCompat.MediaSessionImplApi21.access$200(impl2) != null) {\n                     int index = extras.getInt(\"android.support.v4.media.session.command.ARGUMENT_INDEX\", -1);\n                     if (index >= 0 && index < MediaSessionCompat.MediaSessionImplApi21.access$200(impl2).size()) {\n                         iBinder = (MediaSessionCompat.QueueItem) MediaSessionCompat.MediaSessionImplApi21.access$200(impl2).get(index);\n                     }\n                     if (iBinder != null) {\n                         ((MediaSessionCompat.Callback.StubApi21) this).this$0.onRemoveQueueItem(iBinder.getDescription());\n                     }\n                 }\n             } else {\n                 ((MediaSessionCompat.Callback.StubApi21) this).this$0.onCommand(command, extras, cb);\n             }\n         } catch (BadParcelableException e) {\n             Log.e(\"MediaSessionCompat\", \"Could not unparcel the extra data.\");\n         }\n     }",
              "vulnerability_id": "40d674a4-7f74-43e9-a96f-83b8f4506cc7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaSessionCompat$Callback$StubApi21.java",
              "file_line": [
                114
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.323-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "971ec895-1864-461b-b104-f2954b0e3785",
              "value": "public ShareCompat.IntentBuilder addStream(Uri streamUri) {\n         Uri currentStream = (Uri) ((ShareCompat.IntentBuilder) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n         if (((ShareCompat.IntentBuilder) this).mStreams == null && currentStream == null) {\n             return setStream(streamUri);\n         }\n         if (((ShareCompat.IntentBuilder) this).mStreams == null) {\n             ((ShareCompat.IntentBuilder) this).mStreams = new ArrayList();\n         }\n         if (currentStream != null) {\n             ((ShareCompat.IntentBuilder) this).mIntent.removeExtra(\"android.intent.extra.STREAM\");\n             ((ShareCompat.IntentBuilder) this).mStreams.add(currentStream);\n         }\n         ((ShareCompat.IntentBuilder) this).mStreams.add(streamUri);\n         return this;\n     }",
              "vulnerability_id": "40d674a4-7f74-43e9-a96f-83b8f4506cc7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/app/ShareCompat$IntentBuilder.java",
              "file_line": [
                388
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.195-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "329c0b7d-76f2-48a8-9fe9-a4fea4a4c686",
              "value": "public static KeyEvent handleIntent(MediaSessionCompat mediaSessionCompat, Intent intent) {\n         if (mediaSessionCompat == null || intent == null || !\"android.intent.action.MEDIA_BUTTON\".equals(intent.getAction()) || !intent.hasExtra(\"android.intent.extra.KEY_EVENT\")) {\n             return null;\n         }\n         KeyEvent ke = (KeyEvent) intent.getParcelableExtra(\"android.intent.extra.KEY_EVENT\");\n         MediaControllerCompat mediaController = mediaSessionCompat.getController();\n         mediaController.dispatchMediaButtonEvent(ke);\n         return ke;\n     }",
              "vulnerability_id": "40d674a4-7f74-43e9-a96f-83b8f4506cc7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaButtonReceiver.java",
              "file_line": [
                386
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.290-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "33b9c26b-c6dc-4039-90f6-8cd7ba5f335c",
              "value": "public static ComponentName getCallingActivity(Activity calledActivity) {\n         ComponentName result = calledActivity.getCallingActivity();\n         if (result == null) {\n             return (ComponentName) calledActivity.getIntent().getParcelableExtra(\"android.support.v4.app.EXTRA_CALLING_ACTIVITY\");\n         }\n         return result;\n     }",
              "vulnerability_id": "40d674a4-7f74-43e9-a96f-83b8f4506cc7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/app/ShareCompat.java",
              "file_line": [
                206
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.248-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b9fe3c73-3e5a-4432-8fe5-89f5360ab7cb",
              "value": "public boolean onMediaButtonEvent(Intent mediaButtonEvent) {\n         KeyEvent keyEvent;\n         MediaSessionCompat.MediaSessionImpl impl = (MediaSessionCompat.MediaSessionImpl) ((MediaSessionCompat.Callback) this).mSessionImpl.get();\n         if (impl == null || ((MediaSessionCompat.Callback) this).mCallbackHandler == null || (keyEvent = (KeyEvent) mediaButtonEvent.getParcelableExtra(\"android.intent.extra.KEY_EVENT\")) == null || keyEvent.getAction() != 0) {\n             return false;\n         }\n         int keyCode = keyEvent.getKeyCode();\n         if (keyCode == 79 || keyCode == 85) {\n             if (keyEvent.getRepeatCount() > 0) {\n                 handleMediaPlayPauseKeySingleTapIfPending();\n             } else if (((MediaSessionCompat.Callback) this).mMediaPlayPauseKeyPending) {\n                 ((MediaSessionCompat.Callback) this).mCallbackHandler.removeMessages(1);\n                 ((MediaSessionCompat.Callback) this).mMediaPlayPauseKeyPending = false;\n                 PlaybackStateCompat state = impl.getPlaybackState();\n                 long validActions = state == null ? 0L : state.getActions();\n                 if ((32 & validActions) != 0) {\n                     onSkipToNext();\n                 }\n             } else {\n                 ((MediaSessionCompat.Callback) this).mMediaPlayPauseKeyPending = true;\n                 ((MediaSessionCompat.Callback) this).mCallbackHandler.sendEmptyMessageDelayed(1, ViewConfiguration.getDoubleTapTimeout());\n             }\n             return true;\n         }\n         handleMediaPlayPauseKeySingleTapIfPending();\n         return false;\n     }",
              "vulnerability_id": "40d674a4-7f74-43e9-a96f-83b8f4506cc7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaSessionCompat$Callback.java",
              "file_line": [
                415
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.345-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8bd3fd72-c399-41ea-b537-7de620753b25",
              "value": "public void onConnected() {\n         try {\n             MediaControllerCompat mediaController = new MediaControllerCompat(((MediaButtonReceiver.MediaButtonConnectionCallback) this).mContext, ((MediaButtonReceiver.MediaButtonConnectionCallback) this).mMediaBrowser.getSessionToken());\n             KeyEvent ke = (KeyEvent) ((MediaButtonReceiver.MediaButtonConnectionCallback) this).mIntent.getParcelableExtra(\"android.intent.extra.KEY_EVENT\");\n             mediaController.dispatchMediaButtonEvent(ke);\n         } catch (RemoteException e) {\n             Log.e(\"MediaButtonReceiver\", \"Failed to create a media controller\", e);\n         }\n         finish();\n     }",
              "vulnerability_id": "40d674a4-7f74-43e9-a96f-83b8f4506cc7",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaButtonReceiver$MediaButtonConnectionCallback.java",
              "file_line": [
                93
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.264-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "6af2df4e-e0f5-478c-9e7d-7c992f2e6c82",
          "title": "Content Provider Leak",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Noisiv</b> implements a Content Provider that may allow unauthorized access or data manipulation. Content Providers enable structured data sharing between applications, but if not properly configured, they can expose sensitive data or allow unintended modifications.</p>\n<p>Improper permission handling, insecure URI grants, or unintended data exposure could lead to unauthorized access, affecting both data confidentiality and integrity. This issue may be further exploited if the application lacks proper validation when processing external requests.</p>\n",
              "remediation": "<p>The assessment team recommends ensuring that Content Providers are not unintentionally exposed by explicitly setting android:exported=&quot;false&quot; in the application&#39;s manifest for components that should not be accessed externally. If external access is required, appropriate permissions must be enforced using android:permission, android:readPermission, and android:writePermission.</p>\n<p>Additionally, developers should validate and sanitize all incoming data to prevent unauthorized access or modifications. When granting URI permissions, the use of FLAG_GRANT_READ_URI_PERMISSION and FLAG_GRANT_WRITE_URI_PERMISSION should be restricted to trusted applications. Finally, avoid reflecting attacker-controlled data in result intents, as this could be leveraged to manipulate application behavior.</p>\n",
              "impact": "<p>An attacker could exploit this issue to:</p>\n<ul>\n<li>Access sensitive data stored in the Content Provider, potentially exposing confidential user information.</li>\n<li>Modify or delete records, impacting data integrity and application functionality.</li>\n<li>Gain unauthorized privileges by exploiting weak URI permissions or permission misconfigurations.</li>\n<li>Manipulate application behavior, potentially leading to unintended actions or privilege escalation.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Noisiv</b> implementa un Proveedor de contenido que puede permitir el acceso no autorizado o la manipulación de datos. Los proveedores de contenido permiten compartir datos estructurados entre aplicaciones, pero si no se configuran correctamente, pueden exponer datos confidenciales o permitir modificaciones no deseadas.</p>\n<p>La gestión inadecuada de permisos, las concesiones de URI inseguras o la exposición no intencionada de los datos podrían provocar un acceso no autorizado, lo que afectaría tanto a la confidencialidad como a la integridad de los datos. Este problema puede explotarse aún más si la aplicación carece de una validación adecuada al procesar solicitudes externas.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda garantizar que los proveedores de contenido no queden expuestos involuntariamente configurando explícitamente android:exported=&quot;false&quot; en el manifiesto de la aplicación para los componentes a los que no se debe acceder externamente. Si se requiere acceso externo, se deben aplicar los permisos adecuados mediante android:permission, android:readPermission y android:writePermission.</p>\n<p>Además, los desarrolladores deben validar y desinfectar todos los datos entrantes para evitar modificaciones o accesos no autorizados. Al otorgar permisos URI, el uso de FLAG_GRANT_READ_URI_PERMISSION y FLAG_GRANT_WRITE_URI_PERMISSION debe restringirse a aplicaciones confiables. Por último, evite reflejar datos controlados por el atacante en los resultados, ya que esto podría aprovecharse para manipular el comportamiento de la aplicación.</p>\n",
              "impact": "<p>Un atacante podría aprovechar este problema para:</p>\n<ul>\n<li>Acceder a datos confidenciales almacenados en el Proveedor de contenido, exponiendo potencialmente información confidencial del usuario.</li>\n<li>Modificar o eliminar registros, lo que afecta la integridad de los datos y la funcionalidad de la aplicación.</li>\n<li>Obtenga privilegios no autorizados explotando permisos de URI débiles o configuraciones incorrectas de permisos.</li>\n<li>Manipular el comportamiento de las aplicaciones, lo que podría provocar acciones no deseadas o una escalada de privilegios.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#content-providers"
            },
            {
              "label": "Getting a Result from an Activity | Android Developers",
              "url": "https://developer.android.com/training/basics/intents/result?hl=es-419"
            },
            {
              "label": "Content Provider Basics | Android Developers",
              "url": "https://developer.android.com/guide/topics/providers/content-provider-basics?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0064"
          },
          "evidences": [
            {
              "id": "70f58c77-c10f-425d-b90e-7543440c4db4",
              "value": "private void setResultAndFinish(String filePath) {\n         Intent data = new Intent();\n         data.putExtra(\"result_file_path\", filePath);\n         setResult(-1, data);\n         finish();\n     }",
              "vulnerability_id": "6af2df4e-e0f5-478c-9e7d-7c992f2e6c82",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/nbsp/materialfilepicker/ui/FilePickerActivity.java",
              "file_line": [
                687
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.866-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "f29f63bd-304e-4013-bfff-d187a02958d1",
          "title": "Android Start Internal Components",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Noisiv</b> may improperly start internal components (activities or services) via implicit intents, potentially exposing sensitive functionality to unauthorized applications.</p>\n<p>Android applications often use methods like startActivity(), startActivityForResult(), and startService() to launch internal components. If these methods handle unvalidated intents, an attacker could craft a malicious intent to trigger unintended behaviors, interact with private components, or manipulate application logic.</p>\n<p>Additionally, if getParcelableExtra() is used without strict validation, an attacker could inject a malformed or unauthorized Parcelable object, potentially leading to unintended data processing or security risks.</p>\n",
              "remediation": "<p>The assessment team recommends the following mitigations to reduce the risks associated with insecure component invocation:</p>\n<ul>\n<li>Use explicit intents whenever possible: Restrict inter-component communication to explicitly defined targets to prevent unintended access by other applications.</li>\n<li>Validate all incoming intents: Ensure that every received intent is checked for its origin, expected parameters, and content integrity before processing.</li>\n<li>Restrict exported components: In the AndroidManifest.xml file, set android:exported=\"false\" for components that do not need to be accessed by external applications.</li>\n<li>Apply permission-based access control: If an internal component must be accessible externally, enforce strict access control via custom permissions (android:permission) to limit who can interact with it.</li>\n<li>Sanitize getParcelableExtra() inputs: Ensure that only expected Parcelable objects are processed, rejecting unexpected or malformed inputs.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit this issue to:</p>\n<ul>\n<li>Trigger unintended application behavior: If an internal component (such as an activity or service) is started improperly, it might perform unintended actions, such as navigating to a restricted screen or executing a function that was meant to be internal.</li>\n<li>Access sensitive data through exposed components: If an internal activity or service is unintentionally accessible, an attacker may extract sensitive information by interacting with it in ways not originally intended by the developers.</li>\n<li>Manipulate inter-component communication: If the application relies on intents to exchange data between components, an attacker might craft a malicious intent to manipulate this communication, leading to incorrect processing of user data or system functions.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Noisiv</b> puede iniciar incorrectamente componentes internos (actividades o servicios) a través de intenciones implícitas, exponiendo potencialmente funcionalidades confidenciales a aplicaciones no autorizadas.</p>\n<p>Las aplicaciones de Android suelen utilizar métodos como startActivity(), startActivityForResult() y startService() para iniciar componentes internos. Si estos métodos manejan intenciones no validadas, un atacante podría crear una intención maliciosa para desencadenar comportamientos no deseados, interactuar con componentes privados o manipular la lógica de la aplicación.</p>\n<p>Además, si se utiliza getParcelableExtra() sin una validación estricta, un atacante podría inyectar un objeto Parcelable con formato incorrecto o no autorizado, lo que podría provocar un procesamiento de datos no deseado o riesgos de seguridad.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes mitigaciones para reducir los riesgos asociados con la invocación de componentes inseguros:</p>\n<ul>\n<li>Utilice intenciones explícitas siempre que sea posible: restrinja la comunicación entre componentes a objetivos definidos explícitamente para evitar el acceso no deseado de otras aplicaciones.</li>\n<li>Validar todos los intents entrantes: asegúrese de que se verifique el origen, los parámetros esperados y la integridad del contenido de cada intent recibido antes de procesarlo.</li>\n<li>Restringir los componentes exportados: en el archivo AndroidManifest.xml, configure android:exported=\"false\" para los componentes a los que no es necesario acceder mediante aplicaciones externas.</li>\n<li>Aplique control de acceso basado en permisos: si un componente interno debe ser accesible externamente, aplique un control de acceso estricto a través de permisos personalizados (android:permiso) para limitar quién puede interactuar con él.</li>\n<li>Desinfectar las entradas getParcelableExtra(): asegúrese de que solo se procesen los objetos Parcelable esperados, rechazando las entradas inesperadas o con formato incorrecto.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar este problema para:</p>\n<ul>\n<li>Desencadenar un comportamiento no deseado de la aplicación: si un componente interno (como una actividad o servicio) se inicia incorrectamente, podría realizar acciones no deseadas, como navegar a una pantalla restringida o ejecutar una función que estaba destinada a ser interna.</li>\n<li>Acceder a datos confidenciales a través de componentes expuestos: si se puede acceder involuntariamente a una actividad o servicio interno, un atacante puede extraer información confidencial interactuando con ella de maneras no previstas originalmente por los desarrolladores.</li>\n<li>Manipular la comunicación entre componentes: si la aplicación se basa en intentos de intercambiar datos entre componentes, un atacante podría idear una intención maliciosa para manipular esta comunicación, lo que llevaría a un procesamiento incorrecto de los datos del usuario o de las funciones del sistema.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#intents"
            },
            {
              "label": "Intent Redirection | Security | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/intent-redirection?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "b5e5b3c2-9f12-4c42-8f25-7494ccc74c69",
              "value": "private static void startForegroundService(Context context, Intent intent) {\n         if (Build.VERSION.SDK_INT >= 26) {\n             context.startForegroundService(intent);\n         } else {\n             context.startService(intent);\n         }\n     }",
              "vulnerability_id": "f29f63bd-304e-4013-bfff-d187a02958d1",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaButtonReceiver.java",
              "file_line": [
                433
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.151-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "17166b8a-85ce-4de2-9ba4-ae08e6792a2c",
              "value": "public void startChooser() {\n         ((ShareCompat.IntentBuilder) this).mActivity.startActivity(createChooserIntent());\n     }",
              "vulnerability_id": "f29f63bd-304e-4013-bfff-d187a02958d1",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/app/ShareCompat$IntentBuilder.java",
              "file_line": [
                891
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.134-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
          "title": "Memory Corruption",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Noisiv</b> utilizes native methods within its codebase. Native methods, often written in languages like C or C++, are integrated into Android applications to enhance performance or access specific hardware features. However, these languages are prone to memory management issues, such as buffer overflows, use-after-free errors, and null pointer dereferences, which can lead to memory corruption vulnerabilities. Such vulnerabilities can compromise the application&#39;s stability and security, potentially allowing attackers to execute arbitrary code or escalate privileges.</p>\n",
              "remediation": "<p>The assessment team recommends the following measures to mitigate memory corruption risks:</p>\n<ul>\n<li>Adopt Memory-Safe Languages: Utilize languages like Java or Kotlin for application development, minimizing direct memory management.​</li>\n<li>Implement Secure Coding Practices: When native code is necessary, adhere to secure coding standards, such as input validation and proper memory handling.​</li>\n<li>Enable Compiler Security Features: Use compiler options like _FORTIFY_SOURCE to detect and prevent buffer overflows and other memory issues at compile-time or runtime. ​</li>\n<li>Apply Address Space Layout Randomization (ASLR): Ensure ASLR is enabled to randomize memory addresses, making exploitation more challenging.</li>\n</ul>\n",
              "impact": "<p>Exploitation of memory corruption vulnerabilities can result in:</p>\n<ul>\n<li>Remote Code Execution (RCE): Attackers may execute arbitrary code within the application's context, leading to unauthorized actions or data breaches.​</li>\n<li>Denial of Service (DoS): Memory corruption can cause application crashes or instability, disrupting service availability.​</li>\n<li>Privilege Escalation: Attackers might gain elevated privileges, accessing restricted areas of the system or other applications' data.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Noisiv</b> utiliza métodos nativos dentro de su código base. Los métodos nativos, a menudo escritos en lenguajes como C o C++, se integran en aplicaciones de Android para mejorar el rendimiento o acceder a funciones de hardware específicas. Sin embargo, estos lenguajes son propensos a sufrir problemas de gestión de la memoria, como desbordamientos del búfer, errores de uso después de la liberación y desreferencias de puntero nulo, lo que puede provocar vulnerabilidades de corrupción de la memoria. Estas vulnerabilidades pueden comprometer la estabilidad y la seguridad de la aplicación, permitiendo potencialmente a los atacantes ejecutar código arbitrario o escalar privilegios.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes medidas para mitigar los riesgos de corrupción de la memoria:</p>\n<ul>\n<li>Adopte lenguajes seguros para la memoria: utilice lenguajes como Java o Kotlin para el desarrollo de aplicaciones, minimizando la administración directa de la memoria.</li>\n<li>Implementar prácticas de codificación segura: cuando sea necesario el código nativo, cumpla con los estándares de codificación segura, como la validación de entradas y el manejo adecuado de la memoria.</li>\n<li>Habilite las funciones de seguridad del compilador: use opciones del compilador como _FORTIFY_SOURCE para detectar y evitar desbordamientos del búfer y otros problemas de memoria en tiempo de compilación o ejecución. ​</li>\n<li>Aplicar aleatorización del diseño del espacio de direcciones (ASLR): asegúrese de que ASLR esté habilitado para aleatorizar las direcciones de memoria, lo que hace que la explotación sea más desafiante.</li>\n</ul>\n",
              "impact": "<p>La explotación de vulnerabilidades de corrupción de memoria puede resultar en:</p>\n<ul>\n<li>Ejecución remota de código (RCE): los atacantes pueden ejecutar código arbitrario dentro del contexto de la aplicación, lo que lleva a acciones no autorizadas o violaciones de datos.</li>\n<li>Denegación de servicio (DoS): la corrupción de la memoria puede provocar fallos o inestabilidad de las aplicaciones, lo que altera la disponibilidad del servicio.</li>\n<li>Escalada de privilegios: los atacantes pueden obtener privilegios elevados, accediendo a áreas restringidas del sistema o a datos de otras aplicaciones.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Native Memory Usage Debugging | Android Open Source Project",
              "url": "https://source.android.com/docs/core/tests/debug/native-memory?hl=es"
            },
            {
              "label": "Use of Native Code | Security | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/use-of-native-code?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-3",
            "maswe": "MASWE-0116"
          },
          "evidences": [
            {
              "id": "593f3cc6-db9c-4fed-a7af-3bca217f0d0b",
              "value": "private static native int getDuration(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                274
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.315-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b85b2bb4-3199-4df5-a20c-ec2122090807",
              "value": "private static native int getNativeErrorCode(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                289
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.393-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "bdbeb418-f59e-43b6-8f80-821b0ecee9bb",
              "value": "private static native void glTexImage2D(long j, int i, int i2);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                350
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.486-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "bb116d7a-649b-4677-8bf4-a40406070fbc",
              "value": "private static native boolean isAnimationCompleted(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                359
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.528-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "07a960c4-7d99-403c-8e5c-8ffdfa0f71b6",
              "value": "private static native void postUnbindSurface(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                548
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.576-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c0d756e7-1efc-480c-a955-458a94cbebc7",
              "value": "private static native long getAllocationByteCount(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                259
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.238-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "672a1ae5-00cb-473c-b4d5-382a1bef431a",
              "value": "private static native String getComment(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                262
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.252-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d1797601-5a67-450e-8276-8a7462f25901",
              "value": "private static native int getCurrentFrameIndex(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                265
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.273-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "17f538dc-7c51-45c9-b5e7-1ab04bc0d009",
              "value": "private static native long getMetadataByteCount(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                286
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.379-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2a376728-adfd-4b08-8275-740e0fc01654",
              "value": "private static native long[] getSavedState(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                341
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.433-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "686dc903-1d71-4043-85f7-018f4d918f2b",
              "value": "private static native void initTexImageDescriptor(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                356
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.514-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "df28d5a4-c0d1-42ce-b89a-e9c035eb65cf",
              "value": "private static native long restoreRemainder(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                557
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.642-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "05e6d5c7-bef4-4893-ab90-43a429467907",
              "value": "private static native int restoreSavedState(long j, long[] jArr, Bitmap bitmap);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                560
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.657-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "809156ea-ddeb-42a2-bd03-0159234d870a",
              "value": "private static native void seekToFrameGL(long j, int i);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                569
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.706-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "128d66c3-306c-4401-9424-58ab09e852d3",
              "value": "private static native void setSpeedFactor(long j, float f);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                581
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.785-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4137364d-1fa6-4543-b3c7-06ad82d9d063",
              "value": "private static native void stopDecoderThread(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                587
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.825-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8f957e02-06c8-4d04-a53a-0af20a19ef5d",
              "value": "private static native void bindSurface(long j, Surface surface, long[] jArr);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                237
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.210-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "82b63494-89a2-48e7-aaee-60d51fa4c368",
              "value": "private static native int getCurrentLoop(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                268
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.286-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "79eb5895-7e08-4306-9636-fe98c07b3cd9",
              "value": "private static native int getHeight(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                280
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.350-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "cbecc1ae-8e95-46c8-a6fc-29957abafa3d",
              "value": "private static native long getSourceLength(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                344
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.447-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "24af70b1-cdd0-47c4-ba79-a83e711fe1dc",
              "value": "private static native long renderFrame(long j, Bitmap bitmap);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                551
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.591-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "47bf551b-7377-4a15-bb97-bbedd1502a5a",
              "value": "private static native boolean reset(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                554
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.618-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "cc8bf2bf-6267-45f1-9ecd-c88fe0e66415",
              "value": "private static native void seekToTime(long j, int i, Bitmap bitmap);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                572
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.719-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "53f0ff2a-d43c-4143-91d4-428de8057d2c",
              "value": "private static native void setLoopCount(long j, char c);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                575
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.743-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b721b71e-a2fa-4fe7-9660-7553c2edfe66",
              "value": "private static native void startDecoderThread(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                584
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.802-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b69e7f1d-9f6f-4785-be0f-93510ac56390",
              "value": "private static native void free(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                256
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.223-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e88ef8ef-9fac-46ee-b48c-999e1b164ef9",
              "value": "private static native int getCurrentPosition(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                271
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.300-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "646e3587-39fb-4796-a9ae-b4ccc5f4ed3d",
              "value": "private static native int getFrameDuration(long j, int i);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                277
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.335-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "967e8f64-570e-48c5-a475-b2715309a5f2",
              "value": "private static native int getLoopCount(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                283
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.365-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e62b7deb-1f78-4496-a5c0-1d66ebe67791",
              "value": "private static native int getNumberOfFrames(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                338
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.417-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f243d4df-1157-41f0-b529-352df38e859d",
              "value": "private static native int getWidth(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                347
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.462-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4ed05343-b791-4c51-b1f1-9b92ff197f32",
              "value": "private static native void glTexSubImage2D(long j, int i, int i2);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                353
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.500-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7d85df51-c085-419c-a522-ba1d8dd91726",
              "value": "private static native boolean isOpaque(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                362
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.548-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b351259f-a4f4-431a-bba2-1cb3ff25cb3c",
              "value": "static native long openNativeFileDescriptor(int i, long j) throws GifIOException;",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                456
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.561-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "33cf3a43-cb1e-45b7-afa8-04be310e5532",
              "value": "private static native void saveRemainder(long j);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                563
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.677-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "63a30741-e9e0-462f-b41a-956c76e6b9d4",
              "value": "private static native void seekToFrame(long j, int i, Bitmap bitmap);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                566
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.692-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d2a059db-8551-453a-a639-c6ced4969c11",
              "value": "private static native void setOptions(long j, char c, boolean z);",
              "vulnerability_id": "c18fbf68-7415-4f3e-b0b2-396ecf81eb25",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/pl/droidsonroids/gif/GifInfoHandle.java",
              "file_line": [
                578
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.764-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "5922c727-9a04-4681-8fa9-1c58d3256b7f",
          "title": "Arbitrary File Theft",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Noisiv</b> may expose sensitive files through improper use of the external cache directory (externalCacheDir).</p>\n<p>Android applications typically use externalCacheDir to temporarily store data, such as images or documents retrieved from external sources (e.g., camera, file manager). These actions are triggered using implicit intents via startActivityForResult(), which means the application waits for the external app (e.g., camera, file manager) to respond with a URI pointing to the requested file along with a status code.</p>\n<p>If the implementation of onActivityResult() does not properly validate received intents, the application may accept and process intents from any app. Furthermore, if the URI is not validated correctly, the application may blindly trust attacker-supplied URIs. A malicious application can exploit this behavior by injecting a manipulated intent targeting the victim application&#39;s internal files, causing <b>Noisiv</b> to buffer its own internal files (such as authentication tokens or user data) into externalCacheDir, effectively exposing them to unauthorized access.</p>\n<p>Since externalCacheDir is stored in external storage (/storage/emulated/0/Android/data/<b>Noisiv</b>/cache), it is publicly accessible to any application with READ_EXTERNAL_STORAGE permissions.</p>\n",
              "remediation": "<p>The assessment team recommends the following mitigations to prevent unauthorized access to private files through external cache storage:</p>\n<ul>\n<li>Use internal storage (getCacheDir()) instead of externalCacheDir: Store sensitive temporary files in internal storage, which is private to the application.</li>\n<li>Enforce strict validation of intent data: Ensure that incoming intents (e.g., from startActivityForResult()) are properly validated and restricted to prevent unauthorized file manipulations.</li>\n<li>Implement Scoped Storage: If external storage must be used, follow Scoped Storage best practices to limit file access to the application’s own directory and prevent exposure to third-party apps.</li>\n<li>Regularly clear externalCacheDir: Automatically delete temporary files in externalCacheDir once they are no longer needed to minimize the exposure window.</li>\n<li>Restrict storage permissions: Avoid requesting READ_EXTERNAL_STORAGE or WRITE_EXTERNAL_STORAGE unless absolutely necessary.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit this vulnerability to:</p>\n<ul>\n<li>Access sensitive application data: Private files, including authentication tokens, session cookies, or user-generated content, may be exposed if stored temporarily in externalCacheDir.</li>\n<li>Extract internal configuration files: If the application unintentionally buffers internal files in external storage, an attacker could retrieve them and analyze them for further exploitation.</li>\n<li>Bypass Android’s storage security model: This technique allows an attacker to indirectly access files stored in the app's private directory (/data/user/0/<b>Noisiv</b>), circumventing direct access restrictions.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Noisiv</b> puede exponer archivos confidenciales mediante el uso inadecuado del directorio de caché externo (externalCacheDir).</p>\n<p>Las aplicaciones de Android suelen utilizar externalCacheDir para almacenar temporalmente datos, como imágenes o documentos recuperados de fuentes externas (por ejemplo, cámara, administrador de archivos). Estas acciones se activan mediante intenciones implícitas a través de startActivityForResult(), lo que significa que la aplicación espera a que la aplicación externa (por ejemplo, cámara, administrador de archivos) responda con un URI que apunte al archivo solicitado junto con un código de estado.</p>\n<p>Si la implementación de onActivityResult() no valida adecuadamente los intents recibidos, la aplicación puede aceptar y procesar intents desde cualquier aplicación. Además, si el URI no se valida correctamente, la aplicación puede confiar ciegamente en los URI proporcionados por el atacante. Una aplicación maliciosa puede aprovechar este comportamiento inyectando una intención manipulada dirigida a los archivos internos de la aplicación víctima, lo que hace que <b>Noisiv</b> guarde sus propios archivos internos (como tokens de autenticación o datos de usuario) en externalCacheDir, exponiéndolos efectivamente a acceso no autorizado.</p>\n<p>Dado que externalCacheDir se almacena en un almacenamiento externo (/storage/emulated/0/Android/data/<b>Noisiv</b>/cache), cualquier aplicación con permisos READ_EXTERNAL_STORAGE puede acceder a él públicamente.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes mitigaciones para evitar el acceso no autorizado a archivos privados a través del almacenamiento en caché externo:</p>\n<ul>\n<li>Utilice almacenamiento interno (getCacheDir()) en lugar de externalCacheDir: almacene archivos temporales confidenciales en el almacenamiento interno, que es privado para la aplicación.</li>\n<li>Aplique una validación estricta de los datos de intención: asegúrese de que las intenciones entrantes (por ejemplo, desde startActivityForResult()) estén validadas y restringidas adecuadamente para evitar manipulaciones no autorizadas de archivos.</li>\n<li>Implementar Scoped Storage: si se debe utilizar almacenamiento externo, siga las mejores prácticas de Scoped Storage para limitar el acceso a archivos al propio directorio de la aplicación y evitar la exposición a aplicaciones de terceros.</li>\n<li>Borre periódicamente externalCacheDir: elimine automáticamente los archivos temporales en externalCacheDir una vez que ya no sean necesarios para minimizar la ventana de exposición.</li>\n<li>Restringir los permisos de almacenamiento: evite solicitar READ_EXTERNAL_STORAGE o WRITE_EXTERNAL_STORAGE a menos que sea absolutamente necesario.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar esta vulnerabilidad para:</p>\n<ul>\n<li>Acceda a datos confidenciales de la aplicación: los archivos privados, incluidos los tokens de autenticación, las cookies de sesión o el contenido generado por el usuario, pueden quedar expuestos si se almacenan temporalmente en externalCacheDir.</li>\n<li>Extraer archivos de configuración internos: si la aplicación almacena involuntariamente archivos internos en un almacenamiento externo, un atacante podría recuperarlos y analizarlos para su posterior explotación.</li>\n<li>Omitir el modelo de seguridad de almacenamiento de Android: esta técnica permite a un atacante acceder indirectamente a archivos almacenados en el directorio privado de la aplicación (/data/user/0/<b>Noisiv</b>), eludiendo las restricciones de acceso directo.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "MASTG-TEST-0026: Testing Implicit Intents - Case 1: Arbitrary File Read",
              "url": "https://mas.owasp.org/MASTG/tests/android/MASVS-CODE/MASTG-TEST-0026/#case-1-arbitrary-file-read"
            },
            {
              "label": "Get a result from an activity | Android Developers",
              "url": "https://developer.android.com/training/basics/intents/result"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "a4bca9e9-e238-4b5b-ae75-029691e68670",
              "value": "public void onClick(View view) {\n         if (view != ((MainActivity) this).imageButtonCamera) {\n             if (view == ((MainActivity) this).imageButtonPhoto) {\n                 new MaterialFilePicker().withActivity(this).withRequestCode(2).withTitle(\"Select an Image\").withFilterDirectories(true).start();\n                 return;\n             }\n             return;\n         }\n         Intent imageIntent = new Intent(\"android.media.action.IMAGE_CAPTURE\");\n         if (imageIntent.resolveActivity(getPackageManager()) != null) {\n             startActivityForResult(imageIntent, 1);\n         }\n     }",
              "vulnerability_id": "5922c727-9a04-4681-8fa9-1c58d3256b7f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/datadit/noisiv/MainActivity.java",
              "file_line": [
                794
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.910-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "a5f70d4d-539a-413c-ba8f-c29cf3a270cb",
          "title": "Use of External Storage with Media Types",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Noisiv</b> processes media files using external storage. External storage in Android is publicly accessible, meaning any application with the necessary permissions can read or modify files stored there. If sensitive data is stored or handled insecurely in external storage, the application may be exposed to security risks.</p>\n",
              "remediation": "<p>The assessment team recommends storing sensitive media files in internal storage whenever possible to prevent unauthorized access. Applications targeting Android 10 (API level 29) and above should implement scoped storage to restrict access to external storage. Additionally, it is essential to validate and sanitize files read from external storage to prevent injection attacks and to limit the use of permissions such as READ_EXTERNAL_STORAGE and WRITE_EXTERNAL_STORAGE to only essential cases.</p>\n",
              "impact": "<p>Improper use of external storage can lead to:</p>\n<ul>\n<li>Data Tampering: Malicious applications can modify media files stored in external storage, potentially altering their content.</li>\n<li>Data Leakage: Sensitive information stored in external storage may be accessed by unauthorized applications.</li>\n<li>Code Injection: If the application processes media files from external storage without validation, an attacker could introduce malicious payloads.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Noisiv</b> procesa archivos multimedia utilizando almacenamiento externo. El almacenamiento externo en Android es de acceso público, lo que significa que cualquier aplicación con los permisos necesarios puede leer o modificar los archivos almacenados allí. Si los datos confidenciales se almacenan o manejan de manera insegura en un almacenamiento externo, la aplicación puede quedar expuesta a riesgos de seguridad.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda almacenar archivos multimedia confidenciales en un almacenamiento interno siempre que sea posible para evitar el acceso no autorizado. Las aplicaciones destinadas a Android 10 (nivel de API 29) y superiores deben implementar almacenamiento con alcance para restringir el acceso al almacenamiento externo. Además, es esencial validar y desinfectar los archivos leídos desde el almacenamiento externo para evitar ataques de inyección y limitar el uso de permisos como READ_EXTERNAL_STORAGE y WRITE_EXTERNAL_STORAGE solo a casos esenciales.</p>\n",
              "impact": "<p>El uso inadecuado del almacenamiento externo puede provocar:</p>\n<ul>\n<li>Manipulación de datos: las aplicaciones maliciosas pueden modificar archivos multimedia almacenados en un almacenamiento externo, alterando potencialmente su contenido.</li>\n<li>Fuga de datos: aplicaciones no autorizadas pueden acceder a la información confidencial almacenada en un almacenamiento externo.</li>\n<li>Inyección de código: si la aplicación procesa archivos multimedia desde un almacenamiento externo sin validación, un atacante podría introducir cargas útiles maliciosas.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#external-storage"
            },
            {
              "label": "Sensitive Data Stored in External Storage | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sensitive-data-external-storage"
            },
            {
              "label": "MASTG-TEST-0201: Runtime Use of APIs to Access External Storage | OWASP Mobile Application Security",
              "url": "https://mas.owasp.org/MASTG/tests-beta/android/MASVS-STORAGE/MASTG-TEST-0201/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "a45e026d-10d9-4fe4-8943-29c05f622455",
              "value": "private static long queryForLong(Context context, Uri self, String column, long defaultValue) {\n         ContentResolver resolver = context.getContentResolver();\n         Cursor c = null;\n         try {\n             try {\n                 c = resolver.query(self, new String[]{column}, null, null, null);\n                 if (c.moveToFirst() && !c.isNull(0)) {\n                     return c.getLong(0);\n                 }\n             } catch (Exception e) {\n                 Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             }\n             return defaultValue;\n         } finally {\n             DocumentsContractApi19.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "a5f70d4d-539a-413c-ba8f-c29cf3a270cb",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/provider/DocumentsContractApi19.java",
              "file_line": [
                601
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.044-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8b6dcfdf-3245-44a4-80e6-7e110bd70087",
              "value": "private static String queryForString(Context context, Uri self, String column, String defaultValue) {\n         ContentResolver resolver = context.getContentResolver();\n         Cursor c = null;\n         try {\n             try {\n                 c = resolver.query(self, new String[]{column}, null, null, null);\n                 if (c.moveToFirst() && !c.isNull(0)) {\n                     return c.getString(0);\n                 }\n             } catch (Exception e) {\n                 Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             }\n             return defaultValue;\n         } finally {\n             DocumentsContractApi19.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "a5f70d4d-539a-413c-ba8f-c29cf3a270cb",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/provider/DocumentsContractApi19.java",
              "file_line": [
                738
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.060-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f33f3ba1-76f7-4976-93be-1c14f90775dc",
              "value": "public static Cursor query(ContentResolver resolver, Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, CancellationSignal cancellationSignal) {\n         android.os.CancellationSignal cancellationSignal2;\n         if (Build.VERSION.SDK_INT >= 16) {\n             if (cancellationSignal != null) {\n                 try {\n                     cancellationSignal2 = cancellationSignal.getCancellationSignalObject();\n                 } catch (Exception e) {\n                     if (e instanceof OperationCanceledException) {\n                         throw new android.support.v4.os.OperationCanceledException();\n                     }\n                     throw e;\n                 }\n             } else {\n                 cancellationSignal2 = null;\n             }\n             android.os.CancellationSignal cancellationSignalObj = cancellationSignal2;\n             return resolver.query(uri, projection, selection, selectionArgs, sortOrder, cancellationSignalObj);\n         }\n         if (cancellationSignal != null) {\n             cancellationSignal.throwIfCanceled();\n         }\n         return resolver.query(uri, projection, selection, selectionArgs, sortOrder);\n     }",
              "vulnerability_id": "a5f70d4d-539a-413c-ba8f-c29cf3a270cb",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/content/ContentResolverCompat.java",
              "file_line": [
                114
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.003-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8165ca2b-e477-402a-8c3d-6cb22fae6bca",
              "value": "public DocumentFile[] listFiles() {\n         ContentResolver resolver = ((TreeDocumentFile) this).mContext.getContentResolver();\n         Uri childrenUri = DocumentsContract.buildChildDocumentsUriUsingTree(((TreeDocumentFile) this).mUri, DocumentsContract.getDocumentId(((TreeDocumentFile) this).mUri));\n         ArrayList<Uri> results = new ArrayList<>();\n         Cursor c = null;\n         int i = 0;\n         try {\n             try {\n                 c = resolver.query(childrenUri, new String[]{\"document_id\"}, null, null, null);\n                 while (c.moveToNext()) {\n                     String documentId = c.getString(0);\n                     Uri documentUri = DocumentsContract.buildDocumentUriUsingTree(((TreeDocumentFile) this).mUri, documentId);\n                     results.add(documentUri);\n                 }\n             } catch (Exception e) {\n                 Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             }\n             Uri[] result = (Uri[]) results.toArray(new Uri[results.size()]);\n             DocumentFile[] resultFiles = new DocumentFile[result.length];\n             while (true) {\n                 int i2 = i;\n                 if (i2 >= result.length) {\n                     return resultFiles;\n                 }\n                 resultFiles[i2] = new TreeDocumentFile(this, ((TreeDocumentFile) this).mContext, result[i2]);\n                 i = i2 + 1;\n             }\n         } finally {\n             TreeDocumentFile.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "a5f70d4d-539a-413c-ba8f-c29cf3a270cb",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/provider/TreeDocumentFile.java",
              "file_line": [
                429
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.074-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "728a9cf5-ec41-4d8b-bde6-4f52237869b8",
              "value": "public static boolean exists(Context context, Uri self) {\n         ContentResolver resolver = context.getContentResolver();\n         Cursor c = null;\n         boolean z = false;\n         try {\n             try {\n                 c = resolver.query(self, new String[]{\"document_id\"}, null, null, null);\n                 if (c.getCount() > 0) {\n                     z = true;\n                 }\n             } catch (Exception e) {\n                 Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             }\n             return z;\n         } finally {\n             DocumentsContractApi19.closeQuietly(c);\n         }\n     }",
              "vulnerability_id": "a5f70d4d-539a-413c-ba8f-c29cf3a270cb",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/provider/DocumentsContractApi19.java",
              "file_line": [
                234
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.019-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b8e401f2-3bdb-4e62-8c19-13bdacd6adaf",
              "value": "Cursor getSearchManagerSuggestions(SearchableInfo searchable, String query, int limit) {\n         String authority;\n         if (searchable == null || (authority = searchable.getSuggestAuthority()) == null) {\n             return null;\n         }\n         Uri.Builder uriBuilder = new Uri.Builder().scheme(\"content\").authority(authority).query(\"\").fragment(\"\");\n         String contentPath = searchable.getSuggestPath();\n         if (contentPath != null) {\n             uriBuilder.appendEncodedPath(contentPath);\n         }\n         uriBuilder.appendPath(\"search_suggest_query\");\n         String selection = searchable.getSuggestSelection();\n         String[] selArgs = null;\n         if (selection != null) {\n             selArgs = new String[]{query};\n         } else {\n             uriBuilder.appendPath(query);\n         }\n         String[] selArgs2 = selArgs;\n         if (limit > 0) {\n             uriBuilder.appendQueryParameter(\"limit\", String.valueOf(limit));\n         }\n         Uri uri = uriBuilder.build();\n         return ((SuggestionsAdapter) this).mContext.getContentResolver().query(uri, null, selection, selArgs2, null);\n     }",
              "vulnerability_id": "a5f70d4d-539a-413c-ba8f-c29cf3a270cb",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v7/widget/SuggestionsAdapter.java",
              "file_line": [
                2134
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.090-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "4684fa5c-cd3a-4cd2-9ebe-8193d7b30f1d",
          "title": "Android - AWS Cognito Secret Key Disclosure Within Source Code",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team found an AWS Cognito Key stored locally within the Android <b>Noisiv</b> application. The app is storing sensitive information from AWS configuration (including accessKey, apiKey, secretKey from Prod, QA, Dev, S3Dev, S3Prod, S3Qa) without any encryption. This includes the endpoints associated with those secrets.</p>\n<p>The code snippet below demonstrates the vulnerable implementation:</p>\n",
              "remediation": "<p>To reduce the attack surface, the assessment team recommends the following:</p>\n<p>Avoid Storing Sensitive Information on the Client-Side: Refrain from storing sensitive information, such as AWS Cognito Keys, on the client-side (Android device). If it is necessary for the <b>Noisiv</b> development team to store such information, it should be done securely.</p>\n<p>Use Secure Storage Solutions: Utilize KeyStore functionalities, which offer hardware-backed 256-bit AES encryption, for storing sensitive information securely. Encrypt local information instead of saving it as plain text.</p>\n<p>Remove Compromised Information: Actively remove all potentially compromised sensitive information (Access-Keys, Secret-Keys, API-Keys, SecurityKeys, etc.) from the client-side storage.</p>\n<p>Implement Instance Roles: Consider using instance roles for AWS access instead of storing static Secret Keys within the application. This approach provides a more secure and manageable method of handling AWS credentials.</p>\n",
              "impact": "<p>If an attacker obtains the &#39;AWS Cognito ID&#39; and combines it with the discovered &#39;AWS Cognito Key,&#39; they could potentially launch further attacks. This could enable them to gain unauthorized access or retrieve information from the associated AWS Cognito Endpoints. Such exploitation could lead to significant security breaches, including unauthorized access to sensitive data, manipulation of AWS Cognito resources, and potential data leaks. Addressing this vulnerability is crucial to protect against unauthorized exploitation and safeguard sensitive information.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación encontró una AWS Cognito Key almacenada localmente dentro de la aplicación Android <b>Noisiv</b>. Esta aplicación está almacenando información sensible de la configuración de AWS (incluyendo accessKey, apiKey, secretKey de Prod, QA, Dev, S3Dev, S3Prod, S3Qa) sin ningún tipo de encriptación. Esto incluye los puntos finales asociados con esos secretos.</p>\n<p>El fragmento de código a continuación muestra la implementación vulnerable:</p>\n",
              "remediation": "<p>Para reducir la superficie de ataque, el equipo de evaluación recomienda lo siguiente:</p>\n<p>Evitar Almacenar Información Sensible en el Lado del Cliente: Abstenerse de almacenar información sensible, como las claves de AWS Cognito, en el lado del cliente (dispositivo Android). Si es necesario para el equipo de desarrollo de <b>Noisiv</b> almacenar dicha información, debe hacerse de manera segura.</p>\n<p>Usar Soluciones de Almacenamiento Seguras: Utilizar las funcionalidades de KeyStore, que ofrecen encriptación AES de 256 bits respaldada por hardware, para almacenar información sensible de forma segura. Encriptar la información local en lugar de guardarla como texto plano.</p>\n<p>Eliminar Información Comprometida: Eliminar activamente toda la información sensible potencialmente comprometida (claves de acceso, claves secretas, claves API, claves de seguridad, etc.) del almacenamiento del lado del cliente.</p>\n<p>Implementar Roles de Instancia: Considerar el uso de roles de instancia para el acceso a AWS en lugar de almacenar claves secretas estáticas dentro de la aplicación. Este enfoque proporciona un método más seguro y manejable para manejar las credenciales de AWS.</p>\n",
              "impact": "<p>Si un atacante obtiene el &#39;AWS Cognito ID&#39; y lo combina con el &#39;AWS Cognito Key&#39; descubierto, podría lanzar ataques adicionales. Esto podría permitirles obtener acceso no autorizado o recuperar información de los puntos finales de AWS Cognito asociados. Tal explotación podría llevar a violaciones de seguridad significativas, incluyendo el acceso no autorizado a datos sensibles, la manipulación de recursos de AWS Cognito y posibles fugas de datos. Abordar esta vulnerabilidad es crucial para proteger contra la explotación no autorizada y salvaguardar la información sensible.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "GetAccessKeyInfo - AWS Security Token Service",
              "url": "https://docs.aws.amazon.com/STS/latest/APIReference/API_GetAccessKeyInfo.html"
            },
            {
              "label": "Data Storage on Android - OWASP MASTG",
              "url": "https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage"
            },
            {
              "label": "Sistema Android Keystore  |  Desarrolladores de Android  |  Android Developers",
              "url": "https://developer.android.com/training/articles/keystore?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-AUTH-1",
            "maswe": "MASWE-0005"
          },
          "evidences": [
            {
              "id": "a5a5a6a2-4ef0-4cf3-b755-df36c15a06c4",
              "value": "/* loaded from: classes.dex */\npublic class AWSCredentials {\n    private static final String COGNITO_POOL_ID = \"us-east-1:b82cb567-a0ae-4c4c-9ce1-eb4d87aaab02\";\n    private static final Regions COGNITO_REGION = Regions.US_EAST_1;",
              "vulnerability_id": "4684fa5c-cd3a-4cd2-9ebe-8193d7b30f1d",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/sources/com/datadit/noisiv/AWSCredentials.java",
              "file_line": [
                6
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.466-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "6171fad5-7528-42fb-bbec-b2a1912e91ea",
          "title": "Access External Storage",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>Noisiv</b> application utilizes external storage for reading and writing data. Storing data externally poses a risk as it can be accessed and modified by malicious applications on the same device. This vulnerability can lead to information disclosure, data tampering, or other forms of malicious behavior.</p>\n<p>The code snippet below illustrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends not storing executable files, configuration files, or sensitive user data on the external storage if its possible otherwise it should be strongly encrypted to avoid sensitive information to be disclosed.</p>\n",
              "impact": "<p>An attacker or a malicious application could exploit this vulnerability to access or modify the data stored in the external storage. This unauthorized access or modification could lead to serious security issues, including data breaches, information disclosure, and compromising the integrity of the application&#39;s data.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación <b>Noisiv</b> utiliza almacenamiento externo para leer y escribir datos. El almacenamiento de datos de forma externa representa un riesgo, ya que puede ser accedido y modificado por aplicaciones maliciosas en el mismo dispositivo. Esta vulnerabilidad puede llevar a la divulgación de información, manipulación de datos u otras formas de comportamiento malicioso.</p>\n<p>El fragmento de código a continuación ilustra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda evitar almacenar archivos ejecutables, archivos de configuración o datos sensibles de usuarios en el almacenamiento externo siempre que sea posible. Si es necesario utilizar almacenamiento externo, es crucial emplear encriptación fuerte para prevenir la divulgación de información sensible.</p>\n",
              "impact": "<p>Un atacante o una aplicación maliciosa podría aprovechar esta vulnerabilidad para acceder o modificar los datos almacenados en el almacenamiento externo. Este acceso o modificación no autorizados podrían conducir a graves problemas de seguridad, incluyendo violaciones de datos, divulgación de información y compromiso de la integridad de los datos de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "M2: Insecure Data Storage | OWASP Foundation",
              "url": "https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage"
            },
            {
              "label": "MSTG- Testing Data Storage",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#external-storage"
            },
            {
              "label": "CWE - CWE-921: Storage of Sensitive Data in a Mechanism without Access Control (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/921.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "8ac58643-6b1f-49f5-8537-7123981d3a8b",
              "value": "public static String getStorageState(File path) {\n         if (Build.VERSION.SDK_INT >= 19) {\n             return Environment.getStorageState(path);\n         }\n         try {\n             String canonicalPath = path.getCanonicalPath();\n             String canonicalExternal = Environment.getExternalStorageDirectory().getCanonicalPath();\n             if (canonicalPath.startsWith(canonicalExternal)) {\n                 return Environment.getExternalStorageState();\n             }\n             return \"unknown\";\n         } catch (IOException e) {\n             Log.w(\"EnvironmentCompat\", \"Failed to resolve canonical path: \" + e);\n             return \"unknown\";\n         }\n     }",
              "vulnerability_id": "6171fad5-7528-42fb-bbec-b2a1912e91ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/os/EnvironmentCompat.java",
              "file_line": [
                49
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.102-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1e94d7c7-7793-4d54-a114-4514d2c43faa",
              "value": "private void handleFileClicked(File clickedFile) {\n         if (clickedFile.isDirectory()) {\n             ((FilePickerActivity) this).mCurrentPath = clickedFile.getPath();\n             if (((FilePickerActivity) this).mCurrentPath.equals(\"/storage/emulated\")) {\n                 ((FilePickerActivity) this).mCurrentPath = Environment.getExternalStorageDirectory().getAbsolutePath();\n             }\n             addFragmentToBackStack(((FilePickerActivity) this).mCurrentPath);\n             updateTitle();\n             return;\n         }\n         setResultAndFinish(clickedFile.getPath());\n     }",
              "vulnerability_id": "6171fad5-7528-42fb-bbec-b2a1912e91ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/nbsp/materialfilepicker/ui/FilePickerActivity.java",
              "file_line": [
                150
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.140-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4146d8d7-2598-4e15-840b-1ce65f94a279",
              "value": "public ClsIBGWQQZVMM3QICP() {\n         ((FilePickerActivity) this).mStartPath = Environment.getExternalStorageDirectory().getAbsolutePath();\n         ((FilePickerActivity) this).mCurrentPath = ((FilePickerActivity) this).mStartPath;\n     }",
              "vulnerability_id": "6171fad5-7528-42fb-bbec-b2a1912e91ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/nbsp/materialfilepicker/ui/FilePickerActivity.java",
              "file_line": [
                51
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.117-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "9c722da7-9227-41f2-9a3d-242c4f739d4d",
          "title": "Android - AWS Access ID Disclosure Within Source Code",
          "severity": "low",
          "translations": [
            {
              "description": "<p>The assessment team found an AWS Access ID stored locally within the Android <b>Noisiv</b> application. This app is storing sensitive information from AWS configuration (including accessKey, apiKey, secretKey from Prod, QA, Dev, S3Dev, S3Prod, S3Qa) without any encryption. This includes the endpoints associated with those secrets.</p>\n<p>The code snippet below demonstrates the vulnerable implementation:</p>\n",
              "remediation": "<p>To reduce the attack surface, the assessment team recommends the following:</p>\n<p>Avoid Storing Sensitive Information on the Client-Side: Refrain from storing sensitive information, such as AWS keys, on the client-side (Android device). If it is necessary for the <b>Noisiv</b> development team to store such information, it should be done securely.</p>\n<p>Use Secure Storage Solutions: Utilize the KeyStore functionalities, which offer hardware-backed 256-bit AES encryption, for storing sensitive information securely. Encrypt local information instead of saving it as plain text.</p>\n<p>Remove Compromised Information: Actively remove all potentially compromised sensitive information (Access-Keys, Secret-Keys, API-Keys, SecurityKeys, etc.) from the client-side storage.</p>\n<p>Implement Instance Roles: Consider using instance roles for AWS access instead of storing Secret Keys within the application. This approach provides a more secure and manageable method of handling AWS credentials.</p>\n<p>By implementing these measures, the <b>Noisiv</b> development team can significantly enhance the application&#39;s security posture and protect sensitive data from unauthorized access.</p>\n",
              "impact": "<p>If an attacker obtains the &#39;Secret-Key&#39; and combines it with the discovered &#39;Access-ID,&#39; they could potentially launch further attacks. This could enable them to gain unauthorized access or retrieve information from the associated AWS Endpoints. Such exploitation could result in significant security breaches, including unauthorized access to sensitive data and system resources, potentially leading to more extensive compromise of the application&#39;s infrastructure.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación encontró un AWS Access ID almacenado localmente dentro de la aplicación Android <b>Noisiv</b>. Esta aplicación está almacenando información sensible de la configuración de AWS (incluyendo accessKey, apiKey, secretKey de Prod, QA, Dev, S3Dev, S3Prod, S3Qa) sin ningún tipo de encriptación. Esto incluye los puntos finales asociados con esos secretos.</p>\n<p>El fragmento de código a continuación muestra la implementación vulnerable:</p>\n",
              "remediation": "<p>Para reducir la superficie de ataque, el equipo de evaluación recomienda lo siguiente:</p>\n<p>Evitar Almacenar Información Sensible en el Lado del Cliente: Abstenerse de almacenar información sensible, como las claves de AWS, en el lado del cliente (dispositivo Android). Si es necesario para el equipo de desarrollo de <b>Noisiv</b> almacenar dicha información, debe hacerse de manera segura.</p>\n<p>Usar Soluciones de Almacenamiento Seguras: Utilizar las funcionalidades de KeyStore, que ofrecen encriptación AES de 256 bits respaldada por hardware, para almacenar información sensible de forma segura. Encriptar la información local en lugar de guardarla como texto plano.</p>\n<p>Eliminar Información Comprometida: Eliminar activamente toda la información sensible potencialmente comprometida (claves de acceso, claves secretas, claves API, claves de seguridad, etc.) del almacenamiento del lado del cliente.</p>\n<p>Implementar Roles de Instancia: Considerar el uso de roles de instancia para el acceso a AWS en lugar de almacenar claves secretas dentro de la aplicación. Este enfoque proporciona un método más seguro y manejable para manejar las credenciales de AWS.</p>\n<p>Al implementar estas medidas, el equipo de desarrollo de <b>Noisiv</b> puede mejorar significativamente la postura de seguridad de la aplicación y proteger los datos sensibles contra el acceso no autorizado.</p>\n",
              "impact": "<p>Si un atacante obtiene la &#39;Secret-Key&#39; y la combina con el &#39;Access-ID&#39; descubierto, podría lanzar ataques adicionales. Esto podría permitirles obtener acceso no autorizado o recuperar información de los puntos finales de AWS asociados. Tal explotación podría resultar en violaciones de seguridad significativas, incluyendo el acceso no autorizado a datos sensibles y recursos del sistema, lo que podría llevar a un compromiso más extenso de la infraestructura de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "GetAccessKeyInfo - AWS Security Token Service",
              "url": "https://docs.aws.amazon.com/STS/latest/APIReference/API_GetAccessKeyInfo.html"
            },
            {
              "label": "Data Storage on Android - OWASP MASTG",
              "url": "https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05d-testing-data-storage"
            },
            {
              "label": "Sistema Android Keystore  |  Desarrolladores de Android  |  Android Developers",
              "url": "https://developer.android.com/training/articles/keystore?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-AUTH-1",
            "maswe": "MASWE-0005"
          },
          "evidences": [
            {
              "id": "a7758b9a-65c0-4771-947e-27f264dfcc60",
              "value": "@Override // com.amazonaws.auth.AWSCredentials\n            public String getAWSAccessKeyId() {\n                return \"AKIAIAAJDIQQ3K2WG4QA\";\n            }",
              "vulnerability_id": "9c722da7-9227-41f2-9a3d-242c4f739d4d",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/sources/com/datadit/noisiv/MainActivity.java",
              "file_line": [
                224
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.503-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "17f4d5f9-0b3f-4296-a748-67a119dd1941",
          "title": "Debug Enabled For App [android:debuggable=true]",
          "severity": "low",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>Noisiv</b> application has the &#39;debuggable&#39; flag set to &#39;true&#39; in its <b>AndroidManifest.xml</b> file. Enabling debugging in the application simplifies the process for reverse engineers to analyze it and attach a debugger. This exposes the app to risks such as dumping stack traces and accessing debugging helper classes.</p>\n<p>The flag is evident in the following snippet from the Android Manifest file:</p>\n",
              "remediation": "<p>The assessment team strongly recommends ensuring that the <b>android:debuggable</b> flag is set to &#39;false&#39; when releasing your application. This practice is crucial for maintaining security and preventing unauthorized access or reverse engineering of the app.</p>\n",
              "impact": "<p>Setting the <b>android:debuggable</b> flag to &#39;true&#39; in the application <b>Noisiv</b> allows debugging, which makes it easier for attackers to gain access to secure parts of the application. This setting increases the risk of sensitive functionalities and data being exposed, as it simplifies reverse engineering and unauthorized access.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación <b>Noisiv</b> tiene el &#39;flag&#39; &#39;debuggable&#39; configurado en &#39;true&#39; en su archivo <b>AndroidManifest.xml</b>. Habilitar la depuración en la aplicación facilita a los analistas de ingeniería inversa para analizarla y conectar un depurador. Esto expone la aplicación a riesgos como el volcado de &#39;stack traces&#39; y el acceso a clases de ayuda para la depuración.</p>\n<p>El &#39;flag&#39; se puede ver en el siguiente fragmento del archivo Android Manifest:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda encarecidamente asegurarse de que el &#39;flag&#39; <b>android:debuggable</b> esté configurado en &#39;false&#39; al lanzar su aplicación. Esta práctica es crucial para mantener la seguridad y prevenir el acceso no autorizado o la ingeniería inversa de la app.</p>\n",
              "impact": "<p>Configurar el &#39;flag&#39; <b>android:debuggable</b> en &#39;true&#39; en la aplicación <b>Noisiv</b> permite la depuración, lo que facilita que los atacantes accedan a partes seguras de la aplicación. Esta configuración aumenta el riesgo de que se expongan funcionalidades y datos sensibles, ya que simplifica la ingeniería inversa y el acceso no autorizado.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "android:debuggable  |  App quality  |  Android Developers",
              "url": "https://developer.android.com/topic/security/risks/android-debuggable"
            },
            {
              "label": "Exploiting debuggable android applications | Infosec",
              "url": "https://resources.infosecinstitute.com/topic/android-hacking-security-part-6-exploiting-debuggable-android-applications/"
            },
            {
              "label": "MSTG - Testing Code Quality",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#debuggable-apps"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0067"
          },
          "evidences": [
            {
              "id": "2c3520f7-e29a-41aa-b5d8-36f8c8e02096",
              "value": "<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n    <application android:theme=\"@style/Theme.AppCompat.Light.DarkActionBar\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher_noisiv\" android:debuggable=\"true\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:roundIcon=\"@mipmap/ic_launcher_noisiv_round\">\n        <activity android:theme=\"@style/AppTheme\" android:name=\"com.datadit.noisiv.MainActivity\" android:screenOrientation=\"portrait\" />",
              "vulnerability_id": "17f4d5f9-0b3f-4296-a748-67a119dd1941",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/AndroidManifest.xml",
              "file_line": [],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T20:57:11.948-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "e4ed0eb8-4b82-48ac-bb07-f35b0f5b76ea",
          "title": "Application Allows Execution of Backups",
          "severity": "low",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>android:allowBackup</b> attribute is set to true in the Android Manifest file of the <b>Noisiv</b> application. This setting determines if a user can back up and restore the application&#39;s data. When the backup flag is true, it permits an attacker to extract a backup of the application&#39;s data through adb/USB, even on unrooted devices.</p>\n",
              "remediation": "<p>To prevent unauthorized backup of the app data, set the <b>android:allowBackup</b> attribute to false. By default, the allowBackup setting is enabled if this attribute is not explicitly defined, necessitating manual deactivation. It&#39;s important to regularly review the <b>AndroidManifest.xml</b> file to ensure that the developer framework does not inadvertently include insecure default settings.</p>\n",
              "impact": "<p>Android includes an <b>allowBackup</b> attribute, used to enable the backup of all application data. This attribute is defined in the <b>AndroidManifest.xml</b> file. When its value is set to true, it permits users to back up the application data using the Android Debug Bridge (ADB). However, this setting can potentially expose sensitive data, as it allows for data backup without strong security controls, potentially leading to data leakage or unauthorized access if exploited.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que el atributo <b>android:allowBackup</b> está configurado como true en el archivo Android Manifest de la aplicación <b>Noisiv</b>. Esta configuración determina si los datos de la aplicación pueden ser respaldados y restaurados por el usuario. Cuando el flag allowBackup está en true, permite a un atacante realizar un backup de los datos de la aplicación a través de adb/USB, incluso en dispositivos que no están rooteados.</p>\n",
              "remediation": "<p>Para prevenir el respaldo no autorizado de los datos de la aplicación, configure el atributo <b>android:allowBackup</b> en false. Por defecto, la configuración allowBackup está habilitada si este atributo no se define explícitamente, lo que requiere una desactivación manual. Es importante revisar regularmente el archivo <b>AndroidManifest.xml</b> para asegurarse de que el marco de desarrollo no incluya por error configuraciones predeterminadas inseguras.</p>\n",
              "impact": "<p>Android incluye un atributo llamado <b>allowBackup</b>, utilizado para habilitar el respaldo de todos los datos de una aplicación. Este atributo se define en el archivo <b>AndroidManifest.xml</b>. Cuando su valor está configurado en true, permite a los usuarios respaldar los datos de la aplicación utilizando el Android Debug Bridge (ADB). Sin embargo, esta configuración puede exponer datos sensibles, ya que permite realizar copias de seguridad de datos sin controles de seguridad estrictos, lo que podría llevar a la filtración de datos o acceso no autorizado si se explota.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "MSTG - Testing Backups",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-backups-for-sensitive-data-mstg-storage-8"
            },
            {
              "label": "Back up user data with Auto Backup  |  Android Developers",
              "url": "https://developer.android.com/guide/topics/data/autobackup"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-2",
            "maswe": "MASWE-0003"
          },
          "evidences": [
            {
              "id": "30a00f54-6c1d-470c-a2b6-5b0f3ce5d6a4",
              "value": "<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n    <application android:theme=\"@style/Theme.AppCompat.Light.DarkActionBar\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher_noisiv\" android:debuggable=\"true\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:roundIcon=\"@mipmap/ic_launcher_noisiv_round\">\n        <activity android:theme=\"@style/AppTheme\" android:name=\"com.datadit.noisiv.MainActivity\" android:screenOrientation=\"portrait\" />",
              "vulnerability_id": "e4ed0eb8-4b82-48ac-bb07-f35b0f5b76ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/AndroidManifest.xml",
              "file_line": [],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T20:57:11.171-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "0cf19e22-05df-4876-8e91-d564ca5f17db",
          "title": "Android - S3 Bucket Disclosure Within Source Code",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team&#39;s findings reveal that the <b>Noisiv</b> application contains at least one hard-coded S3 Bucket. Integrating these static credentials into the product introduces significant security concerns. If exploited, such hard-coded elements can lead to unauthorized access, potential breaches in data encryption, or unauthorized communication with external components. Consequently, these vulnerabilities pose a wide array of security risks, necessitating thorough attention and remediation efforts by system administrators and developers.</p>\n<p>The code snippet below demonstrates the insecure implementation:</p>\n",
              "remediation": "<p>The assessment team recommends the following measures to address the vulnerability involving a hard-coded S3 Bucket in the <b>Noisiv</b> application:</p>\n<p>Replace Hard-Coded Credentials: The primary focus should be on identifying and replacing hard-coded credentials within the application&#39;s source code. This key step plays a crucial role in mitigating immediate security risks associated with such vulnerabilities.</p>\n<p>Implement Dynamic Credential Management: It is essential to deploy dynamic credential management solutions. These solutions will securely store credentials and facilitate changes without requiring alterations in the code, thereby enhancing the security and flexibility of the application.</p>\n<p>Regularly Update and Monitor: Maintaining up-to-date software components and establishing a regime of continuous monitoring are critical to detect and prevent potential security breaches or unauthorized access.</p>\n<p>Secure Deployment: Giving priority to deploying the application in a secure environment is vital. This includes ensuring appropriate access controls and firewalls are in place, which helps the application operate within a protected infrastructure and significantly reduces the risk of unauthorized access and security breaches.</p>\n",
              "impact": "<p>The impact of this vulnerability involving a hard-coded S3 Bucket in the <b>Noisiv</b> application is significant. It can potentially lead to unauthorized access, data breaches, and exposure of sensitive information. Exploiting hard-coded credentials in an application severely compromises the confidentiality, integrity, and availability of data and system resources. This vulnerability may result in unauthorized manipulation of system functionality, legal and regulatory consequences, reputational damage, and operational disruptions. Addressing this issue is critical to prevent these severe security risks and maintain the overall security posture of the application.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>Los hallazgos del equipo de evaluación revelan que la aplicación <b>Noisiv</b> contiene al menos un S3 Bucket codificado de forma estática. La integración de estas credenciales estáticas en el producto introduce preocupaciones significativas de seguridad. Si se explotan, tales elementos codificados de forma estática pueden llevar a acceso no autorizado, posibles brechas en la encriptación de datos o comunicación no autorizada con componentes externos. En consecuencia, estas vulnerabilidades representan una amplia gama de riesgos de seguridad, lo que requiere atención y esfuerzos de remediación exhaustivos por parte de los administradores de sistemas y desarrolladores.</p>\n<p>El fragmento de código a continuación muestra la implementación insegura:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes medidas para abordar la vulnerabilidad que implica un S3 Bucket codificado de forma estática en la aplicación <b>Noisiv</b>:</p>\n<p>Reemplazar Credenciales Codificadas: El enfoque principal debe ser identificar y reemplazar las credenciales codificadas dentro del código fuente de la aplicación. Este paso clave juega un papel crucial en la mitigación de los riesgos de seguridad inmediatos asociados con tales vulnerabilidades.</p>\n<p>Implementar Gestión Dinámica de Credenciales: Es esencial desplegar soluciones de gestión dinámica de credenciales. Estas soluciones almacenarán de manera segura las credenciales y facilitarán cambios sin requerir alteraciones en el código, mejorando así la seguridad y flexibilidad de la aplicación.</p>\n<p>Actualizar y Monitorear Regularmente: Mantener los componentes del software actualizados y establecer un régimen de monitoreo continuo son críticos para detectar y prevenir posibles violaciones de seguridad o accesos no autorizados.</p>\n<p>Despliegue Seguro: Dar prioridad al despliegue de la aplicación en un entorno seguro es vital. Esto incluye asegurar que los controles de acceso adecuados y cortafuegos estén en su lugar, lo que ayuda a que la aplicación opere dentro de una infraestructura protegida y reduce significativamente el riesgo de acceso no autorizado y violaciones de seguridad.</p>\n",
              "impact": "<p>El impacto de esta vulnerabilidad, que implica un S3 Bucket codificado de forma estática en la aplicación <b>Noisiv</b>, es significativo. Puede llevar a acceso no autorizado, violaciones de datos y exposición de información sensible. Explotar credenciales codificadas de forma estática en una aplicación compromete gravemente la confidencialidad, integridad y disponibilidad de los datos y recursos del sistema. Esta vulnerabilidad puede resultar en manipulación no autorizada de la funcionalidad del sistema, consecuencias legales y regulatorias, daño a la reputación y trastornos operativos. Abordar este problema es crítico para prevenir estos graves riesgos de seguridad y mantener la postura de seguridad general de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "CWE - CWE-798: Use of Hard-coded Credentials (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/798.html"
            },
            {
              "label": "CWE - CWE-259: Use of Hard-coded Password (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/259.html"
            },
            {
              "label": "CWE - CWE-321: Use of Hard-coded Cryptographic Key (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/321.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-AUTH-1",
            "maswe": "MASWE-0005"
          },
          "evidences": [
            {
              "id": "5131b2b7-1f45-4c5e-823b-82bedfd98e3f",
              "value": "public static final String S3_SERVICE_DISPLAY_NAME = \"Amazon S3\";\n    public static final String URL_ENCODING = \"url\";\n    public static final String XML_NAMESPACE = \"http://s3.amazonaws.com/doc/2006-03-01/\";\n    private static Log log = LogFactory.getLog(AmazonS3Client.class);\n    public static final String SSE_AWS_KMS_ENCRYPTION_SCHEME = SSEAlgorithm.KMS.getAlgorithm();",
              "vulnerability_id": "0cf19e22-05df-4876-8e91-d564ca5f17db",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/sources/com/amazonaws/services/s3/internal/Constants.java",
              "file_line": [
                30
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.545-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "794b1442-bdb9-4b1d-907c-3f7e15017b09",
          "title": "Dynamic Receiver Registration",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team discovered a vulnerability in the <b>Noisiv</b> application related to the dynamic registration of broadcast receivers. This issue arises due to the application&#39;s use of the registerReceiver() method, which can register broadcast receivers dynamically at runtime instead of declaring them statically in the Android manifest. While dynamic registration provides flexibility, it also introduces potential security risks if not properly managed.</p>\n<p>Specifically, dynamically registered broadcast receivers do not benefit from the Android system&#39;s manifest-based security checks, which can lead to unintended broadcast exposure. If the intent filters associated with these receivers are not carefully specified, it could allow external applications to send broadcasts to the receivers, potentially leading to information leakage or triggering unintended behavior within the app.</p>\n<p>The following code snippet shows the insecure implementation:</p>\n",
              "remediation": "<p>To mitigate the risks associated with dynamically registered broadcast receivers the assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Explicit Intent Filters: Ensure that all dynamically registered broadcast receivers use explicit intent filters that clearly define what actions the receiver is intended to respond to. This helps prevent malicious apps from sending broadcasts that could trigger unintended behavior.\n</li>\n<li>Validate Broadcast Origin: Implement checks within the broadcast receiver to validate the origin of the broadcast. This ensures that only broadcasts from trusted sources are processed, reducing the risk of unauthorized access or manipulation.\n</li>\n<li>Limit Receiver Exposure: Where possible, avoid dynamic registration of broadcast receivers and instead declare them statically in the Android manifest with the necessary permission settings. This leverages the platform's built-in security features to control who can send broadcasts to the receivers.\n</li>\n<li>Use Local Broadcast Manager: For intra-app communication, use Android's Local Broadcast Manager to handle broadcasts. This confines broadcast messages to the app itself, preventing external applications from sending messages to the receivers.\n</li>\n<li>Unregister Receivers: Always ensure that dynamically registered receivers are unregistered when not needed, especially when the app is not in the foreground. This prevents dormant receivers from being triggered unexpectedly.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit the dynamically registered broadcast receivers to send unauthorized broadcasts that trigger unintended actions or manipulate the application’s behavior. This vulnerability could lead to the leakage of sensitive information if broadcasts are intercepted, or could cause the application to perform unintended operations. Such exposures can compromise user data privacy and application functionality</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió una vulnerabilidad en la aplicación <b>Noisiv</b> relacionada con el registro dinámico de receptores de transmisión. Este problema surge debido al uso por parte de la aplicación del método RegisterReceiver(), que puede registrar receptores de transmisión dinámicamente en tiempo de ejecución en lugar de declararlos estáticamente en el manifiesto de Android. Si bien el registro dinámico proporciona flexibilidad, también introduce riesgos potenciales de seguridad si no se gestiona adecuadamente.</p>\n<p>Específicamente, los receptores de transmisión registrados dinámicamente no se benefician de las comprobaciones de seguridad basadas en manifiestos del sistema Android, lo que puede provocar una exposición involuntaria de la transmisión. Si los filtros de intención asociados con estos receptores no se especifican cuidadosamente, podría permitir que aplicaciones externas envíen transmisiones a los receptores, lo que podría provocar una fuga de información o desencadenar un comportamiento no deseado dentro de la aplicación.</p>\n<p>El siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>Para mitigar los riesgos asociados con los receptores de transmisión registrados dinámicamente, el equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Filtros de intención explícitos: asegúrese de que todos los receptores de transmisión registrados dinámicamente utilicen filtros de intención explícitos que definan claramente a qué acciones debe responder el receptor. Esto ayuda a evitar que aplicaciones maliciosas envíen difusiones que podrían desencadenar un comportamiento no deseado.\n</li>\n<li>Validar origen de transmisión: implemente comprobaciones dentro del receptor de transmisión para validar el origen de la transmisión. Esto garantiza que solo se procesen transmisiones de fuentes confiables, lo que reduce el riesgo de acceso o manipulación no autorizados.\n</li>\n<li>Limitar la exposición del receptor: cuando sea posible, evite el registro dinámico de los receptores de transmisión y, en cambio, declárelos estáticamente en el manifiesto de Android con la configuración de permisos necesaria. Esto aprovecha las funciones de seguridad integradas de la plataforma para controlar quién puede enviar transmisiones a los receptores.\n</li>\n<li>Utilizar el Administrador de transmisiones locales: para la comunicación dentro de la aplicación, use el Administrador de transmisiones locales de Android para manejar las transmisiones. Esto limita los mensajes de difusión a la propia aplicación y evita que aplicaciones externas envíen mensajes a los receptores.\n</li>\n<li>Cancelar receptores: asegúrese siempre de cancelar el registro de los receptores registrados dinámicamente cuando no sean necesarios, especialmente cuando la aplicación no esté en primer plano. Esto evita que los receptores inactivos se activen inesperadamente.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar los receptores de transmisión registrados dinámicamente para enviar transmisiones no autorizadas que desencadenen acciones no deseadas o manipulen el comportamiento de la aplicación. Esta vulnerabilidad podría provocar la fuga de información confidencial si se interceptan las transmisiones o podría provocar que la aplicación realice operaciones no deseadas. Estas exposiciones pueden comprometer la privacidad de los datos del usuario y la funcionalidad de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Transmisiones persistentes | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sticky-broadcast?hl=es-419"
            },
            {
              "label": "Insecure Broadcast Receiver Configuration - Ostorlab: Mobile application security testing for android and ios",
              "url": "https://docs.ostorlab.co/kb/INSECURE_REGISTER_RECEIVER_FLAG/index.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0063"
          },
          "evidences": [
            {
              "id": "8c368dd1-ca33-46b7-bb58-7e53ffd95953",
              "value": "public void onCreate() {\n         super.onCreate();\n         TransferService.LOGGER.info(\"Starting Transfer Service to listen for network connectivity changes\");\n         ((TransferService) this).dbUtil = new TransferDBUtil(this);\n         ((TransferService) this).updater = TransferStatusUpdater.getInstance(this);\n         TransferService.networkInfoReceiver = new TransferService.NetworkInfoReceiver(this, getApplicationContext());\n         if (((TransferService) this).isReceiverNotRegistered) {\n             try {\n                 try {\n                     try {\n                         TransferService.LOGGER.info(\"Registering the network receiver\");\n                         registerReceiver(TransferService.networkInfoReceiver, new IntentFilter(\"android.net.conn.CONNECTIVITY_CHANGE\"));\n                     } catch (IllegalArgumentException e) {\n                         TransferService.LOGGER.warn(\"Ignoring the exception trying to register the receiver for connectivity change.\");\n                     }\n                 } catch (IllegalStateException e2) {\n                     TransferService.LOGGER.warn(\"Ignoring the leak in registering the receiver.\");\n                 }\n             } finally {\n                 ((TransferService) this).isReceiverNotRegistered = false;\n             }\n         }\n     }",
              "vulnerability_id": "794b1442-bdb9-4b1d-907c-3f7e15017b09",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/s3/transferutility/TransferService.java",
              "file_line": [
                635
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.407-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d27a3380-9140-4aef-8664-3b7d83daf2c4",
              "value": "public int onStartCommand(Intent intent, int flags, int startId) {\n         if (((TransferService) this).isReceiverNotRegistered) {\n             try {\n                 try {\n                     TransferService.LOGGER.info(\"Registering the network receiver\");\n                     registerReceiver(TransferService.networkInfoReceiver, new IntentFilter(\"android.net.conn.CONNECTIVITY_CHANGE\"));\n                 } catch (IllegalArgumentException e) {\n                     TransferService.LOGGER.warn(\"Ignoring the exception trying to register the receiver for connectivity change.\");\n                 } catch (IllegalStateException e2) {\n                     TransferService.LOGGER.warn(\"Ignoring the leak in registering the receiver.\");\n                 }\n                 return 1;\n             } finally {\n                 ((TransferService) this).isReceiverNotRegistered = false;\n             }\n         }\n         return 1;\n     }",
              "vulnerability_id": "794b1442-bdb9-4b1d-907c-3f7e15017b09",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/amazonaws/mobileconnectors/s3/transferutility/TransferService.java",
              "file_line": [
                789
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.423-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "aa98e349-ef3d-48a0-8542-f268e4142e0f",
              "value": "final void setup() {\n         cleanup();\n         if (((AppCompatDelegateImplV14.AutoNightModeManager) this).mAutoTimeChangeReceiver == null) {\n             ((AppCompatDelegateImplV14.AutoNightModeManager) this).mAutoTimeChangeReceiver = new AppCompatDelegateImplV14.AutoNightModeManager.1(this);\n         }\n         if (((AppCompatDelegateImplV14.AutoNightModeManager) this).mAutoTimeChangeReceiverFilter == null) {\n             ((AppCompatDelegateImplV14.AutoNightModeManager) this).mAutoTimeChangeReceiverFilter = new IntentFilter();\n             ((AppCompatDelegateImplV14.AutoNightModeManager) this).mAutoTimeChangeReceiverFilter.addAction(\"android.intent.action.TIME_SET\");\n             ((AppCompatDelegateImplV14.AutoNightModeManager) this).mAutoTimeChangeReceiverFilter.addAction(\"android.intent.action.TIMEZONE_CHANGED\");\n             ((AppCompatDelegateImplV14.AutoNightModeManager) this).mAutoTimeChangeReceiverFilter.addAction(\"android.intent.action.TIME_TICK\");\n         }\n         ((AppCompatDelegateImplV14.AutoNightModeManager) this).this$0.mContext.registerReceiver(((AppCompatDelegateImplV14.AutoNightModeManager) this).mAutoTimeChangeReceiver, ((AppCompatDelegateImplV14.AutoNightModeManager) this).mAutoTimeChangeReceiverFilter);\n     }",
              "vulnerability_id": "794b1442-bdb9-4b1d-907c-3f7e15017b09",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v7/app/AppCompatDelegateImplV14$AutoNightModeManager.java",
              "file_line": [
                208
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:12.392-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
          "title": "Implicit Intent Detected",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Noisiv</b> uses implicit intents, which allow the Android system to determine which component, potentially from another application, should handle an intent. While this enables flexible inter-application communication, insecure implementation can lead to unintended exposure of sensitive functionality.</p>\n",
              "remediation": "<p>The assessment team recommends using explicit intents whenever possible to ensure that only intended application components handle them. If implicit intents are required, developers should restrict exposed components by properly configuring intent filters and setting the exported attribute to false when external access is not necessary. Additionally, all incoming intents should be validated to prevent unauthorized access or data manipulation.</p>\n",
              "impact": "<p>Improper handling of implicit intents can result in intent hijacking, where malicious applications intercept and manipulate intents that were not explicitly directed to a specific component. This could lead to unauthorized access to sensitive data or unintended execution of actions triggered by an attacker.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Noisiv</b> utiliza intenciones implícitas, que permiten al sistema Android determinar qué componente, potencialmente de otra aplicación, debe manejar una intención. Si bien esto permite una comunicación flexible entre aplicaciones, una implementación insegura puede provocar una exposición involuntaria de funciones confidenciales.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda utilizar intenciones explícitas siempre que sea posible para garantizar que solo los componentes de la aplicación previstos las manejen. Si se requieren intenciones implícitas, los desarrolladores deben restringir los componentes expuestos configurando correctamente los filtros de intención y estableciendo el atributo exportado en falso cuando no sea necesario el acceso externo. Además, todos los intents entrantes deben validarse para evitar el acceso no autorizado o la manipulación de datos.</p>\n",
              "impact": "<p>El manejo inadecuado de intenciones implícitas puede resultar en secuestro de intenciones, donde aplicaciones maliciosas interceptan y manipulan intenciones que no estaban dirigidas explícitamente a un componente específico. Esto podría dar lugar a un acceso no autorizado a datos confidenciales o a la ejecución involuntaria de acciones provocadas por un atacante.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Intents and Intent Filters | App architecture - Android Developers",
              "url": "https://developer.android.com/guide/components/intents-filters?hl=es-419"
            },
            {
              "label": "Implicit Intent Hijacking | Security - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/implicit-intent-hijacking?hl=es-419"
            },
            {
              "label": "Mitigate security risks in your app - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "4088c01e-9703-46e5-8eaf-af72b5c44485",
              "value": "public void run() {\n         if (((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mState == 0) {\n             return;\n         }\n         ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mState = 2;\n         if (MediaBrowserCompat.DEBUG && ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mServiceConnection != null) {\n             throw new RuntimeException(\"mServiceConnection should be null. Instead it is \" + ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mServiceConnection);\n         } else if (((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mServiceBinderWrapper != null) {\n             throw new RuntimeException(\"mServiceBinderWrapper should be null. Instead it is \" + ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mServiceBinderWrapper);\n         } else if (((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mCallbacksMessenger != null) {\n             throw new RuntimeException(\"mCallbacksMessenger should be null. Instead it is \" + ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mCallbacksMessenger);\n         } else {\n             Intent intent = new Intent(\"android.media.browse.MediaBrowserService\");\n             intent.setComponent(((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mServiceComponent);\n             ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mServiceConnection = new MediaBrowserCompat.MediaBrowserImplBase.MediaServiceConnection(((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0);\n             boolean bound = false;\n             try {\n                 bound = ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mContext.bindService(intent, ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mServiceConnection, 1);\n             } catch (Exception e) {\n                 Log.e(\"MediaBrowserCompat\", \"Failed binding to service \" + ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mServiceComponent);\n             }\n             if (!bound) {\n                 ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.forceCloseConnection();\n                 ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.mCallback.onConnectionFailed();\n             }\n             if (MediaBrowserCompat.DEBUG) {\n                 Log.d(\"MediaBrowserCompat\", \"connect...\");\n                 ((MediaBrowserCompat.MediaBrowserImplBase.1) this).this$0.dump();\n             }\n         }\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/MediaBrowserCompat$MediaBrowserImplBase$1.java",
              "file_line": [
                169
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.808-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "86b73b26-57ca-4ed6-ba96-dc6b819f0652",
              "value": "public Cls8VFDXBIKI5IKQ7J(Context context, String tag, ComponentName mbrComponent, PendingIntent mbrIntent) {\n         ((MediaSessionCompat) this).mActiveListeners = new ArrayList();\n         if (context == null) {\n             throw new IllegalArgumentException(\"context must not be null\");\n         }\n         if (TextUtils.isEmpty(tag)) {\n             throw new IllegalArgumentException(\"tag must not be null or empty\");\n         }\n         if (mbrComponent == null && (mbrComponent = MediaButtonReceiver.getMediaButtonReceiverComponent(context)) == null) {\n             Log.w(\"MediaSessionCompat\", \"Couldn't find a unique registered media button receiver in the given context.\");\n         }\n         if (mbrComponent != null && mbrIntent == null) {\n             Intent mediaButtonIntent = new Intent(\"android.intent.action.MEDIA_BUTTON\");\n             mediaButtonIntent.setComponent(mbrComponent);\n             mbrIntent = PendingIntent.getBroadcast(context, 0, mediaButtonIntent, 0);\n         }\n         if (Build.VERSION.SDK_INT >= 21) {\n             ((MediaSessionCompat) this).mImpl = new MediaSessionCompat.MediaSessionImplApi21(context, tag);\n             setCallback(new MediaSessionCompat.1(this));\n             ((MediaSessionCompat) this).mImpl.setMediaButtonReceiver(mbrIntent);\n         } else if (Build.VERSION.SDK_INT >= 19) {\n             ((MediaSessionCompat) this).mImpl = new MediaSessionCompat.MediaSessionImplApi19(context, tag, mbrComponent, mbrIntent);\n         } else if (Build.VERSION.SDK_INT >= 18) {\n             ((MediaSessionCompat) this).mImpl = new MediaSessionCompat.MediaSessionImplApi18(context, tag, mbrComponent, mbrIntent);\n         } else {\n             ((MediaSessionCompat) this).mImpl = new MediaSessionCompat.MediaSessionImplBase(context, tag, mbrComponent, mbrIntent);\n         }\n         ((MediaSessionCompat) this).mController = new MediaControllerCompat(context, this);\n         if (MediaSessionCompat.sMaxBitmapSize == 0) {\n             MediaSessionCompat.sMaxBitmapSize = (int) TypedValue.applyDimension(1, 320.0f, context.getResources().getDisplayMetrics());\n         }\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaSessionCompat.java",
              "file_line": [
                254
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.894-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "311b81d8-480d-4a79-99b1-8426306feb06",
              "value": "private boolean ensureServiceBound(NotificationManagerCompat.SideChannelManager.ListenerRecord record) {\n         if (record.bound) {\n             return true;\n         }\n         Intent intent = new Intent(\"android.support.BIND_NOTIFICATION_SIDE_CHANNEL\").setComponent(record.componentName);\n         record.bound = ((NotificationManagerCompat.SideChannelManager) this).mContext.bindService(intent, this, 33);\n         if (record.bound) {\n             record.retryCount = 0;\n         } else {\n             Log.w(\"NotifManCompat\", \"Unable to bind to listener \" + record.componentName);\n             ((NotificationManagerCompat.SideChannelManager) this).mContext.unbindService(this);\n         }\n         return record.bound;\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/app/NotificationManagerCompat$SideChannelManager.java",
              "file_line": [
                142
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.785-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e40db144-9b28-48e8-abcf-115d0f06660a",
              "value": "public ClsG9LQKY269ZTQZNE(Context context, AttributeSet attrs, int defStyleAttr) {\n         super(context, attrs, defStyleAttr);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         ((SearchView) this).mOnClickListener = new SearchView.5(this);\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         ((SearchView) this).mOnEditorActionListener = new SearchView.7(this);\n         ((SearchView) this).mOnItemClickListener = new SearchView.8(this);\n         ((SearchView) this).mOnItemSelectedListener = new SearchView.9(this);\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.SearchView, defStyleAttr, 0);\n         LayoutInflater inflater = LayoutInflater.from(context);\n         int layoutResId = a.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view);\n         inflater.inflate(layoutResId, (ViewGroup) this, true);\n         ((SearchView) this).mSearchSrcTextView = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         ((SearchView) this).mSearchPlate = findViewById(R.id.search_plate);\n         ((SearchView) this).mSubmitArea = findViewById(R.id.submit_area);\n         ((SearchView) this).mSearchButton = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mGoButton = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mCloseButton = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mVoiceButton = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mCollapsedIcon = (ImageView) findViewById(R.id.search_mag_icon);\n         ViewCompat.setBackground(((SearchView) this).mSearchPlate, a.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(((SearchView) this).mSubmitArea, a.getDrawable(R.styleable.SearchView_submitBackground));\n         ((SearchView) this).mSearchButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mGoButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_goIcon));\n         ((SearchView) this).mCloseButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_closeIcon));\n         ((SearchView) this).mVoiceButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_voiceIcon));\n         ((SearchView) this).mCollapsedIcon.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = a.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(((SearchView) this).mSearchButton, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = a.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = a.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         ((SearchView) this).mSearchButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mCloseButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mGoButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mVoiceButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.addTextChangedListener(((SearchView) this).mTextWatcher);\n         ((SearchView) this).mSearchSrcTextView.setOnEditorActionListener(((SearchView) this).mOnEditorActionListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemClickListener(((SearchView) this).mOnItemClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemSelectedListener(((SearchView) this).mOnItemSelectedListener);\n         ((SearchView) this).mSearchSrcTextView.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         ((SearchView) this).mSearchSrcTextView.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (maxWidth != -1) {\n             setMaxWidth(maxWidth);\n         }\n         ((SearchView) this).mDefaultQueryHint = a.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = a.getText(R.styleable.SearchView_queryHint);\n         int imeOptions = a.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (imeOptions != -1) {\n             setImeOptions(imeOptions);\n         }\n         int inputType = a.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (inputType != -1) {\n             setInputType(inputType);\n         }\n         boolean focusable = a.getBoolean(R.styleable.SearchView_android_focusable, true);\n         setFocusable(focusable);\n         a.recycle();\n         ((SearchView) this).mVoiceWebSearchIntent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent.addFlags(268435456);\n         ((SearchView) this).mVoiceWebSearchIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         ((SearchView) this).mVoiceAppSearchIntent = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent.addFlags(268435456);\n         ((SearchView) this).mDropDownAnchor = findViewById(((SearchView) this).mSearchSrcTextView.getDropDownAnchor());\n         if (((SearchView) this).mDropDownAnchor != null) {\n             ((SearchView) this).mDropDownAnchor.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v7/widget/SearchView.java",
              "file_line": [
                714
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.912-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "af52b2c2-0713-4294-92ed-c497da65473a",
              "value": "public Cls4TKGXLYHP0GEMS0(Context context, AttributeSet attrs, int defStyleAttr) {\n         super(context, attrs, defStyleAttr);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         ((SearchView) this).mOnClickListener = new SearchView.5(this);\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         ((SearchView) this).mOnEditorActionListener = new SearchView.7(this);\n         ((SearchView) this).mOnItemClickListener = new SearchView.8(this);\n         ((SearchView) this).mOnItemSelectedListener = new SearchView.9(this);\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.SearchView, defStyleAttr, 0);\n         LayoutInflater inflater = LayoutInflater.from(context);\n         int layoutResId = a.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view);\n         inflater.inflate(layoutResId, (ViewGroup) this, true);\n         ((SearchView) this).mSearchSrcTextView = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         ((SearchView) this).mSearchPlate = findViewById(R.id.search_plate);\n         ((SearchView) this).mSubmitArea = findViewById(R.id.submit_area);\n         ((SearchView) this).mSearchButton = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mGoButton = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mCloseButton = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mVoiceButton = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mCollapsedIcon = (ImageView) findViewById(R.id.search_mag_icon);\n         ViewCompat.setBackground(((SearchView) this).mSearchPlate, a.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(((SearchView) this).mSubmitArea, a.getDrawable(R.styleable.SearchView_submitBackground));\n         ((SearchView) this).mSearchButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mGoButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_goIcon));\n         ((SearchView) this).mCloseButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_closeIcon));\n         ((SearchView) this).mVoiceButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_voiceIcon));\n         ((SearchView) this).mCollapsedIcon.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = a.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(((SearchView) this).mSearchButton, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = a.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = a.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         ((SearchView) this).mSearchButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mCloseButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mGoButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mVoiceButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.addTextChangedListener(((SearchView) this).mTextWatcher);\n         ((SearchView) this).mSearchSrcTextView.setOnEditorActionListener(((SearchView) this).mOnEditorActionListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemClickListener(((SearchView) this).mOnItemClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemSelectedListener(((SearchView) this).mOnItemSelectedListener);\n         ((SearchView) this).mSearchSrcTextView.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         ((SearchView) this).mSearchSrcTextView.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (maxWidth != -1) {\n             setMaxWidth(maxWidth);\n         }\n         ((SearchView) this).mDefaultQueryHint = a.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = a.getText(R.styleable.SearchView_queryHint);\n         int imeOptions = a.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (imeOptions != -1) {\n             setImeOptions(imeOptions);\n         }\n         int inputType = a.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (inputType != -1) {\n             setInputType(inputType);\n         }\n         boolean focusable = a.getBoolean(R.styleable.SearchView_android_focusable, true);\n         setFocusable(focusable);\n         a.recycle();\n         ((SearchView) this).mVoiceWebSearchIntent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent.addFlags(268435456);\n         ((SearchView) this).mVoiceWebSearchIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         ((SearchView) this).mVoiceAppSearchIntent = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent.addFlags(268435456);\n         ((SearchView) this).mDropDownAnchor = findViewById(((SearchView) this).mSearchSrcTextView.getDropDownAnchor());\n         if (((SearchView) this).mDropDownAnchor != null) {\n             ((SearchView) this).mDropDownAnchor.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v7/widget/SearchView.java",
              "file_line": [
                739
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.932-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b49bb460-34de-44dc-8ff2-833e05563eb0",
              "value": "public void onClick(View view) {\n         if (view != ((MainActivity) this).imageButtonCamera) {\n             if (view == ((MainActivity) this).imageButtonPhoto) {\n                 new MaterialFilePicker().withActivity(this).withRequestCode(2).withTitle(\"Select an Image\").withFilterDirectories(true).start();\n                 return;\n             }\n             return;\n         }\n         Intent imageIntent = new Intent(\"android.media.action.IMAGE_CAPTURE\");\n         if (imageIntent.resolveActivity(getPackageManager()) != null) {\n             startActivityForResult(imageIntent, 1);\n         }\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/datadit/noisiv/MainActivity.java",
              "file_line": [
                780
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.991-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "72bcbb57-690b-4e80-8b91-6ae8bdef5179",
              "value": "private static ComponentName getServiceComponentByAction(Context context, String action) {\n         PackageManager pm = context.getPackageManager();\n         Intent queryIntent = new Intent(action);\n         queryIntent.setPackage(context.getPackageName());\n         List<ResolveInfo> resolveInfos = pm.queryIntentServices(queryIntent, 0);\n         if (resolveInfos.size() == 1) {\n             ResolveInfo resolveInfo = resolveInfos.get(0);\n             return new ComponentName(resolveInfo.serviceInfo.packageName, resolveInfo.serviceInfo.name);\n         } else if (resolveInfos.isEmpty()) {\n             return null;\n         } else {\n             throw new IllegalStateException(\"Expected 1 service that handles \" + action + \", found \" + resolveInfos.size());\n         }\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaButtonReceiver.java",
              "file_line": [
                250
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.851-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d874041e-6f36-486b-bc1b-6692fceed6e5",
              "value": "public void handleMessage(Message msg) {\n         MediaSessionCompat.Callback cb = ((MediaSessionCompat.MediaSessionImplBase.MessageHandler) this).this$0.mCallback;\n         if (cb == null) {\n             return;\n         }\n         switch (msg.what) {\n             case 1:\n                 MediaSessionCompat.MediaSessionImplBase.Command cmd = (MediaSessionCompat.MediaSessionImplBase.Command) msg.obj;\n                 cb.onCommand(cmd.command, cmd.extras, cmd.stub);\n                 return;\n             case 2:\n                 ((MediaSessionCompat.MediaSessionImplBase.MessageHandler) this).this$0.adjustVolume(msg.arg1, 0);\n                 return;\n             case 3:\n                 cb.onPrepare();\n                 return;\n             case 4:\n                 cb.onPrepareFromMediaId((String) msg.obj, msg.getData());\n                 return;\n             case 5:\n                 cb.onPrepareFromSearch((String) msg.obj, msg.getData());\n                 return;\n             case 6:\n                 cb.onPrepareFromUri((Uri) msg.obj, msg.getData());\n                 return;\n             case 7:\n                 cb.onPlay();\n                 return;\n             case 8:\n                 cb.onPlayFromMediaId((String) msg.obj, msg.getData());\n                 return;\n             case 9:\n                 cb.onPlayFromSearch((String) msg.obj, msg.getData());\n                 return;\n             case 10:\n                 cb.onPlayFromUri((Uri) msg.obj, msg.getData());\n                 return;\n             case 11:\n                 cb.onSkipToQueueItem(((Long) msg.obj).longValue());\n                 return;\n             case 12:\n                 cb.onPause();\n                 return;\n             case 13:\n                 cb.onStop();\n                 return;\n             case 14:\n                 cb.onSkipToNext();\n                 return;\n             case 15:\n                 cb.onSkipToPrevious();\n                 return;\n             case 16:\n                 cb.onFastForward();\n                 return;\n             case 17:\n                 cb.onRewind();\n                 return;\n             case 18:\n                 cb.onSeekTo(((Long) msg.obj).longValue());\n                 return;\n             case 19:\n                 cb.onSetRating((RatingCompat) msg.obj);\n                 return;\n             case 20:\n                 cb.onCustomAction((String) msg.obj, msg.getData());\n                 return;\n             case 21:\n                 KeyEvent keyEvent = (KeyEvent) msg.obj;\n                 Intent intent = new Intent(\"android.intent.action.MEDIA_BUTTON\");\n                 intent.putExtra(\"android.intent.extra.KEY_EVENT\", keyEvent);\n                 if (!cb.onMediaButtonEvent(intent)) {\n                     onMediaButtonEvent(keyEvent, cb);\n                     return;\n                 }\n                 return;\n             case 22:\n                 ((MediaSessionCompat.MediaSessionImplBase.MessageHandler) this).this$0.setVolumeTo(msg.arg1, 0);\n                 return;\n             case 23:\n                 cb.onSetRepeatMode(msg.arg1);\n                 return;\n             case 24:\n             default:\n                 return;\n             case 25:\n                 cb.onAddQueueItem((MediaDescriptionCompat) msg.obj);\n                 return;\n             case 26:\n                 cb.onAddQueueItem((MediaDescriptionCompat) msg.obj, msg.arg1);\n                 return;\n             case 27:\n                 cb.onRemoveQueueItem((MediaDescriptionCompat) msg.obj);\n                 return;\n             case 28:\n                 if (((MediaSessionCompat.MediaSessionImplBase.MessageHandler) this).this$0.mQueue != null) {\n                     MediaSessionCompat.QueueItem item = (msg.arg1 < 0 || msg.arg1 >= ((MediaSessionCompat.MediaSessionImplBase.MessageHandler) this).this$0.mQueue.size()) ? null : (MediaSessionCompat.QueueItem) ((MediaSessionCompat.MediaSessionImplBase.MessageHandler) this).this$0.mQueue.get(msg.arg1);\n                     if (item != null) {\n                         cb.onRemoveQueueItem(item.getDescription());\n                         return;\n                     }\n                     return;\n                 }\n                 return;\n             case 29:\n                 cb.onSetCaptioningEnabled(((Boolean) msg.obj).booleanValue());\n                 return;\n             case 30:\n                 cb.onSetShuffleMode(msg.arg1);\n                 return;\n             case 31:\n                 cb.onSetRating((RatingCompat) msg.obj, msg.getData());\n                 return;\n         }\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaSessionCompat$MediaSessionImplBase$MessageHandler.java",
              "file_line": [
                497
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.875-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d66e2dbe-c8bb-40e0-ae59-153d3571b692",
              "value": "public ClsTJGK94DA1NJF7XP(Context context, String tag, ComponentName mbrComponent, PendingIntent mbrIntent) {\n         ((MediaSessionCompat) this).mActiveListeners = new ArrayList();\n         if (context == null) {\n             throw new IllegalArgumentException(\"context must not be null\");\n         }\n         if (TextUtils.isEmpty(tag)) {\n             throw new IllegalArgumentException(\"tag must not be null or empty\");\n         }\n         if (mbrComponent == null && (mbrComponent = MediaButtonReceiver.getMediaButtonReceiverComponent(context)) == null) {\n             Log.w(\"MediaSessionCompat\", \"Couldn't find a unique registered media button receiver in the given context.\");\n         }\n         if (mbrComponent != null && mbrIntent == null) {\n             Intent mediaButtonIntent = new Intent(\"android.intent.action.MEDIA_BUTTON\");\n             mediaButtonIntent.setComponent(mbrComponent);\n             mbrIntent = PendingIntent.getBroadcast(context, 0, mediaButtonIntent, 0);\n         }\n         if (Build.VERSION.SDK_INT >= 21) {\n             ((MediaSessionCompat) this).mImpl = new MediaSessionCompat.MediaSessionImplApi21(context, tag);\n             setCallback(new MediaSessionCompat.1(this));\n             ((MediaSessionCompat) this).mImpl.setMediaButtonReceiver(mbrIntent);\n         } else if (Build.VERSION.SDK_INT >= 19) {\n             ((MediaSessionCompat) this).mImpl = new MediaSessionCompat.MediaSessionImplApi19(context, tag, mbrComponent, mbrIntent);\n         } else if (Build.VERSION.SDK_INT >= 18) {\n             ((MediaSessionCompat) this).mImpl = new MediaSessionCompat.MediaSessionImplApi18(context, tag, mbrComponent, mbrIntent);\n         } else {\n             ((MediaSessionCompat) this).mImpl = new MediaSessionCompat.MediaSessionImplBase(context, tag, mbrComponent, mbrIntent);\n         }\n         ((MediaSessionCompat) this).mController = new MediaControllerCompat(context, this);\n         if (MediaSessionCompat.sMaxBitmapSize == 0) {\n             MediaSessionCompat.sMaxBitmapSize = (int) TypedValue.applyDimension(1, 320.0f, context.getResources().getDisplayMetrics());\n         }\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaSessionCompat.java",
              "file_line": [
                254
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.016-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2d785971-6e0e-4860-adc9-2cb0f73a89b6",
              "value": "public static PendingIntent buildMediaButtonPendingIntent(Context context, ComponentName mbrComponent, long action) {\n         if (mbrComponent == null) {\n             Log.w(\"MediaButtonReceiver\", \"The component name of media button receiver should be provided.\");\n             return null;\n         }\n         int keyCode = PlaybackStateCompat.toKeyCode(action);\n         if (keyCode == 0) {\n             Log.w(\"MediaButtonReceiver\", \"Cannot build a media button pending intent with the given action: \" + action);\n             return null;\n         }\n         Intent intent = new Intent(\"android.intent.action.MEDIA_BUTTON\");\n         intent.setComponent(mbrComponent);\n         intent.putExtra(\"android.intent.extra.KEY_EVENT\", new KeyEvent(0, keyCode));\n         return PendingIntent.getBroadcast(context, keyCode, intent, 0);\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaButtonReceiver.java",
              "file_line": [
                123
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.823-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "eefa56c2-1116-423e-ba8d-c1f863dbe34a",
              "value": "private Intent createVoiceAppSearchIntent(Intent baseIntent, SearchableInfo searchable) {\n         ComponentName searchActivity = searchable.getSearchActivity();\n         Intent queryIntent = new Intent(\"android.intent.action.SEARCH\");\n         queryIntent.setComponent(searchActivity);\n         PendingIntent pending = PendingIntent.getActivity(getContext(), 0, queryIntent, 1073741824);\n         Bundle queryExtras = new Bundle();\n         if (((SearchView) this).mAppSearchData != null) {\n             queryExtras.putParcelable(\"app_data\", ((SearchView) this).mAppSearchData);\n         }\n         Intent voiceIntent = new Intent(baseIntent);\n         String languageModel = \"free_form\";\n         String prompt = null;\n         String language = null;\n         int maxResults = 1;\n         Resources resources = getResources();\n         if (searchable.getVoiceLanguageModeId() != 0) {\n             languageModel = resources.getString(searchable.getVoiceLanguageModeId());\n         }\n         if (searchable.getVoicePromptTextId() != 0) {\n             prompt = resources.getString(searchable.getVoicePromptTextId());\n         }\n         if (searchable.getVoiceLanguageId() != 0) {\n             language = resources.getString(searchable.getVoiceLanguageId());\n         }\n         if (searchable.getVoiceMaxResults() != 0) {\n             maxResults = searchable.getVoiceMaxResults();\n         }\n         voiceIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", languageModel);\n         voiceIntent.putExtra(\"android.speech.extra.PROMPT\", prompt);\n         voiceIntent.putExtra(\"android.speech.extra.LANGUAGE\", language);\n         voiceIntent.putExtra(\"android.speech.extra.MAX_RESULTS\", maxResults);\n         voiceIntent.putExtra(\"calling_package\", searchActivity == null ? null : searchActivity.flattenToShortString());\n         voiceIntent.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT\", pending);\n         voiceIntent.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT_BUNDLE\", queryExtras);\n         return voiceIntent;\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v7/widget/SearchView.java",
              "file_line": [
                1108
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.975-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "503ff604-4caf-4e03-ba39-c7e85aa1783f",
              "value": "static ComponentName getMediaButtonReceiverComponent(Context context) {\n         Intent queryIntent = new Intent(\"android.intent.action.MEDIA_BUTTON\");\n         queryIntent.setPackage(context.getPackageName());\n         PackageManager pm = context.getPackageManager();\n         List<ResolveInfo> resolveInfos = pm.queryBroadcastReceivers(queryIntent, 0);\n         if (resolveInfos.size() == 1) {\n             ResolveInfo resolveInfo = resolveInfos.get(0);\n             return new ComponentName(resolveInfo.activityInfo.packageName, resolveInfo.activityInfo.name);\n         } else if (resolveInfos.size() > 1) {\n             Log.w(\"MediaButtonReceiver\", \"More than one BroadcastReceiver that handles android.intent.action.MEDIA_BUTTON was found, returning null.\");\n             return null;\n         } else {\n             return null;\n         }\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v4/media/session/MediaButtonReceiver.java",
              "file_line": [
                157
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.836-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "eaa5f25a-9e37-4c9b-a61d-d45c9526db9c",
              "value": "public ClsDA0YY97A7JGVEXR(Context context, AttributeSet attrs, int defStyleAttr) {\n         super(context, attrs, defStyleAttr);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         ((SearchView) this).mOnClickListener = new SearchView.5(this);\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         ((SearchView) this).mOnEditorActionListener = new SearchView.7(this);\n         ((SearchView) this).mOnItemClickListener = new SearchView.8(this);\n         ((SearchView) this).mOnItemSelectedListener = new SearchView.9(this);\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.SearchView, defStyleAttr, 0);\n         LayoutInflater inflater = LayoutInflater.from(context);\n         int layoutResId = a.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view);\n         inflater.inflate(layoutResId, (ViewGroup) this, true);\n         ((SearchView) this).mSearchSrcTextView = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         ((SearchView) this).mSearchPlate = findViewById(R.id.search_plate);\n         ((SearchView) this).mSubmitArea = findViewById(R.id.submit_area);\n         ((SearchView) this).mSearchButton = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mGoButton = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mCloseButton = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mVoiceButton = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mCollapsedIcon = (ImageView) findViewById(R.id.search_mag_icon);\n         ViewCompat.setBackground(((SearchView) this).mSearchPlate, a.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(((SearchView) this).mSubmitArea, a.getDrawable(R.styleable.SearchView_submitBackground));\n         ((SearchView) this).mSearchButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mGoButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_goIcon));\n         ((SearchView) this).mCloseButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_closeIcon));\n         ((SearchView) this).mVoiceButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_voiceIcon));\n         ((SearchView) this).mCollapsedIcon.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = a.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(((SearchView) this).mSearchButton, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = a.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = a.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         ((SearchView) this).mSearchButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mCloseButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mGoButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mVoiceButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.addTextChangedListener(((SearchView) this).mTextWatcher);\n         ((SearchView) this).mSearchSrcTextView.setOnEditorActionListener(((SearchView) this).mOnEditorActionListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemClickListener(((SearchView) this).mOnItemClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemSelectedListener(((SearchView) this).mOnItemSelectedListener);\n         ((SearchView) this).mSearchSrcTextView.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         ((SearchView) this).mSearchSrcTextView.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (maxWidth != -1) {\n             setMaxWidth(maxWidth);\n         }\n         ((SearchView) this).mDefaultQueryHint = a.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = a.getText(R.styleable.SearchView_queryHint);\n         int imeOptions = a.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (imeOptions != -1) {\n             setImeOptions(imeOptions);\n         }\n         int inputType = a.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (inputType != -1) {\n             setInputType(inputType);\n         }\n         boolean focusable = a.getBoolean(R.styleable.SearchView_android_focusable, true);\n         setFocusable(focusable);\n         a.recycle();\n         ((SearchView) this).mVoiceWebSearchIntent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent.addFlags(268435456);\n         ((SearchView) this).mVoiceWebSearchIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         ((SearchView) this).mVoiceAppSearchIntent = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent.addFlags(268435456);\n         ((SearchView) this).mDropDownAnchor = findViewById(((SearchView) this).mSearchSrcTextView.getDropDownAnchor());\n         if (((SearchView) this).mDropDownAnchor != null) {\n             ((SearchView) this).mDropDownAnchor.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v7/widget/SearchView.java",
              "file_line": [
                714
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.033-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "827e7d93-c276-4806-a972-a67899497f9e",
              "value": "private Intent createIntent(String action, Uri data, String extraData, String query, int actionKey, String actionMsg) {\n         Intent intent = new Intent(action);\n         intent.addFlags(268435456);\n         if (data != null) {\n             intent.setData(data);\n         }\n         intent.putExtra(\"user_query\", ((SearchView) this).mUserQuery);\n         if (query != null) {\n             intent.putExtra(\"query\", query);\n         }\n         if (extraData != null) {\n             intent.putExtra(\"intent_extra_data_key\", extraData);\n         }\n         if (((SearchView) this).mAppSearchData != null) {\n             intent.putExtra(\"app_data\", ((SearchView) this).mAppSearchData);\n         }\n         if (actionKey != 0) {\n             intent.putExtra(\"action_key\", actionKey);\n             intent.putExtra(\"action_msg\", actionMsg);\n         }\n         intent.setComponent(((SearchView) this).mSearchable.getSearchActivity());\n         return intent;\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v7/widget/SearchView.java",
              "file_line": [
                800
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:10.958-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "08944a55-f105-4ed7-a48f-661ada73fce8",
              "value": "public ClsJV6AQQ8LEI6DIOI(Context context, AttributeSet attrs, int defStyleAttr) {\n         super(context, attrs, defStyleAttr);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         ((SearchView) this).mOnClickListener = new SearchView.5(this);\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         ((SearchView) this).mOnEditorActionListener = new SearchView.7(this);\n         ((SearchView) this).mOnItemClickListener = new SearchView.8(this);\n         ((SearchView) this).mOnItemSelectedListener = new SearchView.9(this);\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.SearchView, defStyleAttr, 0);\n         LayoutInflater inflater = LayoutInflater.from(context);\n         int layoutResId = a.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view);\n         inflater.inflate(layoutResId, (ViewGroup) this, true);\n         ((SearchView) this).mSearchSrcTextView = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         ((SearchView) this).mSearchPlate = findViewById(R.id.search_plate);\n         ((SearchView) this).mSubmitArea = findViewById(R.id.submit_area);\n         ((SearchView) this).mSearchButton = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mGoButton = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mCloseButton = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mVoiceButton = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mCollapsedIcon = (ImageView) findViewById(R.id.search_mag_icon);\n         ViewCompat.setBackground(((SearchView) this).mSearchPlate, a.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(((SearchView) this).mSubmitArea, a.getDrawable(R.styleable.SearchView_submitBackground));\n         ((SearchView) this).mSearchButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mGoButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_goIcon));\n         ((SearchView) this).mCloseButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_closeIcon));\n         ((SearchView) this).mVoiceButton.setImageDrawable(a.getDrawable(R.styleable.SearchView_voiceIcon));\n         ((SearchView) this).mCollapsedIcon.setImageDrawable(a.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = a.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(((SearchView) this).mSearchButton, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = a.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = a.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         ((SearchView) this).mSearchButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mCloseButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mGoButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mVoiceButton.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnClickListener(((SearchView) this).mOnClickListener);\n         ((SearchView) this).mSearchSrcTextView.addTextChangedListener(((SearchView) this).mTextWatcher);\n         ((SearchView) this).mSearchSrcTextView.setOnEditorActionListener(((SearchView) this).mOnEditorActionListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemClickListener(((SearchView) this).mOnItemClickListener);\n         ((SearchView) this).mSearchSrcTextView.setOnItemSelectedListener(((SearchView) this).mOnItemSelectedListener);\n         ((SearchView) this).mSearchSrcTextView.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         ((SearchView) this).mSearchSrcTextView.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (maxWidth != -1) {\n             setMaxWidth(maxWidth);\n         }\n         ((SearchView) this).mDefaultQueryHint = a.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = a.getText(R.styleable.SearchView_queryHint);\n         int imeOptions = a.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (imeOptions != -1) {\n             setImeOptions(imeOptions);\n         }\n         int inputType = a.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (inputType != -1) {\n             setInputType(inputType);\n         }\n         boolean focusable = a.getBoolean(R.styleable.SearchView_android_focusable, true);\n         setFocusable(focusable);\n         a.recycle();\n         ((SearchView) this).mVoiceWebSearchIntent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent.addFlags(268435456);\n         ((SearchView) this).mVoiceWebSearchIntent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         ((SearchView) this).mVoiceAppSearchIntent = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent.addFlags(268435456);\n         ((SearchView) this).mDropDownAnchor = findViewById(((SearchView) this).mSearchSrcTextView.getDropDownAnchor());\n         if (((SearchView) this).mDropDownAnchor != null) {\n             ((SearchView) this).mDropDownAnchor.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "a7fd88d8-b701-494b-99a6-512b0ecd2003",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/android/support/v7/widget/SearchView.java",
              "file_line": [
                739
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:57:11.052-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        }
      ],
      "severityDistribution": {
        "info": 20,
        "high": 40,
        "medium": 20,
        "low": 20
      },
      "severityCount": {
        "high": 6,
        "info": 3,
        "medium": 3,
        "low": 3
      },
      "properties": {
        "MIN_SDK": 21,
        "MD5": "c3cac8d311e21e92c50f7cc5e6cf210f",
        "SHA1": "f439cdb86a50d2ca82fdfed59ac7ebcfa3b150ba",
        "SHA256": "549f11de9660d9e1bd260e302525732f8f0c183a6ddab035dde4664e3c0c138d",
        "VERSION": 1,
        "ANDROID_VERSION_CODE": 1,
        "FRAMEWORK": "Native (Java / Kotlin)",
        "MAIN_ACTIVITY": "com.matrix.noisiv.SplashActivity",
        "BINARY_PROTECTIONS": null
      },
      "permissions": [
        "android.permission.INTERNET",
        "android.permission.ACCESS_NETWORK_STATE",
        "android.permission.READ_EXTERNAL_STORAGE",
        "android.permission.RECORD_AUDIO",
        "android.permission.WRITE_EXTERNAL_STORAGE",
        "android.permission.WAKE_LOCK",
        "android.permission.READ_PHONE_STATE"
      ],
      "components": [
        {
          "name": "com.datadit.noisiv.MainActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.datadit.noisiv.SplashActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": true
        },
        {
          "name": "com.nbsp.materialfilepicker.ui.FilePickerActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        }
      ],
      "protections": [
        {
          "type": "has_ssl_pinning",
          "name": "Certificate Pinning",
          "category": [
            "MASVS-NETWORK-1"
          ],
          "protectors": [
            {
              "name": "TrustedCertificate",
              "files": [
                "classes.dex"
              ]
            }
          ]
        },
        {
          "type": "anti_vm",
          "name": "Emulation Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": [
            {
              "name": "Build.MANUFACTURER",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "Build.MODEL",
              "files": [
                "classes.dex"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": 4,
      "status": "COMPLETED",
      "start_at": "2025-06-14T00:00:00.000-03:00",
      "end_at": "2025-06-15T23:59:59.999-03:00",
      "created_at": "2025-06-14T20:54:27.060-03:00",
      "updated_at": "2025-06-14T20:54:32.354-03:00",
      "platform": "IOS",
      "services": {
        "id": 0,
        "name": "Mobile Penetration Testing"
      },
      "assessment": {
        "status": "COMPLETED",
        "id": "73d80983-0bf2-4c0c-9f8b-17d7222e3161",
        "name": null,
        "company_id": 1,
        "company": {
          "id": 1,
          "name": "Just Mobile Security"
        }
      },
      "scans": [
        {
          "id": "3f38e009-2c1f-4631-8e50-5899f517a024",
          "aat_version": "0.1.0-beta-2",
          "scan_status": "FINISHED",
          "created_at": "2025-06-14T20:54:27.217-03:00",
          "updated_at": "2025-06-14T20:54:32.301-03:00",
          "type": "SAST",
          "app_id": "2f4f485b-9ce2-499b-8de9-51a3d57576e6",
          "assessment_service_id": 4,
          "app": {
            "id": "2f4f485b-9ce2-499b-8de9-51a3d57576e6",
            "name": "challenge",
            "description": "justmobilesecurity.challenge",
            "created_at": "2025-06-14T20:54:27.212-03:00",
            "updated_at": "2025-06-14T20:54:28.436-03:00",
            "version": null,
            "icon": {
              "url": "http://storage.fakedomain.com/bucket-storage/assessments/73d80983-0bf2-4c0c-9f8b-17d7222e3161/service/4/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T012947Z&X-Amz-Expires=600&X-Amz-Signature=67e5fb9f459e5d6444db68d3b9745ff06c3f665c355a6a8f311a478e010dcc45&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
              "name": "assessments/73d80983-0bf2-4c0c-9f8b-17d7222e3161/service/4/icon.png",
              "extname": "png",
              "size": 16415,
              "mimeType": "image/png"
            }
          }
        }
      ],
      "summary": {
        "appId": "2f4f485b-9ce2-499b-8de9-51a3d57576e6",
        "name": "challenge",
        "description": "justmobilesecurity.challenge",
        "platform": "IOS",
        "version": "",
        "createdAt": "2025-06-14T20:54:27.217-03:00",
        "finishedAt": "2025-06-14T20:54:32.301-03:00",
        "statusId": 5,
        "status": "Incomplete",
        "duration": {
          "days": 0,
          "hours": 0,
          "minutes": 0,
          "seconds": 5,
          "milliseconds": 84,
          "human": "5 seconds"
        },
        "file": {
          "name": "assessments/73d80983-0bf2-4c0c-9f8b-17d7222e3161/service/4/challenge.ipa",
          "size": "1.45 MB"
        },
        "icon": "http://storage.fakedomain.com/bucket-storage/assessments/73d80983-0bf2-4c0c-9f8b-17d7222e3161/service/4/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T034026Z&X-Amz-Expires=600&X-Amz-Signature=525db8dc95dcb254e667b08bb7cfa8ea68924024a939e9c0b820f255aa182e3b&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
        "start_date": "2025-06-14T00:00:00.000-03:00",
        "end_date": "2025-06-15T23:59:59.999-03:00"
      },
      "vulnerabilities": [
        {
          "vulnerabilityId": "f3076e8b-e9b0-4bfb-b89e-d40e414a660c",
          "title": "Insecure App Transport Security Policy Does Not Conform With Best Practices",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>App Transport Security (ATS) is a set of security checks iOS enforces when connecting to public hosts using <b>NSURLConnection</b>, <b>NSURLSession</b>, or <b>CFURL</b>. ATS is enabled by default for applications that were built from the iOS 9 SDK and later versions. The assessment team found that the <b>challenge</b> application’s Info.plist configuration file did not conform with best practices on <b>NSAppTransportSecurityPolicy</b> transport encryption.</p>\n",
              "remediation": "<p>The assessment team recommends reconsidering these ATS security overrides, reverting to the higher-security defaults if they are or can be made compatible with the business logic.</p>\n<ul>\n<li>The NSAllowArbitraryLoads key defaults to no. Setting it to yes opts out of ATS and its security benefits.</li>\n<li>NSExceptionAllowsInsecureHTTPLoads also defaults to no. When set to yes, applications can send HTTP traffic to the specified domain. For any such domains, it is important to consider all data which could be sent to the specified domain, understanding that all data sent or received via HTTP is vulnerable to interception and tampering.</li>\n</ul>\n",
              "impact": "<p>App Transport Security includes the following default requirements:</p>\n<ul>\n<li>Unencrypted HTTP connections are not allowed.</li>\n<li>X.509 certificates must have SHA256 fingerprints, and must be signed using at least a 2048-bit RSA key or a 256-bit Elliptic Curve Cryptography (ECC) key.</li>\n<li>Transport Layer Security (TLS) must be version 1.2 or above, and must support Perfect Forward Secrecy (PFS) through Elliptic Curve Diffie-Hellman Ephemeral (ECDHE) key exchange and also AES-128 or AES-256 symmetric ciphers.\nThe following security exception was found: NSExceptionAllowsInsecureHTTPLoads. When this key is set to YES, the app will be allowed to send unencrypted HTTP traffic to the configured domain.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>App Transport Security (ATS) es un conjunto de comprobaciones de seguridad implementadas por iOS cuando se conecta a hosts públicos con <b>NSURLConnection</b>, <b>NSURLSession</b> o <b>CFURL</b>. ATS está activado de manera predeterminada para aplicaciones desarrolladas con iOS 9 SDK o versiones posteriores. El equipo de evaluación descubrió que el archivo de configuración Info.plist de la aplicación de <b>challenge</b> no realizaba las prácticas recomendadas relacionadas con la encriptación tráfico <b>NSAppTransportSecurityPolicy</b>.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda reconsiderar estas invalidaciones de seguridad de ATS y regresar a las configuraciones predeterminadas más seguras si son compatibles con la lógica de la compañía o si se puede lograr que lo sean.</p>\n<ul>\n<li>El estado predeterminado de NSAllowArbitraryLoads es \"no\". Configurarla como \"yes\" excluye la ATS y sus beneficios de seguridad.</li>\n<li>El estado predeterminado de NSExceptionAllowsInsecureHTTPLoads también es \"no\". Cuando se elige \"yes\", las aplicaciones pueden enviar tráfico HTTP al dominio especificado, y toda la información envidada o recibida a través de HTTP puede ser interceptada y manipulada.</li>\n</ul>\n",
              "impact": "<p>ATS incluye los siguientes requisitos predeterminados:</p>\n<ul>\n<li>No se permiten conexiones HTTP sin encriptar.</li>\n<li>Los certificados X.509 deben tener huellas digitales SHA256 y deben estar firmadas con una clave de al menos 2048 bits o con una clave de criptografía de curva elíptica (ECC) de 256 bits.</li>\n<li>La versión de la seguridad de la capa de transporte (Transport Layer Security o TLS) debe ser 1.2 o posterior, y debe ser compatible con la función de confidencialidad directa total (PFS) a través de un intercambio de claves  Elliptic Curve Diffie-Hellman Ephemeral (ECDHE) y con cifrados simétricos AES-128 o AES-256.\nSe encontró la siguiente excepción de seguridad: NSExceptionAllowsInsecureHTTPLoads. Cuando esto está configurado como YES, la aplicación podrá enviar tráfico HTTP sin encriptar al dominio configurado.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Apple Developer Documentation: NSAllowArbitraryLoads",
              "url": "https://developer.apple.com/documentation/bundleresources/information_property_list/nsapptransportsecurity/nsallowsarbitraryloads"
            },
            {
              "label": "Apple Developer Documentation: NSExceptionDomains",
              "url": "https://developer.apple.com/documentation/bundleresources/information_property_list/nsapptransportsecurity/nsexceptiondomains"
            },
            {
              "label": "A security analyst's guide to App Transport Security (ATS) exceptions",
              "url": "https://www.nowsecure.com/blog/2017/08/31/security-analysts-guide-nsapptransportsecurity-nsallowsarbitraryloads-app-transport-security-ats-exceptions/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-NETWORK-1",
            "maswe": "MASWE-0050"
          },
          "evidences": [
            {
              "id": "9680dcb4-349f-4177-83f7-0e7f7e85b853",
              "value": "<key>NSAppTransportSecurity</key>\n\t<dict>\n\t\t<key>NSAllowsArbitraryLoads</key>\n\t\t<false/>\n\t\t<key>NSAllowsArbitraryLoadsForMedia</key>",
              "vulnerability_id": "f3076e8b-e9b0-4bfb-b89e-d40e414a660c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/Payload/challenge.app/Info.xml.plist",
              "file_line": [
                259
              ],
              "extra": "text",
              "file": null,
              "created_at": "2025-06-14T20:54:32.086-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c3705fc9-f8e7-462f-a9f7-0aa16b36cdee",
              "value": "<key>NSAllowsArbitraryLoads</key>\n\t\t<false/>\n\t\t<key>NSAllowsArbitraryLoadsForMedia</key>\n\t\t<true/>\n\t\t<key>NSAllowsArbitraryLoadsForMediaUsageDescription</key>",
              "vulnerability_id": "f3076e8b-e9b0-4bfb-b89e-d40e414a660c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/Payload/challenge.app/Info.xml.plist",
              "file_line": [
                261
              ],
              "extra": "text",
              "file": null,
              "created_at": "2025-06-14T20:54:32.146-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e2f082f6-9057-4170-8af2-b78c7b63c637",
              "value": "<key>NSAllowsArbitraryLoadsForMedia</key>\n\t\t<true/>\n\t\t<key>NSAllowsArbitraryLoadsForMediaUsageDescription</key>\n\t\t<dict/>\n\t\t<key>NSAllowsArbitraryLoadsInWebContent</key>",
              "vulnerability_id": "f3076e8b-e9b0-4bfb-b89e-d40e414a660c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/Payload/challenge.app/Info.xml.plist",
              "file_line": [
                263
              ],
              "extra": "text",
              "file": null,
              "created_at": "2025-06-14T20:54:32.165-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e92e2c94-b869-43ce-a6a8-8d983d88b22e",
              "value": "<key>NSAllowsArbitraryLoadsForMediaUsageDescription</key>\n\t\t<dict/>\n\t\t<key>NSAllowsArbitraryLoadsInWebContent</key>\n\t\t<false/>\n\t\t<key>NSAllowsArbitraryLoadsInWebContentUsageDescription</key>",
              "vulnerability_id": "f3076e8b-e9b0-4bfb-b89e-d40e414a660c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/Payload/challenge.app/Info.xml.plist",
              "file_line": [
                265
              ],
              "extra": "text",
              "file": null,
              "created_at": "2025-06-14T20:54:32.184-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d4997964-a910-4257-b07a-fc602f1bbe0f",
              "value": "<key>NSAllowsArbitraryLoadsInWebContent</key>\n\t\t<false/>\n\t\t<key>NSAllowsArbitraryLoadsInWebContentUsageDescription</key>\n\t\t<dict>\n\t\t\t<key>NSATSExceptionUsage</key>",
              "vulnerability_id": "f3076e8b-e9b0-4bfb-b89e-d40e414a660c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/Payload/challenge.app/Info.xml.plist",
              "file_line": [
                267
              ],
              "extra": "text",
              "file": null,
              "created_at": "2025-06-14T20:54:32.216-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6ac3ae30-2c3a-4742-90fd-47f5b1b4a6a4",
              "value": "</dict>\n\t\t</dict>\n\t\t<key>NSAllowsArbitraryLoadsUsageDescription</key>\n\t\t<dict>\n\t\t\t<key>NSATSExceptionServiceType</key>",
              "vulnerability_id": "f3076e8b-e9b0-4bfb-b89e-d40e414a660c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/Payload/challenge.app/Info.xml.plist",
              "file_line": [
                277
              ],
              "extra": "text",
              "file": null,
              "created_at": "2025-06-14T20:54:32.248-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8afaeb72-e65e-4abf-a37f-8ba09c76da8a",
              "value": "<key>NSAllowsLocalNetworkingUsageDescription</key>\n\t\t<dict/>\n\t\t<key>NSExceptionDomains</key>\n\t\t<dict/>\n\t\t<key>New item</key>",
              "vulnerability_id": "f3076e8b-e9b0-4bfb-b89e-d40e414a660c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/Payload/challenge.app/Info.xml.plist",
              "file_line": [
                295
              ],
              "extra": "text",
              "file": null,
              "created_at": "2025-06-14T20:54:32.285-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 3
        }
      ],
      "severityDistribution": {
        "medium": 100
      },
      "severityCount": {
        "medium": 1
      },
      "properties": {
        "MIN_SDK": 17.2,
        "MD5": "95fa9ffa61de234a5a59b8afcad44755",
        "SHA1": "c2757f81de0201096e8d35dc667d972a80f1dc4d",
        "SHA256": "1f2085ad636c222fe5289a233a5263338aec13652c8a4d20bf4c292ff2c8401f",
        "VERSION": 1,
        "ARCH": "arm",
        "BITS": 64,
        "COMPILER": "clang",
        "CRYPTO": false,
        "LANG": "swift",
        "LIBRARIES": [
          "/System/Library/Frameworks/Foundation.framework/Foundation",
          "/usr/lib/libobjc.A.dylib",
          "/usr/lib/libSystem.B.dylib",
          "/System/Library/Frameworks/UIKit.framework/UIKit",
          "/usr/lib/swift/libswiftCore.dylib",
          "/usr/lib/swift/libswiftCoreFoundation.dylib",
          "/usr/lib/swift/libswiftCoreImage.dylib",
          "/usr/lib/swift/libswiftDarwin.dylib",
          "/usr/lib/swift/libswiftDataDetection.dylib",
          "/usr/lib/swift/libswiftDispatch.dylib",
          "/usr/lib/swift/libswiftFileProvider.dylib",
          "/usr/lib/swift/libswiftMetal.dylib",
          "/usr/lib/swift/libswiftOSLog.dylib",
          "/usr/lib/swift/libswiftObjectiveC.dylib",
          "/usr/lib/swift/libswiftQuartzCore.dylib",
          "/usr/lib/swift/libswiftUniformTypeIdentifiers.dylib",
          "/usr/lib/swift/libswiftos.dylib"
        ],
        "FRAMEWORK": "Native Objective-C",
        "BINARY_PROTECTIONS": {
          "encrypted": false,
          "pie": true,
          "canary": true,
          "arc": true
        }
      },
      "permissions": [],
      "components": [],
      "protections": [
        {
          "type": "frida",
          "name": "Frida Detection (iOS)",
          "category": [
            "MASVS-RESILIENCE-4"
          ],
          "protectors": []
        },
        {
          "type": "hooking_detection",
          "name": "Hooking Detection",
          "category": [
            "MASVS-RESILIENCE-4"
          ],
          "protectors": []
        },
        {
          "type": "anti_jailbreak",
          "name": "Jailbreak Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": []
        },
        {
          "type": "package_managers",
          "name": "Package Managers Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": []
        },
        {
          "type": "tweaks_detection",
          "name": "Tweaks Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": []
        }
      ]
    },
    {
      "id": 3,
      "status": "COMPLETED",
      "start_at": "2025-06-14T00:00:00.000-03:00",
      "end_at": "2025-06-15T23:59:59.999-03:00",
      "created_at": "2025-06-14T20:54:05.650-03:00",
      "updated_at": "2025-06-14T20:56:27.541-03:00",
      "platform": "ANDROID",
      "services": {
        "id": 0,
        "name": "Mobile Penetration Testing"
      },
      "assessment": {
        "status": "COMPLETED",
        "id": "4d6c1939-2ca2-47ff-b189-bec25196b3f5",
        "name": null,
        "company_id": 1,
        "company": {
          "id": 1,
          "name": "Just Mobile Security"
        }
      },
      "scans": [
        {
          "id": "cb5de231-e8f0-46cc-9cfe-e2a7e8175de3",
          "aat_version": "0.1.0-beta-2",
          "scan_status": "FINISHED",
          "created_at": "2025-06-14T20:54:06.508-03:00",
          "updated_at": "2025-06-14T20:56:27.512-03:00",
          "type": "SAST",
          "app_id": "ed990a61-9383-48ad-81c4-c0f004594122",
          "assessment_service_id": 3,
          "app": {
            "id": "ed990a61-9383-48ad-81c4-c0f004594122",
            "name": "Challenge 3",
            "description": "com.just.mobile.sec.challenge3",
            "created_at": "2025-06-14T20:54:06.480-03:00",
            "updated_at": "2025-06-14T20:54:24.452-03:00",
            "version": null,
            "icon": {
              "url": "http://storage.fakedomain.com/bucket-storage/assessments/4d6c1939-2ca2-47ff-b189-bec25196b3f5/service/3/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T012947Z&X-Amz-Expires=600&X-Amz-Signature=a5a6c9b9687b653a7fb8ba0dad06c7644e11f7f3abbc90ebfdff76bc46f4477e&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
              "name": "assessments/4d6c1939-2ca2-47ff-b189-bec25196b3f5/service/3/icon.png",
              "extname": "png",
              "size": 6437,
              "mimeType": "image/png"
            }
          }
        }
      ],
      "summary": {
        "appId": "ed990a61-9383-48ad-81c4-c0f004594122",
        "name": "Challenge 3",
        "description": "com.just.mobile.sec.challenge3",
        "platform": "ANDROID",
        "version": "",
        "createdAt": "2025-06-14T20:54:06.508-03:00",
        "finishedAt": "2025-06-14T20:56:27.512-03:00",
        "statusId": 5,
        "status": "Incomplete",
        "duration": {
          "days": 0,
          "hours": 0,
          "minutes": 2,
          "seconds": 21,
          "milliseconds": 4,
          "human": "2 minutes"
        },
        "file": {
          "name": "assessments/4d6c1939-2ca2-47ff-b189-bec25196b3f5/service/3/Challenge_3.apk",
          "size": "3.37 MB"
        },
        "icon": "http://storage.fakedomain.com/bucket-storage/assessments/4d6c1939-2ca2-47ff-b189-bec25196b3f5/service/3/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T033857Z&X-Amz-Expires=600&X-Amz-Signature=4a2804e37981b21a4a138c9c9ec35fb77af3052ecf8c9b3a5bd4a7d94655959a&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
        "start_date": "2025-06-14T00:00:00.000-03:00",
        "end_date": "2025-06-15T23:59:59.999-03:00"
      },
      "vulnerabilities": [
        {
          "vulnerabilityId": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
          "title": "SQL Injection",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team discovered potential SQL Injection (SQLi) vulnerabilities in the decompiled source code of the <b>Challenge 3</b> Android application, specifically in how the application handles SQL database operations. The critical findings include the use of methods such as insert, delete, query, execSQL, and rawQuery without proper input validation or parameterization. This opens up possible attack vectors if these database operations interact with external inputs. For example, if these methods are triggered via deeplinks, interceptable network communications, or manipulated within insecure WebViews, they could potentially be exploited remotely. Such vulnerabilities are particularly concerning as they could allow an attacker to inject malicious SQL queries to manipulate or exfiltrate data from the application’s local databases, posing significant risks to data integrity and security.</p>\n<p>The following code snippet shows the insecure implementation.</p>\n",
              "remediation": "<p>The assessment team recommends the following:</p>\n<ul>\n<li>Implement Parameterized Queries: Replace all raw SQL query constructions with parameterized queries to prevent SQL injection. This practice ensures that input values are treated as data, not executable code.\n</li>\n<li>Validate and Sanitize Inputs: Rigorously validate and sanitize all inputs, especially those obtained from external sources such as deeplinks, network communications, or WebViews. Ensure that inputs conform to expected formats and do not contain malicious SQL code.\n</li>\n<li>Secure WebViews: If the application uses WebViews, ensure they are configured securely. Disable JavaScript execution if not needed, and restrict interaction between the WebView and the application to minimize exposure to injection attacks.\n</li>\n<li>Review and Restrict Database Permissions: Restrict the database permissions to the minimum necessary for the application to function. This minimizes the potential damage from an SQL injection attack by limiting what an attacker can do within the database.</li>\n</ul>\n",
              "impact": "<p>An attacker could potentially execute unauthorized SQL commands, leading to data manipulation or exfiltration. This could result in the compromise of sensitive user data stored within the application&#39;s databases, such as personal details, credentials, financial information or disrupt application functionality. The ability to exploit these vulnerabilities remotely via methods like deeplinks or insecure WebViews significantly increases the severity of the threat, expanding the potential for widespread impact on users.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación halló una posible vulnerabilidad de inyección de SQL (SQLi) en el código fuente sin compilar de la aplicación Android <b>Challenge 3</b>, específicamente, en la manera en la que la aplicación maneja las operaciones de bases de datos de SQL. Estos hallazgos críticos incluyen el uso de métodos (como insert, delete, query, execSQL y rawQuery) sin una validación o parametrización apropiada de las entradas. Esto habilita posibles vectores de ataque si estas operaciones de base de datos interactúan con entradas externas. Por ejemplo, si estos métodos son activadios a través enlaces profundos o comunicaciones de red interceptables, o si se manipulan en vistas web inseguras, podrían explotarse de manera remota. Estas vulnerabilidades son particularmente preocupantes, ya que podrían permitirle a un atacante inyectar consultas SQL malintencionadas para manipular o extraer información de las bases de datos locales de la aplicación, lo cual implica un gran riesgo para la seguridad y la integridad de la información.</p>\n<p>El siguiente fragmento de código muestra la implementación segura.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda lo siguiente:</p>\n<ul>\n<li>Implementar consultas parametrizadas: reemplace todas las construcciones de consultas SQL sin formato con consultas parametrizadas para evitar la inyección de SQL. Esta práctica garantiza que los valores de entrada se traten como datos, y no como código ejecutable.\n</li>\n<li>Validar y desinfectar entradas: valide y desinfecte rigurosamente todas las entradas, especialmente aquellas obtenidas de fuentes externas, como enlaces profundos, comunicaciones de red o vistas web. Asegúrese de que las entradas se ajusten a los formatos esperados y no contengan código SQL malintencionado.\n</li>\n<li>Vistas web seguras: si la aplicación utiliza vistas web, asegúrese de que estén configurados de manera segura. Deshabilite la ejecución de JavaScript si no es necesario y restrinja la interacción entre las vistas web y la aplicación para minimizar la exposición a ataques de inyección.\n</li>\n<li>Revisar y restringir los permisos de la base de datos: mantenga los permisos de la base de datos al mínimo necesario para que la aplicación funcione. Esto minimiza el daño potencial de un ataque de inyección SQL al limitar lo que un atacante puede hacer dentro de la base de datos</li>\n</ul>\n",
              "impact": "<p>Un atacante podría ejecutar comandos SQL no autorizados, lo que llevaría a la manipulación o extracción de datos. Esto podría poner en peligro la información sensible de los usuarios almacenada en las bases de datos de la aplicación (como detalles personales, credenciales, información financiera) o interrumpir la funcionalidad de la aplicación. La capacidad de explotar estas vulnerabilidades de manera remota mediante enlaces profundos o vistas web inseguras aumenta significativamente la gravedad de la amenaza y amplía el potencial de un impacto generalizado en los usuarios.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "SQL injection | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sql-injection"
            },
            {
              "label": "V10: Code Quality Requirements - OWASP MASVS",
              "url": "https://mas.owasp.org/MASVS/10-MASVS-CODE/"
            },
            {
              "label": "MASVS-CODE-2.5: Security Control Verification Requirements | OWASP MASTG",
              "url": "https://mas.owasp.org/MASTG/tests/android/MASVS-CODE/MASTG-TEST-0025/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0086"
          },
          "evidences": [
            {
              "id": "1265ce9c-d153-48e3-81f2-3ff6e9f1474c",
              "value": "r0 = e;\n      */\n         r0 = e;\n      */\n         r13 = true;\n      */\n         ((com.google.android.gms.measurement.internal.zzge) r8).zzx.zzat().zzb().zzc(\"Error pruning currencies. appId\", com.google.android.gms.measurement.internal.zzei.zzl(r10), r0);\n      */\n         if (r14.size() != 0) goto L176;\n      */\n         r17 = 1;\n      */\n         r0 = e;\n      */\n     \n     final void zzC(com.google.android.gms.measurement.internal.zzas r35, com.google.android.gms.measurement.internal.zzp r36) {\n         \n         throw new UnsupportedOperationException(\"Method not decompiled: com.aat.Cls5C5D6GGR2X5XG32.zzC(com.google.android.gms.measurement.internal.zzas, com.google.android.gms.measurement.internal.zzp):void\");\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                8821
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.835-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8fd0d6de-9483-41f2-b950-93f67ae1441c",
              "value": "private void dropTable(SQLiteDatabase sQLiteDatabase, String str) {\n         sQLiteDatabase.execSQL(\"DROP TABLE IF EXISTS \" + str);\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine$PersistentCacheOpenHelper.java",
              "file_line": [
                53
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.920-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5de83156-a109-4826-b0b4-532db56f5a5e",
              "value": "public final int zzp(String str, String str2) {\n         Preconditions.checkNotEmpty(str);\n         Preconditions.checkNotEmpty(str2);\n         zzg();\n         zzX();\n         try {\n             return zze().delete(\"conditional_properties\", \"app_id=? and name=?\", new String[]{str, str2});\n         } catch (SQLiteException e) {\n             ((zzge) this).zzx.zzat().zzb().zzd(\"Error deleting conditional property\", zzei.zzl(str), ((zzge) this).zzx.zzm().zze(str2), e);\n             return 0;\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzai.java",
              "file_line": [
                6620
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.057-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9b3037a2-c818-45fc-9ca9-121d91ea658f",
              "value": "r0 = e;\n      */\n         r0 = e;\n      */\n         r13 = true;\n      */\n         ((com.google.android.gms.measurement.internal.zzge) r8).zzx.zzat().zzb().zzc(\"Error pruning currencies. appId\", com.google.android.gms.measurement.internal.zzei.zzl(r10), r0);\n      */\n         if (r14.size() != 0) goto L176;\n      */\n         r17 = 1;\n      */\n         r0 = e;\n      */\n     \n     final void zzC(com.google.android.gms.measurement.internal.zzas r35, com.google.android.gms.measurement.internal.zzp r36) {\n         \n         throw new UnsupportedOperationException(\"Method not decompiled: com.aat.Cls42VXHJ1HWC29U4S.zzC(com.google.android.gms.measurement.internal.zzas, com.google.android.gms.measurement.internal.zzp):void\");\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                9583
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.309-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0c6e853a-1368-413f-ac8c-906cc133e531",
              "value": "private int removeNested(String str, Path path) {\n         String pathToKey = SqlPersistenceStorageEngine.pathToKey(path);\n         return ((SqlPersistenceStorageEngine) this).database.delete(str, \"path >= ? AND path < ?\", new String[]{pathToKey, SqlPersistenceStorageEngine.pathPrefixStartToPrefixEnd(pathToKey)});\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine.java",
              "file_line": [
                1497
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.422-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1be867cf-93b8-49bf-ac90-ebbcb3399024",
              "value": "public void purgeCache() {\n         verifyInsideTransaction();\n         ((SqlPersistenceStorageEngine) this).database.delete(\"serverCache\", null, null);\n         ((SqlPersistenceStorageEngine) this).database.delete(\"writes\", null, null);\n         ((SqlPersistenceStorageEngine) this).database.delete(\"trackedQueries\", null, null);\n         ((SqlPersistenceStorageEngine) this).database.delete(\"trackedKeys\", null, null);\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine.java",
              "file_line": [
                3889
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.611-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f1a364bf-fb67-42e8-b339-8e3d9073daeb",
              "value": "private SQLiteDatabase openDatabase(Context context, String str) {\n         try {\n             SQLiteDatabase writableDatabase = new SqlPersistenceStorageEngine.PersistentCacheOpenHelper(context, str).getWritableDatabase();\n             writableDatabase.rawQuery(\"PRAGMA locking_mode = EXCLUSIVE\", null).close();\n             writableDatabase.beginTransaction();\n             writableDatabase.endTransaction();\n             return writableDatabase;\n         } catch (SQLiteException e) {\n             if (e instanceof SQLiteDatabaseLockedException) {\n                 throw new DatabaseException(\"Failed to gain exclusive lock to Firebase Database's offline persistence. This generally means you are using Firebase Database from multiple processes in your app. Keep in mind that multi-process Android apps execute the code in your Application class in all processes, so you may need to avoid initializing FirebaseDatabase in your Application class. If you are intentionally using Firebase Database from multiple processes, you can only enable offline persistence (i.e. call setPersistenceEnabled(true)) in one of them.\", e);\n             }\n             throw e;\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine.java",
              "file_line": [
                1097
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.981-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4cd22d64-627a-4203-93b6-f77a5e28de80",
              "value": "public final void zzh() {\n         int delete;\n         zzg();\n         try {\n             SQLiteDatabase zzo = zzo();\n             if (zzo == null || (delete = zzo.delete(\"messages\", null, null)) <= 0) {\n                 return;\n             }\n             ((zzge) this).zzx.zzat().zzk().zzb(\"Reset local analytics data. records\", Integer.valueOf(delete));\n         } catch (SQLiteException e) {\n             ((zzge) this).zzx.zzat().zzb().zzb(\"Error resetting local analytics data. error\", e);\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzec.java",
              "file_line": [
                534
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.097-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d5387ecf-ee80-4169-b5d8-3b02c81ec679",
              "value": "if (r10 > (com.google.android.gms.measurement.internal.zzae.zzA() + r8)) goto L341;\n      */\n     \n     private final boolean zzae(String str, long j) {\n         String str2;\n         long j2;\n         long j3;\n         zzdi zzdiVar;\n         zzkc zzkcVar;\n         long parseLong;\n         int zzk;\n         zzkc zzkcVar2;\n         SecureRandom secureRandom;\n         zzdi zzdiVar2;\n         Long l;\n         Map map;\n         long zzab;\n         Map map2;\n         zzdi zzdiVar3;\n         ClsGCNUGCP9VYAIUHS clsGCNUGCP9VYAIUHS;\n         zzai zzi;\n         zzdj zzaA;\n         long currentTimeMillis;\n         long zzo;\n         ContentValues contentValues;\n         zzg zzs;\n         String str3;\n         String str4;\n         boolean z;\n         int i;\n         String str5;\n         zzdi zzdiVar4;\n         int i2;\n         String str6;\n         String str7;\n         zzdi zzdiVar5;\n         int i3;\n         String str8;\n         zzdi zzdiVar6;\n         int i4;\n         int i5;\n         String str9;\n         String str10;\n         int i6;\n         zzda zzdaVar;\n         int i7;\n         int i8;\n         zzda zzdaVar2;\n         char c;\n         ClsGCNUGCP9VYAIUHS clsGCNUGCP9VYAIUHS2 = this;\n         String str11 = \"_sn\";\n         String str12 = \"_npa\";\n         String str13 = \"_ai\";\n         zzi().zzb();\n         try {\n             zzkc zzkcVar3 = new zzkc(clsGCNUGCP9VYAIUHS2, (zzjw) null);\n             zzi().zzU((String) null, j, ((zzkd) clsGCNUGCP9VYAIUHS2).zzy, zzkcVar3);\n             List list = zzkcVar3.zzc;\n             try {\n                 if (list != null && !list.isEmpty()) {\n                     zzdi zzbu = zzkcVar3.zza.zzbu();\n                     zzbu.zzh();\n                     boolean zzn = ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzc().zzn(zzkcVar3.zza.zzA(), zzdw.zzT);\n                     zzda zzdaVar3 = null;\n                     zzda zzdaVar4 = null;\n                     int i9 = -1;\n                     int i10 = 0;\n                     int i11 = -1;\n                     long j4 = 0;\n                     int i12 = 0;\n                     int i13 = 0;\n                     while (true) {\n                         String str14 = \"_fr\";\n                         String str15 = \"_et\";\n                         str2 = str12;\n                         j2 = j4;\n                         if (i10 >= zzkcVar3.zzc.size()) {\n                             break;\n                         }\n                         zzda zzdaVar5 = (zzda) ((zzdb) zzkcVar3.zzc.get(i10)).zzbu();\n                         int i14 = i10;\n                         if (zzf().zzi(zzkcVar3.zza.zzA(), zzdaVar5.zzk())) {\n                             ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zze().zzc(\"Dropping blacklisted raw event. appId\", zzei.zzl(zzkcVar3.zza.zzA()), ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzm().zzc(zzdaVar5.zzk()));\n                             if (!zzf().zzl(zzkcVar3.zza.zzA()) && !zzf().zzm(zzkcVar3.zza.zzA()) && !\"_err\".equals(zzdaVar5.zzk())) {\n                                 ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzl().zzM(((zzkd) clsGCNUGCP9VYAIUHS2).zzA, zzkcVar3.zza.zzA(), 11, \"_ev\", zzdaVar5.zzk(), 0);\n                             }\n                             str3 = str13;\n                             zzdiVar6 = zzbu;\n                             z = zzn;\n                             j4 = j2;\n                             i7 = i14;\n                             str10 = str11;\n                         } else {\n                             if (zzdaVar5.zzk().equals(zzgi.zza(str13))) {\n                                 zzdaVar5.zzl(str13);\n                                 ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zzk().zza(\"Renaming ad_impression to _ai\");\n                                 if (Log.isLoggable(((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zzn(), 5)) {\n                                     int i15 = 0;\n                                     while (i15 < zzdaVar5.zzb()) {\n                                         String str16 = str13;\n                                         if (\"ad_platform\".equals(zzdaVar5.zzc(i15).zzb()) && !TextUtils.isEmpty(zzdaVar5.zzc(i15).zzd()) && \"admob\".equalsIgnoreCase(zzdaVar5.zzc(i15).zzd())) {\n                                             ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zzh().zza(\"AdMob ad impression logged from app. Potentially duplicative.\");\n                                         }\n                                         i15++;\n                                         str13 = str16;\n                                     }\n                                 }\n                             }\n                             str3 = str13;\n                             boolean zzj = zzf().zzj(zzkcVar3.zza.zzA(), zzdaVar5.zzk());\n                             if (zzj) {\n                                 str4 = str11;\n                                 z = zzn;\n                             } else {\n                                 zzn();\n                                 String zzk2 = zzdaVar5.zzk();\n                                 Preconditions.checkNotEmpty(zzk2);\n                                 z = zzn;\n                                 int hashCode = zzk2.hashCode();\n                                 str4 = str11;\n                                 if (hashCode == 94660) {\n                                     if (zzk2.equals(\"_in\")) {\n                                         c = 0;\n                                         if (c != 0) {\n                                         }\n                                     }\n                                     c = 65535;\n                                     if (c != 0) {\n                                     }\n                                 } else if (hashCode != 95025) {\n                                     if (hashCode == 95027 && zzk2.equals(\"_ui\")) {\n                                         c = 1;\n                                         if (c != 0 && c != 1 && c != 2) {\n                                             i2 = i9;\n                                             str6 = \"_fr\";\n                                             str5 = \"_et\";\n                                             i = i11;\n                                             zzj = false;\n                                             str7 = \"_e\";\n                                             zzdiVar4 = zzbu;\n                                             if (zzj) {\n                                                 ArrayList arrayList = new ArrayList(zzdaVar5.zza());\n                                                 int i16 = -1;\n                                                 int i17 = -1;\n                                                 for (int i18 = 0; i18 < arrayList.size(); i18++) {\n                                                     if (\"value\".equals(((zzdf) arrayList.get(i18)).zzb())) {\n                                                         i16 = i18;\n                                                     } else if (\"currency\".equals(((zzdf) arrayList.get(i18)).zzb())) {\n                                                         i17 = i18;\n                                                     }\n                                                 }\n                                                 if (i16 != -1) {\n                                                     if (((zzdf) arrayList.get(i16)).zze() || ((zzdf) arrayList.get(i16)).zzi()) {\n                                                         if (i17 != -1) {\n                                                             String zzd = ((zzdf) arrayList.get(i17)).zzd();\n                                                             if (zzd.length() == 3) {\n                                                                 int i19 = 0;\n                                                                 while (i19 < zzd.length()) {\n                                                                     int codePointAt = zzd.codePointAt(i19);\n                                                                     if (Character.isLetter(codePointAt)) {\n                                                                         i19 += Character.charCount(codePointAt);\n                                                                     }\n                                                                 }\n                                                             }\n                                                         }\n                                                         ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zzh().zza(\"Value parameter discarded. You must also supply a 3-letter ISO_4217 currency code in the currency parameter.\");\n                                                         zzdaVar5.zzj(i16);\n                                                         zzkd.zzad(zzdaVar5, \"_c\");\n                                                         zzkd.zzac(zzdaVar5, 19, \"currency\");\n                                                         break;\n                                                     }\n                                                     ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zzh().zza(\"Value must be specified with a numeric type.\");\n                                                     zzdaVar5.zzj(i16);\n                                                     zzkd.zzad(zzdaVar5, \"_c\");\n                                                     zzkd.zzac(zzdaVar5, 18, \"value\");\n                                                 }\n                                                 if (str7.equals(zzdaVar5.zzk())) {\n                                                     zzdiVar6 = zzdiVar4;\n                                                     i4 = i2;\n                                                     if (\"_vs\".equals(zzdaVar5.zzk())) {\n                                                         zzn();\n                                                         str9 = str5;\n                                                         if (zzkf.zzz(zzdaVar5.zzaA(), str9) == null) {\n                                                             if (zzdaVar3 == null || Math.abs(zzdaVar3.zzn() - zzdaVar5.zzn()) > 1000) {\n                                                                 i11 = i;\n                                                                 zzdaVar4 = zzdaVar5;\n                                                                 i9 = i12;\n                                                             } else {\n                                                                 zzda zzay = zzdaVar3.zzay();\n                                                                 if (clsGCNUGCP9VYAIUHS2.zzag(zzay, zzdaVar5)) {\n                                                                     i6 = i;\n                                                                     zzdiVar6.zze(i6, zzay);\n                                                                     i9 = i4;\n                                                                     zzdaVar = null;\n                                                                     zzdaVar3 = null;\n                                                                 } else {\n                                                                     i6 = i;\n                                                                     zzdaVar = zzdaVar5;\n                                                                     i9 = i12;\n                                                                 }\n                                                                 zzdaVar4 = zzdaVar;\n                                                                 i11 = i6;\n                                                             }\n                                                             str10 = str4;\n                                                         } else {\n                                                             i5 = i;\n                                                             str10 = str4;\n                                                             i11 = i5;\n                                                             i9 = i4;\n                                                         }\n                                                     } else {\n                                                         i5 = i;\n                                                         str9 = str5;\n                                                         if (((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzc().zzn(zzkcVar3.zza.zzA(), zzdw.zzak) && \"_ab\".equals(zzdaVar5.zzk())) {\n                                                             zzn();\n                                                             if (zzkf.zzz(zzdaVar5.zzaA(), str9) == null && zzdaVar3 != null && Math.abs(zzdaVar3.zzn() - zzdaVar5.zzn()) <= 4000) {\n                                                                 zzda zzay2 = zzdaVar3.zzay();\n                                                                 clsGCNUGCP9VYAIUHS2.zzah(zzay2, zzdaVar5);\n                                                                 Preconditions.checkArgument(str7.equals(zzay2.zzk()));\n                                                                 zzn();\n                                                                 str10 = str4;\n                                                                 zzdf zzz = zzkf.zzz(zzay2.zzaA(), str10);\n                                                                 zzn();\n                                                                 zzdf zzz2 = zzkf.zzz(zzay2.zzaA(), \"_sc\");\n                                                                 zzn();\n                                                                 zzdf zzz3 = zzkf.zzz(zzay2.zzaA(), \"_si\");\n                                                                 String zzd2 = zzz != null ? zzz.zzd() : \"\";\n                                                                 if (!TextUtils.isEmpty(zzd2)) {\n                                                                     zzn();\n                                                                     zzkf.zzx(zzdaVar5, str10, zzd2);\n                                                                 }\n                                                                 String zzd3 = zzz2 != null ? zzz2.zzd() : \"\";\n                                                                 if (!TextUtils.isEmpty(zzd3)) {\n                                                                     zzn();\n                                                                     zzkf.zzx(zzdaVar5, \"_sc\", zzd3);\n                                                                 }\n                                                                 if (zzz3 != null) {\n                                                                     zzn();\n                                                                     zzkf.zzx(zzdaVar5, \"_si\", Long.valueOf(zzz3.zzf()));\n                                                                 }\n                                                                 zzdiVar6.zze(i5, zzay2);\n                                                                 i11 = i5;\n                                                                 i9 = i4;\n                                                                 zzdaVar3 = null;\n                                                             }\n                                                         }\n                                                         str10 = str4;\n                                                         i11 = i5;\n                                                         i9 = i4;\n                                                     }\n                                                     if (!z) {\n                                                     }\n                                                     j4 = j2;\n                                                     i7 = i14;\n                                                     zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                     i12++;\n                                                     zzdiVar6.zzf(zzdaVar5);\n                                                 } else {\n                                                     zzn();\n                                                     if (zzkf.zzz(zzdaVar5.zzaA(), str6) == null) {\n                                                         if (zzdaVar4 == null || Math.abs(zzdaVar4.zzn() - zzdaVar5.zzn()) > 1000) {\n                                                             zzdiVar6 = zzdiVar4;\n                                                             zzdaVar3 = zzdaVar5;\n                                                             i9 = i2;\n                                                             i11 = i12;\n                                                         } else {\n                                                             zzda zzay3 = zzdaVar4.zzay();\n                                                             if (clsGCNUGCP9VYAIUHS2.zzag(zzdaVar5, zzay3)) {\n                                                                 zzdiVar6 = zzdiVar4;\n                                                                 i8 = i2;\n                                                                 zzdiVar6.zze(i8, zzay3);\n                                                                 i11 = i;\n                                                                 zzdaVar2 = null;\n                                                                 zzdaVar4 = null;\n                                                             } else {\n                                                                 zzdiVar6 = zzdiVar4;\n                                                                 i8 = i2;\n                                                                 zzdaVar2 = zzdaVar5;\n                                                                 i11 = i12;\n                                                             }\n                                                             zzdaVar3 = zzdaVar2;\n                                                             i9 = i8;\n                                                         }\n                                                         str10 = str4;\n                                                         str9 = str5;\n                                                         if (!z && str7.equals(zzdaVar5.zzk())) {\n                                                             if (zzdaVar5.zzb() != 0) {\n                                                                 ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zze().zzb(\"Engagement event does not contain any parameters. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                                             } else {\n                                                                 zzn();\n                                                                 Long l2 = (Long) zzkf.zzA(zzdaVar5.zzaA(), str9);\n                                                                 if (l2 == null) {\n                                                                     ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zze().zzb(\"Engagement event does not include duration. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                                                 } else {\n                                                                     j4 = j2 + l2.longValue();\n                                                                     i7 = i14;\n                                                                     zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                                     i12++;\n                                                                     zzdiVar6.zzf(zzdaVar5);\n                                                                 }\n                                                             }\n                                                         }\n                                                         j4 = j2;\n                                                         i7 = i14;\n                                                         zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                         i12++;\n                                                         zzdiVar6.zzf(zzdaVar5);\n                                                     } else {\n                                                         zzdiVar6 = zzdiVar4;\n                                                         i4 = i2;\n                                                         i5 = i;\n                                                         str10 = str4;\n                                                         str9 = str5;\n                                                         i11 = i5;\n                                                         i9 = i4;\n                                                         if (!z) {\n                                                             if (zzdaVar5.zzb() != 0) {\n                                                             }\n                                                         }\n                                                         j4 = j2;\n                                                         i7 = i14;\n                                                         zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                         i12++;\n                                                         zzdiVar6.zzf(zzdaVar5);\n                                                     }\n                                                 }\n                                             }\n                                             if (str7.equals(zzdaVar5.zzk())) {\n                                             }\n                                         }\n                                     }\n                                     c = 65535;\n                                     if (c != 0) {\n                                         i2 = i9;\n                                         str6 = \"_fr\";\n                                         str5 = \"_et\";\n                                         i = i11;\n                                         zzj = false;\n                                         str7 = \"_e\";\n                                         zzdiVar4 = zzbu;\n                                         if (zzj) {\n                                         }\n                                         if (str7.equals(zzdaVar5.zzk())) {\n                                         }\n                                     }\n                                 } else {\n                                     if (zzk2.equals(\"_ug\")) {\n                                         c = 2;\n                                         if (c != 0) {\n                                         }\n                                     }\n                                     c = 65535;\n                                     if (c != 0) {\n                                     }\n                                 }\n                             }\n                             i = i11;\n                             int i20 = 0;\n                             boolean z2 = false;\n                             boolean z3 = false;\n                             while (true) {\n                                 str5 = str15;\n                                 if (i20 >= zzdaVar5.zzb()) {\n                                     break;\n                                 }\n                                 if (\"_c\".equals(zzdaVar5.zzc(i20).zzb())) {\n                                     zzde zzbu2 = zzdaVar5.zzc(i20).zzbu();\n                                     zzdiVar5 = zzbu;\n                                     i3 = i9;\n                                     zzbu2.zzd(1L);\n                                     zzdaVar5.zzd(i20, zzbu2.zzaA());\n                                     str8 = str14;\n                                     z2 = true;\n                                 } else {\n                                     zzdiVar5 = zzbu;\n                                     i3 = i9;\n                                     if (\"_r\".equals(zzdaVar5.zzc(i20).zzb())) {\n                                         zzde zzbu3 = zzdaVar5.zzc(i20).zzbu();\n                                         str8 = str14;\n                                         zzbu3.zzd(1L);\n                                         zzdaVar5.zzd(i20, zzbu3.zzaA());\n                                         z3 = true;\n                                     } else {\n                                         str8 = str14;\n                                     }\n                                 }\n                                 i20++;\n                                 str14 = str8;\n                                 zzbu = zzdiVar5;\n                                 str15 = str5;\n                                 i9 = i3;\n                             }\n                             zzdiVar4 = zzbu;\n                             i2 = i9;\n                             String str17 = str14;\n                             if (z2 || !zzj) {\n                                 str6 = str17;\n                             } else {\n                                 ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zzk().zzb(\"Marking event as conversion\", ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzm().zzc(zzdaVar5.zzk()));\n                                 zzde zzn2 = zzdf.zzn();\n                                 zzn2.zza(\"_c\");\n                                 str6 = str17;\n                                 zzn2.zzd(1L);\n                                 zzdaVar5.zzg(zzn2);\n                             }\n                             if (!z3) {\n                                 ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zzk().zzb(\"Marking event as real-time\", ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzm().zzc(zzdaVar5.zzk()));\n                                 zzde zzn3 = zzdf.zzn();\n                                 zzn3.zza(\"_r\");\n                                 zzn3.zzd(1L);\n                                 zzdaVar5.zzg(zzn3);\n                             }\n                             str7 = \"_e\";\n                             if (zzi().zzu(zzy(), zzkcVar3.zza.zzA(), false, false, false, false, true).zze > ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzc().zzk(zzkcVar3.zza.zzA(), zzdw.zzn)) {\n                                 zzkd.zzad(zzdaVar5, \"_r\");\n                             } else {\n                                 i13 = 1;\n                             }\n                             if (zzkk.zzh(zzdaVar5.zzk()) && zzj && zzi().zzu(zzy(), zzkcVar3.zza.zzA(), false, false, true, false, false).zzc > ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzc().zzk(zzkcVar3.zza.zzA(), zzdw.zzm)) {\n                                 ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zze().zzb(\"Too many conversions. Not logging as conversion. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                 zzde zzdeVar = null;\n                                 boolean z4 = false;\n                                 int i21 = -1;\n                                 for (int i22 = 0; i22 < zzdaVar5.zzb(); i22++) {\n                                     zzdf zzc = zzdaVar5.zzc(i22);\n                                     if (\"_c\".equals(zzc.zzb())) {\n                                         zzdeVar = zzc.zzbu();\n                                         i21 = i22;\n                                     } else if (\"_err\".equals(zzc.zzb())) {\n                                         z4 = true;\n                                     }\n                                 }\n                                 if (z4) {\n                                     if (zzdeVar != null) {\n                                         zzdaVar5.zzj(i21);\n                                     } else {\n                                         zzdeVar = null;\n                                     }\n                                 }\n                                 if (zzdeVar != null) {\n                                     zzde zzay4 = zzdeVar.zzay();\n                                     zzay4.zza(\"_err\");\n                                     zzay4.zzd(10L);\n                                     zzdaVar5.zzd(i21, zzay4.zzaA());\n                                 } else {\n                                     ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zzb().zzb(\"Did not find conversion parameter. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                 }\n                             }\n                             if (zzj) {\n                             }\n                             if (str7.equals(zzdaVar5.zzk())) {\n                             }\n                         }\n                         i10 = i7 + 1;\n                         zzbu = zzdiVar6;\n                         str11 = str10;\n                         str12 = str2;\n                         zzn = z;\n                         str13 = str3;\n                     }\n                     zzdi zzdiVar7 = zzbu;\n                     if (zzn) {\n                         int i23 = i12;\n                         j3 = j2;\n                         int i24 = 0;\n                         while (i24 < i23) {\n                             zzdb zzd4 = zzdiVar7.zzd(i24);\n                             if (\"_e\".equals(zzd4.zzd())) {\n                                 zzn();\n                                 if (zzkf.zzz(zzd4, \"_fr\") != null) {\n                                     zzdiVar7.zzi(i24);\n                                     i23--;\n                                     i24--;\n                                     i24++;\n                                 }\n                             }\n                             zzn();\n                             zzdf zzz4 = zzkf.zzz(zzd4, \"_et\");\n                             if (zzz4 != null) {\n                                 Long valueOf = zzz4.zze() ? Long.valueOf(zzz4.zzf()) : null;\n                                 if (valueOf != null && valueOf.longValue() > 0) {\n                                     j3 += valueOf.longValue();\n                                 }\n                             }\n                             i24++;\n                         }\n                     } else {\n                         j3 = j2;\n                     }\n                     clsGCNUGCP9VYAIUHS2.zzaf(zzdiVar7, j3, false);\n                     Iterator it = zzdiVar7.zzb().iterator();\n                     while (true) {\n                         if (it.hasNext()) {\n                             if (\"_s\".equals(((zzdb) it.next()).zzd())) {\n                                 zzi().zzi(zzdiVar7.zzG(), \"_se\");\n                                 break;\n                             }\n                         } else {\n                             break;\n                         }\n                     }\n                     if (zzkf.zzu(zzdiVar7, \"_sid\") >= 0) {\n                         clsGCNUGCP9VYAIUHS2.zzaf(zzdiVar7, j3, true);\n                     } else {\n                         int zzu = zzkf.zzu(zzdiVar7, \"_se\");\n                         if (zzu >= 0) {\n                             zzdiVar7.zzq(zzu);\n                             ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zzb().zzb(\"Session engagement user property is in the bundle without session ID. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                         }\n                     }\n                     zzkf zzn4 = zzn();\n                     ((zzge) zzn4).zzx.zzat().zzk().zza(\"Checking account type status for ad personalization signals\");\n                     if (((zzju) zzn4).zza.zzf().zzf(zzdiVar7.zzG()) && (zzs = ((zzju) zzn4).zza.zzi().zzs(zzdiVar7.zzG())) != null && zzs.zzaf() && ((zzge) zzn4).zzx.zzz().zzf()) {\n                         ((zzge) zzn4).zzx.zzat().zzj().zza(\"Turning off ad personalization due to account type\");\n                         zzdt zzj2 = zzdu.zzj();\n                         zzj2.zzb(str2);\n                         zzj2.zza(((zzge) zzn4).zzx.zzz().zzd());\n                         zzj2.zze(1L);\n                         zzdu zzaA2 = zzj2.zzaA();\n                         int i25 = 0;\n                         while (true) {\n                             if (i25 >= zzdiVar7.zzk()) {\n                                 zzdiVar7.zzn(zzaA2);\n                                 break;\n                             } else if (str2.equals(zzdiVar7.zzl(i25).zzc())) {\n                                 zzdiVar7.zzm(i25, zzaA2);\n                                 break;\n                             } else {\n                                 i25++;\n                             }\n                         }\n                     }\n                     zzdiVar7.zzt(Long.MAX_VALUE);\n                     zzdiVar7.zzv(Long.MIN_VALUE);\n                     for (int i26 = 0; i26 < zzdiVar7.zzc(); i26++) {\n                         zzdb zzd5 = zzdiVar7.zzd(i26);\n                         if (zzd5.zzf() < zzdiVar7.zzs()) {\n                             zzdiVar7.zzt(zzd5.zzf());\n                         }\n                         if (zzd5.zzf() > zzdiVar7.zzu()) {\n                             zzdiVar7.zzv(zzd5.zzf());\n                         }\n                     }\n                     zzdiVar7.zzac();\n                     zzdiVar7.zzZ();\n                     zzdiVar7.zzY(zzl().zzb(zzdiVar7.zzG(), zzdiVar7.zzb(), zzdiVar7.zzj(), Long.valueOf(zzdiVar7.zzs()), Long.valueOf(zzdiVar7.zzu())));\n                     if (((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzc().zzx(zzkcVar3.zza.zzA())) {\n                         try {\n                             Map hashMap = new HashMap();\n                             ArrayList arrayList2 = new ArrayList();\n                             SecureRandom zzf = ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzl().zzf();\n                             int i27 = 0;\n                             while (i27 < zzdiVar7.zzc()) {\n                                 zzda zzbu4 = zzdiVar7.zzd(i27).zzbu();\n                                 if (zzbu4.zzk().equals(\"_ep\")) {\n                                     zzn();\n                                     String str18 = (String) zzkf.zzA(zzbu4.zzaA(), \"_en\");\n                                     zzao zzaoVar = (zzao) hashMap.get(str18);\n                                     if (zzaoVar == null) {\n                                         zzaoVar = zzi().zzf(zzkcVar3.zza.zzA(), str18);\n                                         hashMap.put(str18, zzaoVar);\n                                     }\n                                     if (zzaoVar.zzi == null) {\n                                         if (zzaoVar.zzj.longValue() > 1) {\n                                             zzn();\n                                             zzkf.zzx(zzbu4, \"_sr\", zzaoVar.zzj);\n                                         }\n                                         Boolean bool = zzaoVar.zzk;\n                                         if (bool != null && bool.booleanValue()) {\n                                             zzn();\n                                             zzkf.zzx(zzbu4, \"_efs\", 1L);\n                                         }\n                                         arrayList2.add(zzbu4.zzaA());\n                                     }\n                                     zzdiVar7.zze(i27, zzbu4);\n                                     zzdiVar3 = zzdiVar7;\n                                     zzkcVar2 = zzkcVar3;\n                                     secureRandom = zzf;\n                                     map2 = hashMap;\n                                 } else {\n                                     zzfc zzf2 = zzf();\n                                     String zzA = zzkcVar3.zza.zzA();\n                                     String zza = zzf2.zza(zzA, \"measurement.account.time_zone_offset_minutes\");\n                                     if (!TextUtils.isEmpty(zza)) {\n                                         try {\n                                             parseLong = Long.parseLong(zza);\n                                         } catch (NumberFormatException e) {\n                                             ((zzge) zzf2).zzx.zzat().zze().zzc(\"Unable to parse timezone offset. appId\", zzei.zzl(zzA), e);\n                                         }\n                                         long zzab2 = ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzl().zzab(zzbu4.zzn(), parseLong);\n                                         zzdb zzaA3 = zzbu4.zzaA();\n                                         long j5 = parseLong;\n                                         Long l3 = 1L;\n                                         if (!TextUtils.isEmpty(\"_dbg\")) {\n                                             Iterator it2 = zzaA3.zza().iterator();\n                                             while (true) {\n                                                 if (!it2.hasNext()) {\n                                                     break;\n                                                 }\n                                                 zzdf zzdfVar = (zzdf) it2.next();\n                                                 Iterator it3 = it2;\n                                                 if (!\"_dbg\".equals(zzdfVar.zzb())) {\n                                                     it2 = it3;\n                                                 } else if (l3.equals(Long.valueOf(zzdfVar.zzf()))) {\n                                                     zzk = 1;\n                                                 }\n                                             }\n                                         }\n                                         zzk = zzf().zzk(zzkcVar3.zza.zzA(), zzbu4.zzk());\n                                         if (zzk > 0) {\n                                             ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zze().zzc(\"Sample rate must be positive. event, rate\", zzbu4.zzk(), Integer.valueOf(zzk));\n                                             arrayList2.add(zzbu4.zzaA());\n                                             zzdiVar7.zze(i27, zzbu4);\n                                         } else {\n                                             zzao zzaoVar2 = (zzao) hashMap.get(zzbu4.zzk());\n                                             if (zzaoVar2 == null && (zzaoVar2 = zzi().zzf(zzkcVar3.zza.zzA(), zzbu4.zzk())) == null) {\n                                                 ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzat().zze().zzc(\"Event being bundled has no eventAggregate. appId, eventName\", zzkcVar3.zza.zzA(), zzbu4.zzk());\n                                                 zzaoVar2 = new zzao(zzkcVar3.zza.zzA(), zzbu4.zzk(), 1L, 1L, 1L, zzbu4.zzn(), 0L, (Long) null, (Long) null, (Long) null, (Boolean) null);\n                                             }\n                                             zzn();\n                                             Long l4 = (Long) zzkf.zzA(zzbu4.zzaA(), \"_eid\");\n                                             Boolean valueOf2 = Boolean.valueOf(l4 != null);\n                                             if (zzk == 1) {\n                                                 arrayList2.add(zzbu4.zzaA());\n                                                 if (valueOf2.booleanValue() && (zzaoVar2.zzi != null || zzaoVar2.zzj != null || zzaoVar2.zzk != null)) {\n                                                     hashMap.put(zzbu4.zzk(), zzaoVar2.zzc((Long) null, (Long) null, (Boolean) null));\n                                                 }\n                                                 zzdiVar7.zze(i27, zzbu4);\n                                             } else {\n                                                 if (zzf.nextInt(zzk) == 0) {\n                                                     zzn();\n                                                     zzkcVar2 = zzkcVar3;\n                                                     secureRandom = zzf;\n                                                     Long valueOf3 = Long.valueOf(zzk);\n                                                     zzkf.zzx(zzbu4, \"_sr\", valueOf3);\n                                                     arrayList2.add(zzbu4.zzaA());\n                                                     if (valueOf2.booleanValue()) {\n                                                         zzaoVar2 = zzaoVar2.zzc((Long) null, valueOf3, (Boolean) null);\n                                                     }\n                                                     hashMap.put(zzbu4.zzk(), zzaoVar2.zzb(zzbu4.zzn(), zzab2));\n                                                     map2 = hashMap;\n                                                     zzdiVar3 = zzdiVar7;\n                                                 } else {\n                                                     zzkcVar2 = zzkcVar3;\n                                                     secureRandom = zzf;\n                                                     Long l5 = zzaoVar2.zzh;\n                                                     if (l5 != null) {\n                                                         zzab = l5.longValue();\n                                                         l = l4;\n                                                         map = hashMap;\n                                                         zzdiVar2 = zzdiVar7;\n                                                     } else {\n                                                         zzdiVar2 = zzdiVar7;\n                                                         l = l4;\n                                                         map = hashMap;\n                                                         zzab = ((zzkd) this).zzl.zzl().zzab(zzbu4.zzp(), j5);\n                                                     }\n                                                     if (zzab != zzab2) {\n                                                         zzn();\n                                                         zzkf.zzx(zzbu4, \"_efs\", 1L);\n                                                         zzn();\n                                                         Long valueOf4 = Long.valueOf(zzk);\n                                                         zzkf.zzx(zzbu4, \"_sr\", valueOf4);\n                                                         arrayList2.add(zzbu4.zzaA());\n                                                         if (valueOf2.booleanValue()) {\n                                                             zzaoVar2 = zzaoVar2.zzc((Long) null, valueOf4, true);\n                                                         }\n                                                         map2 = map;\n                                                         map2.put(zzbu4.zzk(), zzaoVar2.zzb(zzbu4.zzn(), zzab2));\n                                                     } else {\n                                                         map2 = map;\n                                                         if (valueOf2.booleanValue()) {\n                                                             map2.put(zzbu4.zzk(), zzaoVar2.zzc(l, (Long) null, (Boolean) null));\n                                                         }\n                                                     }\n                                                     zzdiVar3 = zzdiVar2;\n                                                 }\n                                                 zzdiVar3.zze(i27, zzbu4);\n                                             }\n                                         }\n                                         zzdiVar3 = zzdiVar7;\n                                         zzkcVar2 = zzkcVar3;\n                                         secureRandom = zzf;\n                                         map2 = hashMap;\n                                     }\n                                     parseLong = 0;\n                                     long zzab22 = ((zzkd) clsGCNUGCP9VYAIUHS2).zzl.zzl().zzab(zzbu4.zzn(), parseLong);\n                                     zzdb zzaA32 = zzbu4.zzaA();\n                                     long j52 = parseLong;\n                                     Long l32 = 1L;\n                                     if (!TextUtils.isEmpty(\"_dbg\")) {\n                                     }\n                                     zzk = zzf().zzk(zzkcVar3.zza.zzA(), zzbu4.zzk());\n                                     if (zzk > 0) {\n                                     }\n                                     zzdiVar3 = zzdiVar7;\n                                     zzkcVar2 = zzkcVar3;\n                                     secureRandom = zzf;\n                                     map2 = hashMap;\n                                 }\n                                 i27++;\n                                 zzdiVar7 = zzdiVar3;\n                                 hashMap = map2;\n                                 zzkcVar3 = zzkcVar2;\n                                 clsGCNUGCP9VYAIUHS2 = this;\n                                 zzf = secureRandom;\n                             }\n                             Map map3 = hashMap;\n                             zzdiVar = zzdiVar7;\n                             zzkc zzkcVar4 = zzkcVar3;\n                             if (arrayList2.size() < zzdiVar.zzc()) {\n                                 zzdiVar.zzh();\n                                 zzdiVar.zzg(arrayList2);\n                             }\n                             for (Map.Entry entry : map3.entrySet()) {\n                                 zzi().zzh((zzao) entry.getValue());\n                             }\n                             zzkcVar = zzkcVar4;\n                         } catch (Throwable th) {\n                             th = th;\n                             Throwable th2 = th;\n                             zzi().zzd();\n                             throw th2;\n                         }\n                     } else {\n                         zzdiVar = zzdiVar7;\n                         zzkcVar = zzkcVar3;\n                     }\n                     String zzA2 = zzkcVar.zza.zzA();\n                     zzg zzs2 = zzi().zzs(zzA2);\n                     if (zzs2 == null) {\n                         clsGCNUGCP9VYAIUHS = this;\n                         ((zzkd) clsGCNUGCP9VYAIUHS).zzl.zzat().zzb().zzb(\"Bundling raw events w/o app info. appId\", zzei.zzl(zzkcVar.zza.zzA()));\n                     } else {\n                         clsGCNUGCP9VYAIUHS = this;\n                         if (zzdiVar.zzc() > 0) {\n                             long zzr = zzs2.zzr();\n                             if (zzr != 0) {\n                                 zzdiVar.zzy(zzr);\n                             } else {\n                                 zzdiVar.zzz();\n                             }\n                             long zzp = zzs2.zzp();\n                             if (zzp != 0) {\n                                 zzr = zzp;\n                             }\n                             if (zzr != 0) {\n                                 zzdiVar.zzw(zzr);\n                             } else {\n                                 zzdiVar.zzx();\n                             }\n                             zzs2.zzN();\n                             zzdiVar.zzS((int) zzs2.zzI());\n                             zzs2.zzq(zzdiVar.zzs());\n                             zzs2.zzs(zzdiVar.zzu());\n                             String zzab3 = zzs2.zzab();\n                             if (zzab3 != null) {\n                                 zzdiVar.zzT(zzab3);\n                             } else {\n                                 zzdiVar.zzU();\n                             }\n                             zzi().zzt(zzs2);\n                         }\n                     }\n                     if (zzdiVar.zzc() > 0) {\n                         ((zzkd) clsGCNUGCP9VYAIUHS).zzl.zzas();\n                         zzcp zzb = zzf().zzb(zzkcVar.zza.zzA());\n                         try {\n                             try {\n                                 if (zzb != null && zzb.zza()) {\n                                     zzdiVar.zzad(zzb.zzb());\n                                     zzi = zzi();\n                                     zzaA = zzdiVar.zzaA();\n                                     zzi.zzg();\n                                     zzi.zzX();\n                                     Preconditions.checkNotNull(zzaA);\n                                     Preconditions.checkNotEmpty(zzaA.zzA());\n                                     Preconditions.checkState(zzaA.zzn());\n                                     zzi.zzy();\n                                     currentTimeMillis = ((zzge) zzi).zzx.zzax().currentTimeMillis();\n                                     zzo = zzaA.zzo();\n                                     ((zzge) zzi).zzx.zzc();\n                                     if (zzo >= currentTimeMillis - zzae.zzA()) {\n                                         long zzo2 = zzaA.zzo();\n                                         ((zzge) zzi).zzx.zzc();\n                                     }\n                                     ((zzge) zzi).zzx.zzat().zze().zzd(\"Storing bundle outside of the max uploading time span. appId, now, timestamp\", zzei.zzl(zzaA.zzA()), Long.valueOf(currentTimeMillis), Long.valueOf(zzaA.zzo()));\n                                     byte[] zzs3 = ((zzju) zzi).zza.zzn().zzs(zzaA.zzbp());\n                                     ((zzge) zzi).zzx.zzat().zzk().zzb(\"Saving bundle, size\", Integer.valueOf(zzs3.length));\n                                     contentValues = new ContentValues();\n                                     contentValues.put(\"app_id\", zzaA.zzA());\n                                     contentValues.put(\"bundle_end_timestamp\", Long.valueOf(zzaA.zzo()));\n                                     contentValues.put(\"data\", zzs3);\n                                     contentValues.put(\"has_realtime\", Integer.valueOf(i13));\n                                     if (zzaA.zzab()) {\n                                         contentValues.put(\"retry_count\", Integer.valueOf(zzaA.zzac()));\n                                     }\n                                     if (zzi.zze().insert(\"queue\", null, contentValues) == -1) {\n                                         ((zzge) zzi).zzx.zzat().zzb().zzb(\"Failed to insert bundle (got -1). appId\", zzei.zzl(zzaA.zzA()));\n                                     }\n                                 }\n                                 if (zzi.zze().insert(\"queue\", null, contentValues) == -1) {\n                                 }\n                             } catch (SQLiteException e2) {\n                                 ((zzge) zzi).zzx.zzat().zzb().zzc(\"Error storing bundle. appId\", zzei.zzl(zzaA.zzA()), e2);\n                             }\n                             byte[] zzs32 = ((zzju) zzi).zza.zzn().zzs(zzaA.zzbp());\n                             ((zzge) zzi).zzx.zzat().zzk().zzb(\"Saving bundle, size\", Integer.valueOf(zzs32.length));\n                             contentValues = new ContentValues();\n                             contentValues.put(\"app_id\", zzaA.zzA());\n                             contentValues.put(\"bundle_end_timestamp\", Long.valueOf(zzaA.zzo()));\n                             contentValues.put(\"data\", zzs32);\n                             contentValues.put(\"has_realtime\", Integer.valueOf(i13));\n                             if (zzaA.zzab()) {\n                             }\n                         } catch (IOException e3) {\n                             ((zzge) zzi).zzx.zzat().zzb().zzc(\"Data loss. Failed to serialize bundle. appId\", zzei.zzl(zzaA.zzA()), e3);\n                         }\n                         if (TextUtils.isEmpty(zzkcVar.zza.zzP())) {\n                             zzdiVar.zzad(-1L);\n                         } else {\n                             ((zzkd) clsGCNUGCP9VYAIUHS).zzl.zzat().zze().zzb(\"Did not find measurement config or missing version info. appId\", zzei.zzl(zzkcVar.zza.zzA()));\n                         }\n                         zzi = zzi();\n                         zzaA = zzdiVar.zzaA();\n                         zzi.zzg();\n                         zzi.zzX();\n                         Preconditions.checkNotNull(zzaA);\n                         Preconditions.checkNotEmpty(zzaA.zzA());\n                         Preconditions.checkState(zzaA.zzn());\n                         zzi.zzy();\n                         currentTimeMillis = ((zzge) zzi).zzx.zzax().currentTimeMillis();\n                         zzo = zzaA.zzo();\n                         ((zzge) zzi).zzx.zzc();\n                         if (zzo >= currentTimeMillis - zzae.zzA()) {\n                         }\n                         ((zzge) zzi).zzx.zzat().zze().zzd(\"Storing bundle outside of the max uploading time span. appId, now, timestamp\", zzei.zzl(zzaA.zzA()), Long.valueOf(currentTimeMillis), Long.valueOf(zzaA.zzo()));\n                     }\n                     zzai zzi2 = zzi();\n                     List list2 = zzkcVar.zzb;\n                     Preconditions.checkNotNull(list2);\n                     zzi2.zzg();\n                     zzi2.zzX();\n                     StringBuilder sb = new StringBuilder(\"rowid in (\");\n                     for (int i28 = 0; i28 < list2.size(); i28++) {\n                         if (i28 != 0) {\n                             sb.append(\",\");\n                         }\n                         sb.append(((Long) list2.get(i28)).longValue());\n                     }\n                     sb.append(\")\");\n                     int delete = zzi2.zze().delete(\"raw_events\", sb.toString(), null);\n                     if (delete != list2.size()) {\n                         ((zzge) zzi2).zzx.zzat().zzb().zzc(\"Deleted fewer rows from raw events table than expected\", Integer.valueOf(delete), Integer.valueOf(list2.size()));\n                     }\n                     zzai zzi3 = zzi();\n                     try {\n                         zzi3.zze().execSQL(\"delete from raw_events_metadata where app_id=? and metadata_fingerprint not in (select distinct metadata_fingerprint from raw_events where app_id=?)\", new String[]{zzA2, zzA2});\n                     } catch (SQLiteException e4) {\n                         ((zzge) zzi3).zzx.zzat().zzb().zzc(\"Failed to remove unused event metadata. appId\", zzei.zzl(zzA2), e4);\n                     }\n                     zzi().zzc();\n                     zzi().zzd();\n                     return true;\n                 }\n                 zzi().zzc();\n                 zzi().zzd();\n                 return false;\n             } catch (Throwable th3) {\n                 th = th3;\n                 Throwable th22 = th;\n                 zzi().zzd();\n                 throw th22;\n             }\n         } catch (Throwable th4) {\n             th = th4;\n             Throwable th222 = th;\n             zzi().zzd();\n             throw th222;\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                4766
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.255-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6f4eacfd-afeb-4dac-8315-02b405ac1eec",
              "value": "final void zzM(zzp zzpVar) {\n         if (((zzkd) this).zzw != null) {\n             ArrayList arrayList = new ArrayList();\n             ((zzkd) this).zzx = arrayList;\n             arrayList.addAll(((zzkd) this).zzw);\n         }\n         zzai zzi = zzi();\n         String str = zzpVar.zza;\n         Preconditions.checkNotEmpty(str);\n         zzi.zzg();\n         zzi.zzX();\n         try {\n             SQLiteDatabase zze = zzi.zze();\n             String[] strArr = {str};\n             int delete = zze.delete(\"apps\", \"app_id=?\", strArr) + zze.delete(\"events\", \"app_id=?\", strArr) + zze.delete(\"user_attributes\", \"app_id=?\", strArr) + zze.delete(\"conditional_properties\", \"app_id=?\", strArr) + zze.delete(\"raw_events\", \"app_id=?\", strArr) + zze.delete(\"raw_events_metadata\", \"app_id=?\", strArr) + zze.delete(\"queue\", \"app_id=?\", strArr) + zze.delete(\"audience_filter_values\", \"app_id=?\", strArr) + zze.delete(\"main_event_params\", \"app_id=?\", strArr) + zze.delete(\"default_event_params\", \"app_id=?\", strArr);\n             if (delete > 0) {\n                 ((zzge) zzi).zzx.zzat().zzk().zzc(\"Reset analytics data. app, records\", str, Integer.valueOf(delete));\n             }\n         } catch (SQLiteException e) {\n             ((zzge) zzi).zzx.zzat().zzb().zzc(\"Error resetting analytics data. appId, error\", zzei.zzl(str), e);\n         }\n         if (zzpVar.zzh) {\n             zzS(zzpVar);\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                15748
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.363-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ad4caa9b-8c6f-4110-9266-05ea24ea3a5d",
              "value": "final void zzS(zzp zzpVar) {\n         String str;\n         char c;\n         zzg zzs;\n         String str2;\n         zzao zzf;\n         boolean z;\n         String str3;\n         PackageInfo packageInfo;\n         String str4;\n         String str5;\n         ApplicationInfo applicationInfo;\n         ApplicationInfo applicationInfo2;\n         ApplicationInfo applicationInfo3;\n         boolean z2;\n         boolean z3;\n         zzai zzi;\n         String zzc;\n         int delete;\n         ((zzkd) this).zzl.zzau().zzg();\n         zzs();\n         Preconditions.checkNotNull(zzpVar);\n         Preconditions.checkNotEmpty(zzpVar.zza);\n         if (zzan(zzpVar)) {\n             zzg zzs2 = zzi().zzs(zzpVar.zza);\n             if (zzs2 != null && TextUtils.isEmpty(zzs2.zzf()) && !TextUtils.isEmpty(zzpVar.zzb)) {\n                 zzs2.zzK(0L);\n                 zzi().zzt(zzs2);\n                 zzf().zze(zzpVar.zza);\n             }\n             if (!zzpVar.zzh) {\n                 zzX(zzpVar);\n                 return;\n             }\n             long j = zzpVar.zzm;\n             if (j == 0) {\n                 j = ((zzkd) this).zzl.zzax().currentTimeMillis();\n             }\n             ((zzkd) this).zzl.zzz().zze();\n             int i = zzpVar.zzn;\n             if (i != 0) {\n                 if (i != 1) {\n                     ((zzkd) this).zzl.zzat().zze().zzc(\"Incorrect app type, assuming installed app. appId, appType\", zzei.zzl(zzpVar.zza), Integer.valueOf(i));\n                     i = 0;\n                 } else {\n                     i = 1;\n                 }\n             }\n             zzi().zzb();\n             try {\n                 zzki zzk = zzi().zzk(zzpVar.zza, \"_npa\");\n                 if (zzk != null && !\"auto\".equals(zzk.zzb)) {\n                     str = \"_sysu\";\n                     c = 0;\n                     zzs = zzi().zzs(zzpVar.zza);\n                     if (zzs != null && ((zzkd) this).zzl.zzl().zzB(zzpVar.zzb, zzs.zzf(), zzpVar.zzq, zzs.zzh())) {\n                         ((zzkd) this).zzl.zzat().zze().zzb(\"New GMP App Id passed in. Removing cached database data. appId\", zzei.zzl(zzs.zzc()));\n                         zzi = zzi();\n                         zzc = zzs.zzc();\n                         zzi.zzX();\n                         zzi.zzg();\n                         Preconditions.checkNotEmpty(zzc);\n                         try {\n                             SQLiteDatabase zze = zzi.zze();\n                             String[] strArr = new String[1];\n                             strArr[c] = zzc;\n                             delete = zze.delete(\"events\", \"app_id=?\", strArr) + zze.delete(\"user_attributes\", \"app_id=?\", strArr) + zze.delete(\"conditional_properties\", \"app_id=?\", strArr) + zze.delete(\"apps\", \"app_id=?\", strArr) + zze.delete(\"raw_events\", \"app_id=?\", strArr) + zze.delete(\"raw_events_metadata\", \"app_id=?\", strArr) + zze.delete(\"event_filters\", \"app_id=?\", strArr) + zze.delete(\"property_filters\", \"app_id=?\", strArr) + zze.delete(\"audience_filter_values\", \"app_id=?\", strArr) + zze.delete(\"consent_settings\", \"app_id=?\", strArr);\n                             if (delete > 0) {\n                                 ((zzge) zzi).zzx.zzat().zzk().zzc(\"Deleted application data. app, records\", zzc, Integer.valueOf(delete));\n                             }\n                         } catch (SQLiteException e) {\n                             ((zzge) zzi).zzx.zzat().zzb().zzc(\"Error deleting application data. appId, error\", zzei.zzl(zzc), e);\n                         }\n                         zzs = null;\n                     }\n                     if (zzs == null) {\n                         if (zzs.zzv() != -2147483648L) {\n                             str2 = \"_sys\";\n                             if (zzs.zzv() != zzpVar.zzj) {\n                                 z3 = true;\n                                 if (z3 | ((zzs.zzv() == -2147483648L || zzs.zzt() == null || zzs.zzt().equals(zzpVar.zzc)) ? false : true)) {\n                                     Bundle bundle = new Bundle();\n                                     bundle.putString(\"_pv\", zzs.zzt());\n                                     zzB(new zzas(\"_au\", new zzaq(bundle), \"auto\", j), zzpVar);\n                                 }\n                             }\n                         } else {\n                             str2 = \"_sys\";\n                         }\n                         z3 = false;\n                         if (z3 | ((zzs.zzv() == -2147483648L || zzs.zzt() == null || zzs.zzt().equals(zzpVar.zzc)) ? false : true)) {\n                         }\n                     } else {\n                         str2 = \"_sys\";\n                     }\n                     zzX(zzpVar);\n                     if (i == 0) {\n                         zzf = zzi().zzf(zzpVar.zza, \"_v\");\n                         z = true;\n                     } else {\n                         zzf = zzi().zzf(zzpVar.zza, \"_f\");\n                         z = false;\n                     }\n                     if (zzf != null) {\n                         long j2 = ((j / 3600000) + 1) * 3600000;\n                         if (!z) {\n                             zzN(new zzkg(\"_fot\", j, Long.valueOf(j2), \"auto\"), zzpVar);\n                             ((zzkd) this).zzl.zzau().zzg();\n                             ((zzkd) this).zzl.zzi().zza(zzpVar.zza);\n                             ((zzkd) this).zzl.zzau().zzg();\n                             zzs();\n                             Bundle bundle2 = new Bundle();\n                             bundle2.putLong(\"_c\", 1L);\n                             bundle2.putLong(\"_r\", 1L);\n                             bundle2.putLong(\"_uwa\", 0L);\n                             bundle2.putLong(\"_pfo\", 0L);\n                             bundle2.putLong(str2, 0L);\n                             String str6 = str;\n                             bundle2.putLong(str6, 0L);\n                             bundle2.putLong(\"_et\", 1L);\n                             if (zzpVar.zzp) {\n                                 bundle2.putLong(\"_dac\", 1L);\n                             }\n                             zzai zzi2 = zzi();\n                             String str7 = zzpVar.zza;\n                             Preconditions.checkNotEmpty(str7);\n                             zzi2.zzg();\n                             zzi2.zzX();\n                             long zzC = zzi2.zzC(str7, \"first_open_count\");\n                             if (((zzkd) this).zzl.zzaw().getPackageManager() == null) {\n                                 ((zzkd) this).zzl.zzat().zzb().zzb(\"PackageManager is null, first open report might be inaccurate. appId\", zzei.zzl(zzpVar.zza));\n                                 str4 = \"_et\";\n                             } else {\n                                 try {\n                                     packageInfo = Wrappers.packageManager(((zzkd) this).zzl.zzaw()).getPackageInfo(zzpVar.zza, 0);\n                                 } catch (PackageManager.NameNotFoundException e2) {\n                                     ((zzkd) this).zzl.zzat().zzb().zzc(\"Package info is null, first open report might be inaccurate. appId\", zzei.zzl(zzpVar.zza), e2);\n                                     packageInfo = null;\n                                 }\n                                 if (packageInfo == null || packageInfo.firstInstallTime == 0) {\n                                     str4 = \"_et\";\n                                     str5 = str6;\n                                     applicationInfo = null;\n                                 } else {\n                                     if (packageInfo.firstInstallTime != packageInfo.lastUpdateTime) {\n                                         applicationInfo3 = null;\n                                         if (!((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzal)) {\n                                             bundle2.putLong(\"_uwa\", 1L);\n                                         } else if (zzC == 0) {\n                                             bundle2.putLong(\"_uwa\", 1L);\n                                         }\n                                         z2 = false;\n                                     } else {\n                                         applicationInfo3 = null;\n                                         z2 = true;\n                                     }\n                                     str4 = \"_et\";\n                                     str5 = str6;\n                                     applicationInfo = applicationInfo3;\n                                     zzN(new zzkg(\"_fi\", j, Long.valueOf(true != z2 ? 0L : 1L), \"auto\"), zzpVar);\n                                 }\n                                 try {\n                                     applicationInfo2 = Wrappers.packageManager(((zzkd) this).zzl.zzaw()).getApplicationInfo(zzpVar.zza, 0);\n                                 } catch (PackageManager.NameNotFoundException e3) {\n                                     ((zzkd) this).zzl.zzat().zzb().zzc(\"Application info is null, first open report might be inaccurate. appId\", zzei.zzl(zzpVar.zza), e3);\n                                     applicationInfo2 = applicationInfo;\n                                 }\n                                 if (applicationInfo2 != null) {\n                                     if ((applicationInfo2.flags & 1) != 0) {\n                                         bundle2.putLong(str2, 1L);\n                                     }\n                                     if ((applicationInfo2.flags & 128) != 0) {\n                                         bundle2.putLong(str5, 1L);\n                                     }\n                                 }\n                             }\n                             if (zzC >= 0) {\n                                 bundle2.putLong(\"_pfo\", zzC);\n                             }\n                             zzA(new zzas(\"_f\", new zzaq(bundle2), \"auto\", j), zzpVar);\n                             str3 = str4;\n                         } else {\n                             str3 = \"_et\";\n                             zzN(new zzkg(\"_fvt\", j, Long.valueOf(j2), \"auto\"), zzpVar);\n                             ((zzkd) this).zzl.zzau().zzg();\n                             zzs();\n                             Bundle bundle3 = new Bundle();\n                             bundle3.putLong(\"_c\", 1L);\n                             bundle3.putLong(\"_r\", 1L);\n                             bundle3.putLong(str3, 1L);\n                             if (zzpVar.zzp) {\n                                 bundle3.putLong(\"_dac\", 1L);\n                             }\n                             zzA(new zzas(\"_v\", new zzaq(bundle3), \"auto\", j), zzpVar);\n                         }\n                         if (!((zzkd) this).zzl.zzc().zzn(zzpVar.zza, zzdw.zzT)) {\n                             Bundle bundle4 = new Bundle();\n                             bundle4.putLong(str3, 1L);\n                             bundle4.putLong(\"_fr\", 1L);\n                             zzA(new zzas(\"_e\", new zzaq(bundle4), \"auto\", j), zzpVar);\n                         }\n                     } else if (zzpVar.zzi) {\n                         zzA(new zzas(\"_cd\", new zzaq(new Bundle()), \"auto\", j), zzpVar);\n                     }\n                     zzi().zzc();\n                 }\n                 Boolean bool = zzpVar.zzr;\n                 if (bool != null) {\n                     str = \"_sysu\";\n                     c = 0;\n                     zzkg zzkgVar = new zzkg(\"_npa\", j, Long.valueOf(true != bool.booleanValue() ? 0L : 1L), \"auto\");\n                     if (zzk == null || !zzk.zze.equals(zzkgVar.zzd)) {\n                         zzN(zzkgVar, zzpVar);\n                     }\n                 } else {\n                     str = \"_sysu\";\n                     c = 0;\n                     if (zzk != null) {\n                         zzO(new zzkg(\"_npa\", j, (Object) null, \"auto\"), zzpVar);\n                     }\n                 }\n                 zzs = zzi().zzs(zzpVar.zza);\n                 if (zzs != null) {\n                     ((zzkd) this).zzl.zzat().zze().zzb(\"New GMP App Id passed in. Removing cached database data. appId\", zzei.zzl(zzs.zzc()));\n                     zzi = zzi();\n                     zzc = zzs.zzc();\n                     zzi.zzX();\n                     zzi.zzg();\n                     Preconditions.checkNotEmpty(zzc);\n                     SQLiteDatabase zze2 = zzi.zze();\n                     String[] strArr2 = new String[1];\n                     strArr2[c] = zzc;\n                     delete = zze2.delete(\"events\", \"app_id=?\", strArr2) + zze2.delete(\"user_attributes\", \"app_id=?\", strArr2) + zze2.delete(\"conditional_properties\", \"app_id=?\", strArr2) + zze2.delete(\"apps\", \"app_id=?\", strArr2) + zze2.delete(\"raw_events\", \"app_id=?\", strArr2) + zze2.delete(\"raw_events_metadata\", \"app_id=?\", strArr2) + zze2.delete(\"event_filters\", \"app_id=?\", strArr2) + zze2.delete(\"property_filters\", \"app_id=?\", strArr2) + zze2.delete(\"audience_filter_values\", \"app_id=?\", strArr2) + zze2.delete(\"consent_settings\", \"app_id=?\", strArr2);\n                     if (delete > 0) {\n                     }\n                     zzs = null;\n                 }\n                 if (zzs == null) {\n                 }\n                 zzX(zzpVar);\n                 if (i == 0) {\n                 }\n                 if (zzf != null) {\n                 }\n                 zzi().zzc();\n             } finally {\n                 zzi().zzd();\n             }\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                17129
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.385-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "731ccb57-61f6-4377-9834-f697281cb474",
              "value": "public final Bundle zzI(String str) {\n         Cursor cursor;\n         Cursor cursor2;\n         zzg();\n         zzX();\n         Cursor cursor3 = null;\n         try {\n             try {\n                 cursor = zze().rawQuery(\"select parameters from default_event_params where app_id=?\", new String[]{str});\n                 try {\n                     if (!cursor.moveToFirst()) {\n                         ((zzge) this).zzx.zzat().zzk().zza(\"Default event parameters not found\");\n                         if (cursor != null) {\n                             cursor.close();\n                         }\n                         return null;\n                     }\n                     try {\n                         zzdb zzaA = zzkf.zzt(zzdb.zzk(), cursor.getBlob(0)).zzaA();\n                         ((zzju) this).zza.zzn();\n                         List<zzdf> zza = zzaA.zza();\n                         Bundle bundle = new Bundle();\n                         for (zzdf zzdfVar : zza) {\n                             String zzb = zzdfVar.zzb();\n                             if (zzdfVar.zzi()) {\n                                 bundle.putDouble(zzb, zzdfVar.zzj());\n                             } else if (zzdfVar.zzg()) {\n                                 bundle.putFloat(zzb, zzdfVar.zzh());\n                             } else if (zzdfVar.zzc()) {\n                                 bundle.putString(zzb, zzdfVar.zzd());\n                             } else if (zzdfVar.zze()) {\n                                 bundle.putLong(zzb, zzdfVar.zzf());\n                             }\n                         }\n                         if (cursor != null) {\n                             cursor.close();\n                         }\n                         return bundle;\n                     } catch (IOException e) {\n                         ((zzge) this).zzx.zzat().zzb().zzc(\"Failed to retrieve default event parameters. appId\", zzei.zzl(str), e);\n                         if (cursor != null) {\n                             cursor.close();\n                         }\n                         return null;\n                     }\n                 } catch (SQLiteException e2) {\n                     e = e2;\n                     ((zzge) this).zzx.zzat().zzb().zzb(\"Error selecting default event parameters\", e);\n                     if (cursor != null) {\n                         cursor.close();\n                     }\n                     return null;\n                 }\n             } catch (Throwable th) {\n                 th = th;\n                 cursor3 = cursor2;\n                 if (cursor3 != null) {\n                     cursor3.close();\n                 }\n                 throw th;\n             }\n         } catch (SQLiteException e3) {\n             e = e3;\n             cursor = null;\n         } catch (Throwable th2) {\n             th = th2;\n             if (cursor3 != null) {\n             }\n             throw th;\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzai.java",
              "file_line": [
                1316
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.703-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "db1a445a-c796-451a-b3ce-eb3227155e26",
              "value": "r0 = r0.subList(0, r3);\n      */\n         r0 = th;\n      */\n         r2 = false;\n      */\n         if (r4 != null) goto L267;\n      */\n         r4.close();\n      */\n         if (r4 != null) goto L267;\n      */\n         if (r4 == null) goto L268;\n      */\n         if (android.text.TextUtils.isEmpty(r9) != false) goto L158;\n      */\n         r0 = zzi().zzs(r9);\n      */\n         if (r0 == null) goto L158;\n      */\n         zzH(r0);\n      */\n         if (r11 != null) goto L239;\n      */\n         r11.close();\n      */\n         if (r11 != null) goto L239;\n      */\n         if (r11 == null) goto L240;\n      */\n         ((com.google.android.gms.measurement.internal.zzkd) r22).zzy = r7;\n      */\n     \n     final void zzF() {\n         boolean z;\n         Boolean zzC;\n         zzai zzi;\n         long zzz;\n         Cursor cursor;\n         zzai zzi2;\n         Cursor cursor2;\n         Cursor cursor3;\n         long j;\n         Cursor cursor4;\n         List emptyList;\n         String str;\n         boolean z2;\n         boolean z3;\n         boolean z4;\n         int i;\n         String str2;\n         byte[] byteArray;\n         ((zzkd) this).zzl.zzau().zzg();\n         zzs();\n         int i2 = 1;\n         ((zzkd) this).zzt = true;\n         int i3 = 0;\n         try {\n             ((zzkd) this).zzl.zzas();\n             zzC = ((zzkd) this).zzl.zzy().zzC();\n         } catch (Throwable th) {\n             th = th;\n             z = false;\n         }\n         if (zzC == null) {\n             ((zzkd) this).zzl.zzat().zze().zza(\"Upload data called on the client side before use of service was decided\");\n             ((zzkd) this).zzt = false;\n         } else if (zzC.booleanValue()) {\n             ((zzkd) this).zzl.zzat().zzb().zza(\"Upload called in the client side when service should be used\");\n             ((zzkd) this).zzt = false;\n         } else if (((zzkd) this).zza > 0) {\n             zzaj();\n             ((zzkd) this).zzt = false;\n         } else {\n             ((zzkd) this).zzl.zzau().zzg();\n             if (((zzkd) this).zzw != null) {\n                 ((zzkd) this).zzl.zzat().zzk().zza(\"Uploading requested multiple times\");\n                 ((zzkd) this).zzt = false;\n             } else if (zzh().zzb()) {\n                 ?? currentTimeMillis = ((zzkd) this).zzl.zzax().currentTimeMillis();\n                 Cursor cursor5 = null;\n                 Cursor cursor6 = null;\n                 r9 = null;\n                 r9 = null;\n                 r9 = null;\n                 String str3 = null;\n                 int zzk = ((zzkd) this).zzl.zzc().zzk((String) null, zzdw.zzP);\n                 ((zzkd) this).zzl.zzc();\n                 long zzz2 = currentTimeMillis - zzae.zzz();\n                 for (int i4 = 0; i4 < zzk && zzae((String) null, zzz2); i4++) {\n                 }\n                 long zza = ((zzkd) this).zzl.zzd().zzc.zza();\n                 if (zza != 0) {\n                     ((zzkd) this).zzl.zzat().zzj().zzb(\"Uploading events. Elapsed time since last upload attempt (ms)\", Long.valueOf(Math.abs(currentTimeMillis - zza)));\n                 }\n                 String zzw = zzi().zzw();\n                 long j2 = -1;\n                 try {\n                 } catch (Throwable th2) {\n                     th = th2;\n                     z = false;\n                 }\n                 if (TextUtils.isEmpty(zzw)) {\n                     try {\n                         ((zzkd) this).zzy = -1L;\n                         zzi = zzi();\n                         ((zzkd) this).zzl.zzc();\n                         zzz = currentTimeMillis - zzae.zzz();\n                         zzi.zzg();\n                         zzi.zzX();\n                     } catch (Throwable th3) {\n                         th = th3;\n                         cursor5 = currentTimeMillis;\n                     }\n                     try {\n                         cursor = zzi.zze().rawQuery(\"select app_id from apps where app_id in (select distinct app_id from raw_events) and config_fetched_time < ? order by failed_config_fetch_time limit 1;\", new String[]{String.valueOf(zzz)});\n                         try {\n                             if (cursor.moveToFirst()) {\n                                 str3 = cursor.getString(0);\n                             } else {\n                                 ((zzge) zzi).zzx.zzat().zzk().zza(\"No expired configs for apps with pending events\");\n                             }\n                         } catch (SQLiteException e) {\n                             e = e;\n                             ((zzge) zzi).zzx.zzat().zzb().zzb(\"Error selecting expired configs\", e);\n                         }\n                     } catch (SQLiteException e2) {\n                         e = e2;\n                         cursor = null;\n                     } catch (Throwable th4) {\n                         th = th4;\n                         if (cursor5 != null) {\n                             cursor5.close();\n                         }\n                         throw th;\n                     }\n                 } else {\n                     if (((zzkd) this).zzy == -1) {\n                         try {\n                             zzi2 = zzi();\n                         } catch (Throwable th5) {\n                             th = th5;\n                             cursor6 = cursor2;\n                         }\n                         try {\n                             cursor2 = zzi2.zze().rawQuery(\"select rowid from raw_events order by rowid desc limit 1;\", null);\n                             try {\n                                 if (cursor2.moveToFirst()) {\n                                     j2 = cursor2.getLong(0);\n                                 }\n                             } catch (SQLiteException e3) {\n                                 e = e3;\n                                 ((zzge) zzi2).zzx.zzat().zzb().zzb(\"Error querying raw events\", e);\n                             }\n                         } catch (SQLiteException e4) {\n                             e = e4;\n                             cursor2 = null;\n                         } catch (Throwable th6) {\n                             th = th6;\n                             if (cursor6 != null) {\n                                 cursor6.close();\n                             }\n                             throw th;\n                         }\n                         th = th2;\n                         z = false;\n                         ((zzkd) this).zzt = z;\n                         zzak();\n                         throw th;\n                     }\n                     int zzk2 = ((zzkd) this).zzl.zzc().zzk(zzw, zzdw.zzf);\n                     int max = Math.max(0, ((zzkd) this).zzl.zzc().zzk(zzw, zzdw.zzg));\n                     zzai zzi3 = zzi();\n                     zzi3.zzg();\n                     zzi3.zzX();\n                     Preconditions.checkArgument(zzk2 > 0);\n                     try {\n                         Preconditions.checkArgument(max > 0);\n                         Preconditions.checkNotEmpty(zzw);\n                     } catch (Throwable th7) {\n                         th = th7;\n                         cursor3 = cursor2;\n                     }\n                     try {\n                         cursor4 = zzi3.zze().query(\"queue\", new String[]{\"rowid\", \"data\", \"retry_count\"}, \"app_id=?\", new String[]{zzw}, null, null, \"rowid\", String.valueOf(zzk2));\n                         try {\n                             if (cursor4.moveToFirst()) {\n                                 ArrayList arrayList = new ArrayList();\n                                 int i5 = 0;\n                                 long j3 = currentTimeMillis;\n                                 while (true) {\n                                     long j4 = cursor4.getLong(i3);\n                                     try {\n                                         byte[] blob = cursor4.getBlob(i2);\n                                         zzkf zzn = ((zzju) zzi3).zza.zzn();\n                                         try {\n                                             ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(blob);\n                                             GZIPInputStream gZIPInputStream = new GZIPInputStream(byteArrayInputStream);\n                                             ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n                                             byte[] bArr = new byte[1024];\n                                             j = j3;\n                                             while (true) {\n                                                 try {\n                                                     try {\n                                                         int read = gZIPInputStream.read(bArr);\n                                                         if (read <= 0) {\n                                                             break;\n                                                         }\n                                                         byteArrayOutputStream.write(bArr, 0, read);\n                                                     } catch (IOException e5) {\n                                                         e = e5;\n                                                         try {\n                                                             ((zzge) zzn).zzx.zzat().zzb().zzb(\"Failed to ungzip content\", e);\n                                                             throw e;\n                                                             break;\n                                                         } catch (IOException e6) {\n                                                             e = e6;\n                                                             ((zzge) zzi3).zzx.zzat().zzb().zzc(\"Failed to unzip queued bundle. appId\", zzei.zzl(zzw), e);\n                                                             if (cursor4.moveToNext()) {\n                                                                 break;\n                                                             }\n                                                             j3 = j;\n                                                             i2 = 1;\n                                                             i3 = 0;\n                                                             if (cursor4 != null) {\n                                                             }\n                                                             emptyList = arrayList;\n                                                             if (!emptyList.isEmpty()) {\n                                                             }\n                                                             ((zzkd) this).zzt = false;\n                                                             zzak();\n                                                         }\n                                                     }\n                                                 } catch (SQLiteException e7) {\n                                                     e = e7;\n                                                     ((zzge) zzi3).zzx.zzat().zzb().zzc(\"Error querying bundles. appId\", zzei.zzl(zzw), e);\n                                                     emptyList = Collections.emptyList();\n                                                     if (cursor4 != null) {\n                                                         cursor4.close();\n                                                     }\n                                                     if (!emptyList.isEmpty()) {\n                                                     }\n                                                     ((zzkd) this).zzt = false;\n                                                     zzak();\n                                                 }\n                                             }\n                                             gZIPInputStream.close();\n                                             byteArrayInputStream.close();\n                                             byteArray = byteArrayOutputStream.toByteArray();\n                                         } catch (IOException e8) {\n                                             e = e8;\n                                             j = j3;\n                                         }\n                                     } catch (IOException e9) {\n                                         e = e9;\n                                         j = j3;\n                                     }\n                                     if (!arrayList.isEmpty() && byteArray.length + i5 > max) {\n                                         break;\n                                     }\n                                     try {\n                                         zzdi zzt = zzkf.zzt(zzdj.zzaj(), byteArray);\n                                         if (!cursor4.isNull(2)) {\n                                             zzt.zzah(cursor4.getInt(2));\n                                         }\n                                         i5 += byteArray.length;\n                                         arrayList.add(Pair.create(zzt.zzaA(), Long.valueOf(j4)));\n                                     } catch (IOException e10) {\n                                         ((zzge) zzi3).zzx.zzat().zzb().zzc(\"Failed to merge queued bundle. appId\", zzei.zzl(zzw), e10);\n                                     }\n                                     if (cursor4.moveToNext() || i5 > max) {\n                                         break;\n                                         break;\n                                     }\n                                     j3 = j;\n                                     i2 = 1;\n                                     i3 = 0;\n                                 }\n                                 if (cursor4 != null) {\n                                     cursor4.close();\n                                 }\n                                 emptyList = arrayList;\n                             } else {\n                                 emptyList = Collections.emptyList();\n                                 if (cursor4 != null) {\n                                     cursor4.close();\n                                 }\n                                 j = currentTimeMillis;\n                             }\n                         } catch (SQLiteException e11) {\n                             e = e11;\n                             j = currentTimeMillis;\n                         }\n                     } catch (SQLiteException e12) {\n                         e = e12;\n                         j = currentTimeMillis;\n                         cursor4 = null;\n                     } catch (Throwable th8) {\n                         th = th8;\n                         cursor3 = null;\n                         if (cursor3 != null) {\n                             cursor3.close();\n                         }\n                         throw th;\n                     }\n                     if (!emptyList.isEmpty()) {\n                         zzlc.zzb();\n                         if (!((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzay) || zzx(zzw).zzf()) {\n                             Iterator it = emptyList.iterator();\n                             while (true) {\n                                 if (!it.hasNext()) {\n                                     str = null;\n                                     break;\n                                 }\n                                 zzdj zzdjVar = (zzdj) ((Pair) it.next()).first;\n                                 if (!TextUtils.isEmpty(zzdjVar.zzG())) {\n                                     str = zzdjVar.zzG();\n                                     break;\n                                 }\n                             }\n                             if (str != null) {\n                                 int i6 = 0;\n                                 while (true) {\n                                     if (i6 >= emptyList.size()) {\n                                         break;\n                                     }\n                                     zzdj zzdjVar2 = (zzdj) ((Pair) emptyList.get(i6)).first;\n                                     if (!TextUtils.isEmpty(zzdjVar2.zzG()) && !zzdjVar2.zzG().equals(str)) {\n                                         break;\n                                     }\n                                     i6++;\n                                 }\n                             }\n                         }\n                         zzdg zzc = zzdh.zzc();\n                         int size = emptyList.size();\n                         ArrayList arrayList2 = new ArrayList(emptyList.size());\n                         try {\n                             if (((zzkd) this).zzl.zzc().zzw(zzw)) {\n                                 zzlc.zzb();\n                                 if (!((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzay) || zzx(zzw).zzf()) {\n                                     z2 = true;\n                                     zzlc.zzb();\n                                     if (((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzay) && !zzx(zzw).zzf()) {\n                                         z3 = false;\n                                         zzlc.zzb();\n                                         if (((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzay) && !zzx(zzw).zzh()) {\n                                             z4 = false;\n                                             i = 0;\n                                             while (i < size) {\n                                                 zzdi zzbu = ((zzdj) ((Pair) emptyList.get(i)).first).zzbu();\n                                                 arrayList2.add((Long) ((Pair) emptyList.get(i)).second);\n                                                 ((zzkd) this).zzl.zzc().zzf();\n                                                 zzbu.zzK(39000L);\n                                                 long j5 = j;\n                                                 zzbu.zzr(j5);\n                                                 ((zzkd) this).zzl.zzas();\n                                                 try {\n                                                     zzbu.zzX(false);\n                                                     if (!z2) {\n                                                         zzbu.zzag();\n                                                     }\n                                                     zzlc.zzb();\n                                                     if (((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzay)) {\n                                                         if (!z3) {\n                                                             zzbu.zzM();\n                                                             zzbu.zzO();\n                                                         }\n                                                         if (!z4) {\n                                                             zzbu.zzQ();\n                                                         }\n                                                     }\n                                                     if (((zzkd) this).zzl.zzc().zzn(zzw, zzdw.zzV)) {\n                                                         zzbu.zzam(zzn().zzr(zzbu.zzaA().zzbp()));\n                                                     }\n                                                     zzc.zzb(zzbu);\n                                                     i++;\n                                                     j = j5;\n                                                 } catch (Throwable th9) {\n                                                     th = th9;\n                                                     z = false;\n                                                 }\n                                             }\n                                             long j6 = j;\n                                             String zzh = !Log.isLoggable(((zzkd) this).zzl.zzat().zzn(), 2) ? zzn().zzh(zzc.zzaA()) : null;\n                                             zzn();\n                                             byte[] zzbp = zzc.zzaA().zzbp();\n                                             ((zzkd) this).zzl.zzc();\n                                             str2 = (String) zzdw.zzp.zzb((Object) null);\n                                             URL url = new URL(str2);\n                                             Preconditions.checkArgument(!arrayList2.isEmpty());\n                                             if (((zzkd) this).zzw == null) {\n                                                 ((zzkd) this).zzl.zzat().zzb().zza(\"Set uploading progress before finishing the previous upload\");\n                                             } else {\n                                                 ((zzkd) this).zzw = new ArrayList(arrayList2);\n                                             }\n                                             ((zzkd) this).zzl.zzd().zzd.zzb(j6);\n                                             ((zzkd) this).zzl.zzat().zzk().zzd(\"Uploading data. app, uncompressed size, data\", size > 0 ? zzc.zza(0).zzA() : \"?\", Integer.valueOf(zzbp.length), zzh);\n                                             ((zzkd) this).zzs = true;\n                                             zzeo zzh2 = zzh();\n                                             zzjx zzjxVar = new zzjx(this, zzw);\n                                             zzh2.zzg();\n                                             zzh2.zzX();\n                                             Preconditions.checkNotNull(url);\n                                             Preconditions.checkNotNull(zzbp);\n                                             Preconditions.checkNotNull(zzjxVar);\n                                             ((zzge) zzh2).zzx.zzau().zzk(new zzen(zzh2, zzw, url, zzbp, (Map) null, zzjxVar));\n                                         }\n                                         z4 = true;\n                                         i = 0;\n                                         while (i < size) {\n                                         }\n                                         long j62 = j;\n                                         if (!Log.isLoggable(((zzkd) this).zzl.zzat().zzn(), 2)) {\n                                         }\n                                         zzn();\n                                         byte[] zzbp2 = zzc.zzaA().zzbp();\n                                         ((zzkd) this).zzl.zzc();\n                                         str2 = (String) zzdw.zzp.zzb((Object) null);\n                                         URL url2 = new URL(str2);\n                                         Preconditions.checkArgument(!arrayList2.isEmpty());\n                                         if (((zzkd) this).zzw == null) {\n                                         }\n                                         ((zzkd) this).zzl.zzd().zzd.zzb(j62);\n                                         ((zzkd) this).zzl.zzat().zzk().zzd(\"Uploading data. app, uncompressed size, data\", size > 0 ? zzc.zza(0).zzA() : \"?\", Integer.valueOf(zzbp2.length), zzh);\n                                         ((zzkd) this).zzs = true;\n                                         zzeo zzh22 = zzh();\n                                         zzjx zzjxVar2 = new zzjx(this, zzw);\n                                         zzh22.zzg();\n                                         zzh22.zzX();\n                                         Preconditions.checkNotNull(url2);\n                                         Preconditions.checkNotNull(zzbp2);\n                                         Preconditions.checkNotNull(zzjxVar2);\n                                         ((zzge) zzh22).zzx.zzau().zzk(new zzen(zzh22, zzw, url2, zzbp2, (Map) null, zzjxVar2));\n                                     }\n                                     z3 = true;\n                                     zzlc.zzb();\n                                     if (((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzay)) {\n                                         z4 = false;\n                                         i = 0;\n                                         while (i < size) {\n                                         }\n                                         long j622 = j;\n                                         if (!Log.isLoggable(((zzkd) this).zzl.zzat().zzn(), 2)) {\n                                         }\n                                         zzn();\n                                         byte[] zzbp22 = zzc.zzaA().zzbp();\n                                         ((zzkd) this).zzl.zzc();\n                                         str2 = (String) zzdw.zzp.zzb((Object) null);\n                                         URL url22 = new URL(str2);\n                                         Preconditions.checkArgument(!arrayList2.isEmpty());\n                                         if (((zzkd) this).zzw == null) {\n                                         }\n                                         ((zzkd) this).zzl.zzd().zzd.zzb(j622);\n                                         ((zzkd) this).zzl.zzat().zzk().zzd(\"Uploading data. app, uncompressed size, data\", size > 0 ? zzc.zza(0).zzA() : \"?\", Integer.valueOf(zzbp22.length), zzh);\n                                         ((zzkd) this).zzs = true;\n                                         zzeo zzh222 = zzh();\n                                         zzjx zzjxVar22 = new zzjx(this, zzw);\n                                         zzh222.zzg();\n                                         zzh222.zzX();\n                                         Preconditions.checkNotNull(url22);\n                                         Preconditions.checkNotNull(zzbp22);\n                                         Preconditions.checkNotNull(zzjxVar22);\n                                         ((zzge) zzh222).zzx.zzau().zzk(new zzen(zzh222, zzw, url22, zzbp22, (Map) null, zzjxVar22));\n                                     }\n                                     z4 = true;\n                                     i = 0;\n                                     while (i < size) {\n                                     }\n                                     long j6222 = j;\n                                     if (!Log.isLoggable(((zzkd) this).zzl.zzat().zzn(), 2)) {\n                                     }\n                                     zzn();\n                                     byte[] zzbp222 = zzc.zzaA().zzbp();\n                                     ((zzkd) this).zzl.zzc();\n                                     str2 = (String) zzdw.zzp.zzb((Object) null);\n                                     URL url222 = new URL(str2);\n                                     Preconditions.checkArgument(!arrayList2.isEmpty());\n                                     if (((zzkd) this).zzw == null) {\n                                     }\n                                     ((zzkd) this).zzl.zzd().zzd.zzb(j6222);\n                                     ((zzkd) this).zzl.zzat().zzk().zzd(\"Uploading data. app, uncompressed size, data\", size > 0 ? zzc.zza(0).zzA() : \"?\", Integer.valueOf(zzbp222.length), zzh);\n                                     ((zzkd) this).zzs = true;\n                                     zzeo zzh2222 = zzh();\n                                     zzjx zzjxVar222 = new zzjx(this, zzw);\n                                     zzh2222.zzg();\n                                     zzh2222.zzX();\n                                     Preconditions.checkNotNull(url222);\n                                     Preconditions.checkNotNull(zzbp222);\n                                     Preconditions.checkNotNull(zzjxVar222);\n                                     ((zzge) zzh2222).zzx.zzau().zzk(new zzen(zzh2222, zzw, url222, zzbp222, (Map) null, zzjxVar222));\n                                 }\n                             }\n                             if (((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzay)) {\n                                 z3 = false;\n                                 zzlc.zzb();\n                                 if (((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzay)) {\n                                 }\n                                 z4 = true;\n                                 i = 0;\n                                 while (i < size) {\n                                 }\n                                 long j62222 = j;\n                                 if (!Log.isLoggable(((zzkd) this).zzl.zzat().zzn(), 2)) {\n                                 }\n                                 zzn();\n                                 byte[] zzbp2222 = zzc.zzaA().zzbp();\n                                 ((zzkd) this).zzl.zzc();\n                                 str2 = (String) zzdw.zzp.zzb((Object) null);\n                                 URL url2222 = new URL(str2);\n                                 Preconditions.checkArgument(!arrayList2.isEmpty());\n                                 if (((zzkd) this).zzw == null) {\n                                 }\n                                 ((zzkd) this).zzl.zzd().zzd.zzb(j62222);\n                                 ((zzkd) this).zzl.zzat().zzk().zzd(\"Uploading data. app, uncompressed size, data\", size > 0 ? zzc.zza(0).zzA() : \"?\", Integer.valueOf(zzbp2222.length), zzh);\n                                 ((zzkd) this).zzs = true;\n                                 zzeo zzh22222 = zzh();\n                                 zzjx zzjxVar2222 = new zzjx(this, zzw);\n                                 zzh22222.zzg();\n                                 zzh22222.zzX();\n                                 Preconditions.checkNotNull(url2222);\n                                 Preconditions.checkNotNull(zzbp2222);\n                                 Preconditions.checkNotNull(zzjxVar2222);\n                                 ((zzge) zzh22222).zzx.zzau().zzk(new zzen(zzh22222, zzw, url2222, zzbp2222, (Map) null, zzjxVar2222));\n                             }\n                             URL url22222 = new URL(str2);\n                             Preconditions.checkArgument(!arrayList2.isEmpty());\n                             if (((zzkd) this).zzw == null) {\n                             }\n                             ((zzkd) this).zzl.zzd().zzd.zzb(j62222);\n                             ((zzkd) this).zzl.zzat().zzk().zzd(\"Uploading data. app, uncompressed size, data\", size > 0 ? zzc.zza(0).zzA() : \"?\", Integer.valueOf(zzbp2222.length), zzh);\n                             ((zzkd) this).zzs = true;\n                             zzeo zzh222222 = zzh();\n                             zzjx zzjxVar22222 = new zzjx(this, zzw);\n                             zzh222222.zzg();\n                             zzh222222.zzX();\n                             Preconditions.checkNotNull(url22222);\n                             Preconditions.checkNotNull(zzbp2222);\n                             Preconditions.checkNotNull(zzjxVar22222);\n                             ((zzge) zzh222222).zzx.zzau().zzk(new zzen(zzh222222, zzw, url22222, zzbp2222, (Map) null, zzjxVar22222));\n                         } catch (MalformedURLException unused) {\n                             ((zzkd) this).zzl.zzat().zzb().zzc(\"Failed to parse upload URL. Not uploading. appId\", zzei.zzl(zzw), str2);\n                         }\n                         z2 = false;\n                         zzlc.zzb();\n                         z3 = true;\n                         zzlc.zzb();\n                         if (((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzay)) {\n                         }\n                         z4 = true;\n                         i = 0;\n                         while (i < size) {\n                         }\n                         long j622222 = j;\n                         if (!Log.isLoggable(((zzkd) this).zzl.zzat().zzn(), 2)) {\n                         }\n                         zzn();\n                         byte[] zzbp22222 = zzc.zzaA().zzbp();\n                         ((zzkd) this).zzl.zzc();\n                         str2 = (String) zzdw.zzp.zzb((Object) null);\n                     }\n                 }\n                 ((zzkd) this).zzt = false;\n             } else {\n                 ((zzkd) this).zzl.zzat().zzk().zza(\"Network not connected, ignoring upload request\");\n                 zzaj();\n                 ((zzkd) this).zzt = false;\n             }\n         }\n         zzak();\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                11893
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.855-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "87b58f5b-25a4-484d-ad13-a517d731eef6",
              "value": "private final long zzZ(String str, String[] strArr) {\n         Cursor cursor = null;\n         try {\n             try {\n                 Cursor rawQuery = zze().rawQuery(str, strArr);\n                 if (!rawQuery.moveToFirst()) {\n                     throw new SQLiteException(\"Database returned empty set\");\n                 }\n                 long j = rawQuery.getLong(0);\n                 if (rawQuery != null) {\n                     rawQuery.close();\n                 }\n                 return j;\n             } catch (SQLiteException e) {\n                 ((zzge) this).zzx.zzat().zzb().zzc(\"Database error\", str, e);\n                 throw e;\n             }\n         } catch (Throwable th) {\n             if (0 != 0) {\n                 cursor.close();\n             }\n             throw th;\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzai.java",
              "file_line": [
                428
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.665-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4251edb7-eb4f-4eb5-bc01-b65ab5f27899",
              "value": "private final long zzaa(String str, String[] strArr, long j) {\n         Cursor cursor = null;\n         try {\n             try {\n                 cursor = zze().rawQuery(str, strArr);\n                 if (cursor.moveToFirst()) {\n                     return cursor.getLong(0);\n                 }\n                 if (cursor != null) {\n                     cursor.close();\n                 }\n                 return j;\n             } catch (SQLiteException e) {\n                 ((zzge) this).zzx.zzat().zzb().zzc(\"Database error\", str, e);\n                 throw e;\n             }\n         } finally {\n             if (cursor != null) {\n                 cursor.close();\n             }\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzai.java",
              "file_line": [
                525
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.685-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8b85a85f-7bc9-494f-8d30-f5e0b43c1152",
              "value": "final zzaf zzx(String str) {\n         String str2;\n         zzaf zzafVar = zzaf.zza;\n         zzlc.zzb();\n         Cursor cursor = null;\n         if (((zzkd) this).zzl.zzc().zzn((String) null, zzdw.zzay)) {\n             ((zzkd) this).zzl.zzau().zzg();\n             zzs();\n             zzafVar = (zzaf) ((zzkd) this).zzz.get(str);\n             if (zzafVar == null) {\n                 zzai zzi = zzi();\n                 Preconditions.checkNotNull(str);\n                 zzi.zzg();\n                 zzi.zzX();\n                 try {\n                     try {\n                         cursor = zzi.zze().rawQuery(\"select consent_state from consent_settings where app_id=? limit 1;\", new String[]{str});\n                         if (cursor.moveToFirst()) {\n                             str2 = cursor.getString(0);\n                         } else {\n                             if (cursor != null) {\n                                 cursor.close();\n                             }\n                             str2 = \"G1\";\n                         }\n                         zzaf zzc = zzaf.zzc(str2);\n                         zzv(str, zzc);\n                         return zzc;\n                     } catch (SQLiteException e) {\n                         ((zzge) zzi).zzx.zzat().zzb().zzc(\"Database error\", \"select consent_state from consent_settings where app_id=? limit 1;\", e);\n                         throw e;\n                     }\n                 } finally {\n                     if (cursor != null) {\n                         cursor.close();\n                     }\n                 }\n             }\n         }\n         return zzafVar;\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                20891
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.886-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4a73d0d9-bb19-404f-ab44-afbe38053188",
              "value": "if (r14 == null) goto L67;\n      */\n         if (r14 == null) goto L67;\n      */\n         r14.close();\n      */\n         r0 = null;\n      */\n     \n     final zzdb zza(String str, zzdb zzdbVar) {\n         Cursor cursor;\n         Cursor cursor2;\n         Cursor cursor3;\n         Pair pair;\n         String zzd = zzdbVar.zzd();\n         List zza = zzdbVar.zza();\n         ((zzju) ((zzu) this).zza).zza.zzn();\n         Long l = (Long) zzkf.zzA(zzdbVar, \"_eid\");\n         if (l != null) {\n             if (zzd.equals(\"_ep\")) {\n                 Preconditions.checkNotNull(l);\n                 ((zzju) ((zzu) this).zza).zza.zzn();\n                 String str2 = (String) zzkf.zzA(zzdbVar, \"_en\");\n                 if (TextUtils.isEmpty(str2)) {\n                     ((zzge) ((zzu) this).zza).zzx.zzat().zzc().zzb(\"Extra parameter without an event name. eventId\", l);\n                     return null;\n                 }\n                 if (((zzu) this).zzb == null || ((zzu) this).zzc == null || l.longValue() != ((zzu) this).zzc.longValue()) {\n                     zzai zzi = ((zzju) ((zzu) this).zza).zza.zzi();\n                     zzi.zzg();\n                     zzi.zzX();\n                     try {\n                         try {\n                             cursor2 = zzi.zze().rawQuery(\"select main_event, children_to_process from main_event_params where app_id=? and event_id=?\", new String[]{str, String.valueOf(l)});\n                             try {\n                                 if (cursor2.moveToFirst()) {\n                                     try {\n                                         pair = Pair.create(zzkf.zzt(zzdb.zzk(), cursor2.getBlob(0)).zzaA(), Long.valueOf(cursor2.getLong(1)));\n                                         if (cursor2 != null) {\n                                             cursor2.close();\n                                         }\n                                     } catch (IOException e) {\n                                         ((zzge) zzi).zzx.zzat().zzb().zzd(\"Failed to merge main event. appId, eventId\", zzei.zzl(str), l, e);\n                                     }\n                                 } else {\n                                     ((zzge) zzi).zzx.zzat().zzk().zza(\"Main event not found\");\n                                     if (cursor2 != null) {\n                                         cursor2.close();\n                                     }\n                                     pair = null;\n                                 }\n                             } catch (SQLiteException e2) {\n                                 e = e2;\n                                 ((zzge) zzi).zzx.zzat().zzb().zzb(\"Error selecting main event\", e);\n                             }\n                         } catch (Throwable th) {\n                             th = th;\n                             cursor = cursor3;\n                             if (cursor != null) {\n                                 cursor.close();\n                             }\n                             throw th;\n                         }\n                     } catch (SQLiteException e3) {\n                         e = e3;\n                         cursor2 = null;\n                     } catch (Throwable th2) {\n                         th = th2;\n                         cursor = null;\n                         if (cursor != null) {\n                         }\n                         throw th;\n                     }\n                     if (pair == null || pair.first == null) {\n                         ((zzge) ((zzu) this).zza).zzx.zzat().zzc().zzc(\"Extra parameter without existing main event. eventName, eventId\", str2, l);\n                         return null;\n                     }\n                     ((zzu) this).zzb = (zzdb) pair.first;\n                     ((zzu) this).zzd = ((Long) pair.second).longValue();\n                     ((zzju) ((zzu) this).zza).zza.zzn();\n                     ((zzu) this).zzc = (Long) zzkf.zzA(((zzu) this).zzb, \"_eid\");\n                 }\n                 long j = ((zzu) this).zzd - 1;\n                 ((zzu) this).zzd = j;\n                 if (j <= 0) {\n                     zzai zzi2 = ((zzju) ((zzu) this).zza).zza.zzi();\n                     zzi2.zzg();\n                     ((zzge) zzi2).zzx.zzat().zzk().zzb(\"Clearing complex main event info. appId\", str);\n                     try {\n                         zzi2.zze().execSQL(\"delete from main_event_params where app_id=?\", new String[]{str});\n                     } catch (SQLiteException e4) {\n                         ((zzge) zzi2).zzx.zzat().zzb().zzb(\"Error clearing complex main event\", e4);\n                     }\n                 } else {\n                     ((zzju) ((zzu) this).zza).zza.zzi().zzH(str, l, ((zzu) this).zzd, ((zzu) this).zzb);\n                 }\n                 ArrayList arrayList = new ArrayList();\n                 for (zzdf zzdfVar : ((zzu) this).zzb.zza()) {\n                     ((zzju) ((zzu) this).zza).zza.zzn();\n                     if (zzkf.zzz(zzdbVar, zzdfVar.zzb()) == null) {\n                         arrayList.add(zzdfVar);\n                     }\n                 }\n                 if (arrayList.isEmpty()) {\n                     ((zzge) ((zzu) this).zza).zzx.zzat().zzc().zzb(\"No unique parameters in main event. eventName\", str2);\n                 } else {\n                     arrayList.addAll(zza);\n                     zza = arrayList;\n                 }\n                 zzd = str2;\n             } else {\n                 ((zzu) this).zzc = l;\n                 ((zzu) this).zzb = zzdbVar;\n                 ((zzju) ((zzu) this).zza).zza.zzn();\n                 Object zzA = zzkf.zzA(zzdbVar, \"_epc\");\n                 long longValue = ((Long) (zzA != null ? zzA : 0L)).longValue();\n                 ((zzu) this).zzd = longValue;\n                 if (longValue <= 0) {\n                     ((zzge) ((zzu) this).zza).zzx.zzat().zzc().zzb(\"Complex event with zero extra param count. eventName\", zzd);\n                 } else {\n                     ((zzju) ((zzu) this).zza).zza.zzi().zzH(str, (Long) Preconditions.checkNotNull(l), ((zzu) this).zzd, zzdbVar);\n                 }\n             }\n         }\n         zzda zzbu = zzdbVar.zzbu();\n         zzbu.zzl(zzd);\n         zzbu.zzi();\n         zzbu.zzh(zza);\n         return zzbu.zzaA();\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzu.java",
              "file_line": [
                191
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.903-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "a9c1a9f8-4523-4773-988c-54b558010acb",
              "value": "public final void zzU(String str, long j, long j2, zzkc zzkcVar) {\n         ?? r4;\n         Cursor cursor;\n         String str2;\n         Cursor rawQuery;\n         String string;\n         int i;\n         String str3;\n         String[] strArr;\n         Preconditions.checkNotNull(zzkcVar);\n         zzg();\n         zzX();\n         Cursor cursor2 = null;\n         r3 = null;\n         r3 = null;\n         String str4 = null;\n         try {\n             try {\n                 SQLiteDatabase zze = zze();\n                 r4 = TextUtils.isEmpty(null);\n                 try {\n                     if (r4 != 0) {\n                         int i2 = (j2 > (-1L) ? 1 : (j2 == (-1L) ? 0 : -1));\n                         String[] strArr2 = i2 != 0 ? new String[]{String.valueOf(j2), String.valueOf(j)} : new String[]{String.valueOf(j)};\n                         str2 = i2 != 0 ? \"rowid <= ? and \" : \"\";\n                         StringBuilder sb = new StringBuilder(str2.length() + 148);\n                         sb.append(\"select app_id, metadata_fingerprint from raw_events where \");\n                         sb.append(str2);\n                         sb.append(\"app_id in (select app_id from apps where config_fetched_time >= ?) order by rowid limit 1;\");\n                         rawQuery = zze.rawQuery(sb.toString(), strArr2);\n                         if (!rawQuery.moveToFirst()) {\n                             if (rawQuery != null) {\n                                 rawQuery.close();\n                                 return;\n                             }\n                             return;\n                         }\n                         str4 = rawQuery.getString(0);\n                         string = rawQuery.getString(1);\n                         rawQuery.close();\n                     } else {\n                         int i3 = (j2 > (-1L) ? 1 : (j2 == (-1L) ? 0 : -1));\n                         String[] strArr3 = i3 != 0 ? new String[]{null, String.valueOf(j2)} : new String[]{null};\n                         str2 = i3 != 0 ? \" and rowid <= ?\" : \"\";\n                         StringBuilder sb2 = new StringBuilder(str2.length() + 84);\n                         sb2.append(\"select metadata_fingerprint from raw_events where app_id = ?\");\n                         sb2.append(str2);\n                         sb2.append(\" order by rowid limit 1;\");\n                         rawQuery = zze.rawQuery(sb2.toString(), strArr3);\n                         if (!rawQuery.moveToFirst()) {\n                             if (rawQuery != null) {\n                                 rawQuery.close();\n                                 return;\n                             }\n                             return;\n                         }\n                         string = rawQuery.getString(0);\n                         rawQuery.close();\n                     }\n                     Cursor cursor3 = rawQuery;\n                     Cursor cursor4 = string;\n                     try {\n                         Cursor query = zze.query(\"raw_events_metadata\", new String[]{\"metadata\"}, \"app_id = ? and metadata_fingerprint = ?\", new String[]{str4, cursor4}, null, null, \"rowid\", \"2\");\n                         try {\n                             if (!query.moveToFirst()) {\n                                 ((zzge) this).zzx.zzat().zzb().zzb(\"Raw event metadata record is missing. appId\", zzei.zzl(str4));\n                                 if (query != null) {\n                                     query.close();\n                                     return;\n                                 }\n                                 return;\n                             }\n                             try {\n                                 try {\n                                     zzdj zzaA = zzkf.zzt(zzdj.zzaj(), query.getBlob(0)).zzaA();\n                                     if (query.moveToNext()) {\n                                         ((zzge) this).zzx.zzat().zze().zzb(\"Get multiple raw event metadata records, expected one. appId\", zzei.zzl(str4));\n                                     }\n                                     query.close();\n                                     Preconditions.checkNotNull(zzaA);\n                                     zzkcVar.zza = zzaA;\n                                     if (j2 != -1) {\n                                         i = 1;\n                                         str3 = \"app_id = ? and metadata_fingerprint = ? and rowid <= ?\";\n                                         strArr = new String[]{str4, cursor4, String.valueOf(j2)};\n                                     } else {\n                                         i = 1;\n                                         str3 = \"app_id = ? and metadata_fingerprint = ?\";\n                                         strArr = new String[]{str4, cursor4};\n                                     }\n                                     Cursor query2 = zze.query(\"raw_events\", new String[]{\"rowid\", \"name\", \"timestamp\", \"data\"}, str3, strArr, null, null, \"rowid\", null);\n                                     if (!query2.moveToFirst()) {\n                                         ((zzge) this).zzx.zzat().zze().zzb(\"Raw event data disappeared while in transaction. appId\", zzei.zzl(str4));\n                                         if (query2 != null) {\n                                             query2.close();\n                                             return;\n                                         }\n                                         return;\n                                     }\n                                     do {\n                                         long j3 = query2.getLong(0);\n                                         try {\n                                             zzda zzt = zzkf.zzt(zzdb.zzk(), query2.getBlob(3));\n                                             zzt.zzl(query2.getString(i));\n                                             zzt.zzo(query2.getLong(2));\n                                             if (!zzkcVar.zza(j3, zzt.zzaA())) {\n                                                 if (query2 != null) {\n                                                     query2.close();\n                                                     return;\n                                                 }\n                                                 return;\n                                             }\n                                         } catch (IOException e) {\n                                             ((zzge) this).zzx.zzat().zzb().zzc(\"Data loss. Failed to merge raw event. appId\", zzei.zzl(str4), e);\n                                         }\n                                     } while (query2.moveToNext());\n                                     if (query2 != null) {\n                                         query2.close();\n                                     }\n                                 } catch (IOException e2) {\n                                     ((zzge) this).zzx.zzat().zzb().zzc(\"Data loss. Failed to merge raw event metadata. appId\", zzei.zzl(str4), e2);\n                                     if (query != null) {\n                                         query.close();\n                                     }\n                                 }\n                             } catch (SQLiteException e3) {\n                                 e = e3;\n                                 r4 = cursor4;\n                                 ((zzge) this).zzx.zzat().zzb().zzc(\"Data loss. Error selecting raw event. appId\", zzei.zzl(str4), e);\n                                 if (r4 != 0) {\n                                     r4.close();\n                                 }\n                             } catch (Throwable th) {\n                                 th = th;\n                                 cursor2 = cursor4;\n                                 if (cursor2 != null) {\n                                     cursor2.close();\n                                 }\n                                 throw th;\n                             }\n                         } catch (SQLiteException e4) {\n                             e = e4;\n                             cursor4 = query;\n                         } catch (Throwable th2) {\n                             th = th2;\n                             cursor4 = query;\n                         }\n                     } catch (SQLiteException e5) {\n                         e = e5;\n                         r4 = cursor3;\n                     } catch (Throwable th3) {\n                         th = th3;\n                         cursor2 = cursor3;\n                     }\n                 } catch (SQLiteException e6) {\n                     e = e6;\n                 }\n             } catch (Throwable th4) {\n                 th = th4;\n                 cursor2 = cursor;\n             }\n         } catch (SQLiteException e7) {\n             e = e7;\n             r4 = 0;\n         } catch (Throwable th5) {\n             th = th5;\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzai.java",
              "file_line": [
                3208
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.737-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9daa3b89-9871-4ed7-bdd8-ad24fb8fe90e",
              "value": "public final String zzw() {\n         SQLiteException e;\n         Cursor cursor;\n         Cursor cursor2 = null;\n         try {\n             cursor = zze().rawQuery(\"select app_id from queue order by has_realtime desc, rowid asc limit 1;\", null);\n             try {\n                 try {\n                     if (!cursor.moveToFirst()) {\n                         if (cursor != null) {\n                             cursor.close();\n                         }\n                         return null;\n                     }\n                     String string = cursor.getString(0);\n                     if (cursor != null) {\n                         cursor.close();\n                     }\n                     return string;\n                 } catch (SQLiteException e2) {\n                     e = e2;\n                     ((zzge) this).zzx.zzat().zzb().zzb(\"Database error getting next bundle app id\", e);\n                     if (cursor != null) {\n                         cursor.close();\n                     }\n                     return null;\n                 }\n             } catch (Throwable th) {\n                 cursor2 = cursor;\n                 th = th;\n                 if (cursor2 != null) {\n                     cursor2.close();\n                 }\n                 throw th;\n             }\n         } catch (SQLiteException e3) {\n             e = e3;\n             cursor = null;\n         } catch (Throwable th2) {\n             th = th2;\n             if (cursor2 != null) {\n             }\n             throw th;\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzai.java",
              "file_line": [
                8693
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.754-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f7787449-04c5-493d-8fed-b5b7f64c4a31",
              "value": "private final boolean zzq(int i, byte[] bArr) {\n         SQLiteDatabase sQLiteDatabase;\n         Cursor cursor;\n         zzg();\n         ?? r2 = 0;\n         if (((zzec) this).zzb) {\n             return false;\n         }\n         ContentValues contentValues = new ContentValues();\n         contentValues.put(\"type\", Integer.valueOf(i));\n         contentValues.put(\"entry\", bArr);\n         ((zzge) this).zzx.zzc();\n         int i2 = 0;\n         int i3 = 5;\n         for (int i4 = 5; i2 < i4; i4 = 5) {\n             Cursor cursor2 = null;\n             cursor2 = null;\n             cursor2 = null;\n             r8 = null;\n             SQLiteDatabase sQLiteDatabase2 = null;\n             try {\n                 sQLiteDatabase = zzo();\n                 try {\n                     if (sQLiteDatabase == null) {\n                         ((zzec) this).zzb = true;\n                         return r2;\n                     }\n                     sQLiteDatabase.beginTransaction();\n                     cursor = sQLiteDatabase.rawQuery(\"select count(1) from messages\", null);\n                     long j = 0;\n                     if (cursor != null) {\n                         try {\n                             if (cursor.moveToFirst()) {\n                                 j = cursor.getLong(r2);\n                             }\n                         } catch (SQLiteDatabaseLockedException unused) {\n                             cursor2 = cursor;\n                             try {\n                                 SystemClock.sleep(i3);\n                                 i3 += 20;\n                                 if (cursor2 != null) {\n                                     cursor2.close();\n                                 }\n                                 if (sQLiteDatabase != null) {\n                                     sQLiteDatabase.close();\n                                 }\n                                 i2++;\n                                 r2 = 0;\n                             } catch (Throwable th) {\n                                 th = th;\n                                 if (cursor2 != null) {\n                                     cursor2.close();\n                                 }\n                                 if (sQLiteDatabase != null) {\n                                     sQLiteDatabase.close();\n                                 }\n                                 throw th;\n                             }\n                         } catch (SQLiteFullException e) {\n                             e = e;\n                             sQLiteDatabase2 = sQLiteDatabase;\n                             ((zzge) this).zzx.zzat().zzb().zzb(\"Error writing entry; local database full\", e);\n                             ((zzec) this).zzb = true;\n                             if (cursor != null) {\n                                 cursor.close();\n                             }\n                             if (sQLiteDatabase2 == null) {\n                                 i2++;\n                                 r2 = 0;\n                             }\n                             sQLiteDatabase2.close();\n                             i2++;\n                             r2 = 0;\n                         } catch (SQLiteException e2) {\n                             e = e2;\n                             sQLiteDatabase2 = sQLiteDatabase;\n                             if (sQLiteDatabase2 != null) {\n                                 try {\n                                     if (sQLiteDatabase2.inTransaction()) {\n                                         sQLiteDatabase2.endTransaction();\n                                     }\n                                 } catch (Throwable th2) {\n                                     th = th2;\n                                     sQLiteDatabase = sQLiteDatabase2;\n                                     cursor2 = cursor;\n                                     if (cursor2 != null) {\n                                     }\n                                     if (sQLiteDatabase != null) {\n                                     }\n                                     throw th;\n                                 }\n                             }\n                             ((zzge) this).zzx.zzat().zzb().zzb(\"Error writing entry to local database\", e);\n                             ((zzec) this).zzb = true;\n                             if (cursor != null) {\n                                 cursor.close();\n                             }\n                             if (sQLiteDatabase2 == null) {\n                                 i2++;\n                                 r2 = 0;\n                             }\n                             sQLiteDatabase2.close();\n                             i2++;\n                             r2 = 0;\n                         } catch (Throwable th3) {\n                             th = th3;\n                             cursor2 = cursor;\n                             if (cursor2 != null) {\n                             }\n                             if (sQLiteDatabase != null) {\n                             }\n                             throw th;\n                         }\n                     }\n                     if (j >= 100000) {\n                         ((zzge) this).zzx.zzat().zzb().zza(\"Data loss, local db full\");\n                         long j2 = (100000 - j) + 1;\n                         String[] strArr = new String[1];\n                         strArr[r2] = Long.toString(j2);\n                         long delete = sQLiteDatabase.delete(\"messages\", \"rowid in (select rowid from messages order by rowid asc limit ?)\", strArr);\n                         if (delete != j2) {\n                             ((zzge) this).zzx.zzat().zzb().zzd(\"Different delete count than expected in local db. expected, received, difference\", Long.valueOf(j2), Long.valueOf(delete), Long.valueOf(j2 - delete));\n                         }\n                     }\n                     sQLiteDatabase.insertOrThrow(\"messages\", null, contentValues);\n                     sQLiteDatabase.setTransactionSuccessful();\n                     sQLiteDatabase.endTransaction();\n                     if (cursor != 0) {\n                         cursor.close();\n                     }\n                     sQLiteDatabase.close();\n                     return true;\n                 } catch (SQLiteDatabaseLockedException unused2) {\n                 } catch (SQLiteFullException e3) {\n                     e = e3;\n                     cursor = null;\n                 } catch (SQLiteException e4) {\n                     e = e4;\n                     cursor = null;\n                 }\n             } catch (SQLiteDatabaseLockedException unused3) {\n                 sQLiteDatabase = null;\n             } catch (SQLiteFullException e5) {\n                 e = e5;\n                 cursor = null;\n             } catch (SQLiteException e6) {\n                 e = e6;\n                 cursor = null;\n             } catch (Throwable th4) {\n                 th = th4;\n                 sQLiteDatabase = null;\n                 if (cursor2 != null) {\n                 }\n                 if (sQLiteDatabase != null) {\n                 }\n                 throw th;\n             }\n         }\n         ((zzge) this).zzx.zzat().zzk().zza(\"Failed to write entry to local database\");\n         return false;\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzec.java",
              "file_line": [
                124
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.772-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "486beb73-ad31-456c-ac73-17bf26b573d2",
              "value": "if (r10 > (com.google.android.gms.measurement.internal.zzae.zzA() + r8)) goto L341;\n      */\n     \n     private final boolean zzae(String str, long j) {\n         String str2;\n         long j2;\n         long j3;\n         zzdi zzdiVar;\n         zzkc zzkcVar;\n         long parseLong;\n         int zzk;\n         zzkc zzkcVar2;\n         SecureRandom secureRandom;\n         zzdi zzdiVar2;\n         Long l;\n         Map map;\n         long zzab;\n         Map map2;\n         zzdi zzdiVar3;\n         ClsR5CBZFU7VF5OSZW clsR5CBZFU7VF5OSZW;\n         zzai zzi;\n         zzdj zzaA;\n         long currentTimeMillis;\n         long zzo;\n         ContentValues contentValues;\n         zzg zzs;\n         String str3;\n         String str4;\n         boolean z;\n         int i;\n         String str5;\n         zzdi zzdiVar4;\n         int i2;\n         String str6;\n         String str7;\n         zzdi zzdiVar5;\n         int i3;\n         String str8;\n         zzdi zzdiVar6;\n         int i4;\n         int i5;\n         String str9;\n         String str10;\n         int i6;\n         zzda zzdaVar;\n         int i7;\n         int i8;\n         zzda zzdaVar2;\n         char c;\n         ClsR5CBZFU7VF5OSZW clsR5CBZFU7VF5OSZW2 = this;\n         String str11 = \"_sn\";\n         String str12 = \"_npa\";\n         String str13 = \"_ai\";\n         zzi().zzb();\n         try {\n             zzkc zzkcVar3 = new zzkc(clsR5CBZFU7VF5OSZW2, (zzjw) null);\n             zzi().zzU((String) null, j, ((zzkd) clsR5CBZFU7VF5OSZW2).zzy, zzkcVar3);\n             List list = zzkcVar3.zzc;\n             try {\n                 if (list != null && !list.isEmpty()) {\n                     zzdi zzbu = zzkcVar3.zza.zzbu();\n                     zzbu.zzh();\n                     boolean zzn = ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzc().zzn(zzkcVar3.zza.zzA(), zzdw.zzT);\n                     zzda zzdaVar3 = null;\n                     zzda zzdaVar4 = null;\n                     int i9 = -1;\n                     int i10 = 0;\n                     int i11 = -1;\n                     long j4 = 0;\n                     int i12 = 0;\n                     int i13 = 0;\n                     while (true) {\n                         String str14 = \"_fr\";\n                         String str15 = \"_et\";\n                         str2 = str12;\n                         j2 = j4;\n                         if (i10 >= zzkcVar3.zzc.size()) {\n                             break;\n                         }\n                         zzda zzdaVar5 = (zzda) ((zzdb) zzkcVar3.zzc.get(i10)).zzbu();\n                         int i14 = i10;\n                         if (zzf().zzi(zzkcVar3.zza.zzA(), zzdaVar5.zzk())) {\n                             ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zze().zzc(\"Dropping blacklisted raw event. appId\", zzei.zzl(zzkcVar3.zza.zzA()), ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzm().zzc(zzdaVar5.zzk()));\n                             if (!zzf().zzl(zzkcVar3.zza.zzA()) && !zzf().zzm(zzkcVar3.zza.zzA()) && !\"_err\".equals(zzdaVar5.zzk())) {\n                                 ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzl().zzM(((zzkd) clsR5CBZFU7VF5OSZW2).zzA, zzkcVar3.zza.zzA(), 11, \"_ev\", zzdaVar5.zzk(), 0);\n                             }\n                             str3 = str13;\n                             zzdiVar6 = zzbu;\n                             z = zzn;\n                             j4 = j2;\n                             i7 = i14;\n                             str10 = str11;\n                         } else {\n                             if (zzdaVar5.zzk().equals(zzgi.zza(str13))) {\n                                 zzdaVar5.zzl(str13);\n                                 ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zzk().zza(\"Renaming ad_impression to _ai\");\n                                 if (Log.isLoggable(((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zzn(), 5)) {\n                                     int i15 = 0;\n                                     while (i15 < zzdaVar5.zzb()) {\n                                         String str16 = str13;\n                                         if (\"ad_platform\".equals(zzdaVar5.zzc(i15).zzb()) && !TextUtils.isEmpty(zzdaVar5.zzc(i15).zzd()) && \"admob\".equalsIgnoreCase(zzdaVar5.zzc(i15).zzd())) {\n                                             ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zzh().zza(\"AdMob ad impression logged from app. Potentially duplicative.\");\n                                         }\n                                         i15++;\n                                         str13 = str16;\n                                     }\n                                 }\n                             }\n                             str3 = str13;\n                             boolean zzj = zzf().zzj(zzkcVar3.zza.zzA(), zzdaVar5.zzk());\n                             if (zzj) {\n                                 str4 = str11;\n                                 z = zzn;\n                             } else {\n                                 zzn();\n                                 String zzk2 = zzdaVar5.zzk();\n                                 Preconditions.checkNotEmpty(zzk2);\n                                 z = zzn;\n                                 int hashCode = zzk2.hashCode();\n                                 str4 = str11;\n                                 if (hashCode == 94660) {\n                                     if (zzk2.equals(\"_in\")) {\n                                         c = 0;\n                                         if (c != 0) {\n                                         }\n                                     }\n                                     c = 65535;\n                                     if (c != 0) {\n                                     }\n                                 } else if (hashCode != 95025) {\n                                     if (hashCode == 95027 && zzk2.equals(\"_ui\")) {\n                                         c = 1;\n                                         if (c != 0 && c != 1 && c != 2) {\n                                             i2 = i9;\n                                             str6 = \"_fr\";\n                                             str5 = \"_et\";\n                                             i = i11;\n                                             zzj = false;\n                                             str7 = \"_e\";\n                                             zzdiVar4 = zzbu;\n                                             if (zzj) {\n                                                 ArrayList arrayList = new ArrayList(zzdaVar5.zza());\n                                                 int i16 = -1;\n                                                 int i17 = -1;\n                                                 for (int i18 = 0; i18 < arrayList.size(); i18++) {\n                                                     if (\"value\".equals(((zzdf) arrayList.get(i18)).zzb())) {\n                                                         i16 = i18;\n                                                     } else if (\"currency\".equals(((zzdf) arrayList.get(i18)).zzb())) {\n                                                         i17 = i18;\n                                                     }\n                                                 }\n                                                 if (i16 != -1) {\n                                                     if (((zzdf) arrayList.get(i16)).zze() || ((zzdf) arrayList.get(i16)).zzi()) {\n                                                         if (i17 != -1) {\n                                                             String zzd = ((zzdf) arrayList.get(i17)).zzd();\n                                                             if (zzd.length() == 3) {\n                                                                 int i19 = 0;\n                                                                 while (i19 < zzd.length()) {\n                                                                     int codePointAt = zzd.codePointAt(i19);\n                                                                     if (Character.isLetter(codePointAt)) {\n                                                                         i19 += Character.charCount(codePointAt);\n                                                                     }\n                                                                 }\n                                                             }\n                                                         }\n                                                         ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zzh().zza(\"Value parameter discarded. You must also supply a 3-letter ISO_4217 currency code in the currency parameter.\");\n                                                         zzdaVar5.zzj(i16);\n                                                         zzkd.zzad(zzdaVar5, \"_c\");\n                                                         zzkd.zzac(zzdaVar5, 19, \"currency\");\n                                                         break;\n                                                     }\n                                                     ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zzh().zza(\"Value must be specified with a numeric type.\");\n                                                     zzdaVar5.zzj(i16);\n                                                     zzkd.zzad(zzdaVar5, \"_c\");\n                                                     zzkd.zzac(zzdaVar5, 18, \"value\");\n                                                 }\n                                                 if (str7.equals(zzdaVar5.zzk())) {\n                                                     zzdiVar6 = zzdiVar4;\n                                                     i4 = i2;\n                                                     if (\"_vs\".equals(zzdaVar5.zzk())) {\n                                                         zzn();\n                                                         str9 = str5;\n                                                         if (zzkf.zzz(zzdaVar5.zzaA(), str9) == null) {\n                                                             if (zzdaVar3 == null || Math.abs(zzdaVar3.zzn() - zzdaVar5.zzn()) > 1000) {\n                                                                 i11 = i;\n                                                                 zzdaVar4 = zzdaVar5;\n                                                                 i9 = i12;\n                                                             } else {\n                                                                 zzda zzay = zzdaVar3.zzay();\n                                                                 if (clsR5CBZFU7VF5OSZW2.zzag(zzay, zzdaVar5)) {\n                                                                     i6 = i;\n                                                                     zzdiVar6.zze(i6, zzay);\n                                                                     i9 = i4;\n                                                                     zzdaVar = null;\n                                                                     zzdaVar3 = null;\n                                                                 } else {\n                                                                     i6 = i;\n                                                                     zzdaVar = zzdaVar5;\n                                                                     i9 = i12;\n                                                                 }\n                                                                 zzdaVar4 = zzdaVar;\n                                                                 i11 = i6;\n                                                             }\n                                                             str10 = str4;\n                                                         } else {\n                                                             i5 = i;\n                                                             str10 = str4;\n                                                             i11 = i5;\n                                                             i9 = i4;\n                                                         }\n                                                     } else {\n                                                         i5 = i;\n                                                         str9 = str5;\n                                                         if (((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzc().zzn(zzkcVar3.zza.zzA(), zzdw.zzak) && \"_ab\".equals(zzdaVar5.zzk())) {\n                                                             zzn();\n                                                             if (zzkf.zzz(zzdaVar5.zzaA(), str9) == null && zzdaVar3 != null && Math.abs(zzdaVar3.zzn() - zzdaVar5.zzn()) <= 4000) {\n                                                                 zzda zzay2 = zzdaVar3.zzay();\n                                                                 clsR5CBZFU7VF5OSZW2.zzah(zzay2, zzdaVar5);\n                                                                 Preconditions.checkArgument(str7.equals(zzay2.zzk()));\n                                                                 zzn();\n                                                                 str10 = str4;\n                                                                 zzdf zzz = zzkf.zzz(zzay2.zzaA(), str10);\n                                                                 zzn();\n                                                                 zzdf zzz2 = zzkf.zzz(zzay2.zzaA(), \"_sc\");\n                                                                 zzn();\n                                                                 zzdf zzz3 = zzkf.zzz(zzay2.zzaA(), \"_si\");\n                                                                 String zzd2 = zzz != null ? zzz.zzd() : \"\";\n                                                                 if (!TextUtils.isEmpty(zzd2)) {\n                                                                     zzn();\n                                                                     zzkf.zzx(zzdaVar5, str10, zzd2);\n                                                                 }\n                                                                 String zzd3 = zzz2 != null ? zzz2.zzd() : \"\";\n                                                                 if (!TextUtils.isEmpty(zzd3)) {\n                                                                     zzn();\n                                                                     zzkf.zzx(zzdaVar5, \"_sc\", zzd3);\n                                                                 }\n                                                                 if (zzz3 != null) {\n                                                                     zzn();\n                                                                     zzkf.zzx(zzdaVar5, \"_si\", Long.valueOf(zzz3.zzf()));\n                                                                 }\n                                                                 zzdiVar6.zze(i5, zzay2);\n                                                                 i11 = i5;\n                                                                 i9 = i4;\n                                                                 zzdaVar3 = null;\n                                                             }\n                                                         }\n                                                         str10 = str4;\n                                                         i11 = i5;\n                                                         i9 = i4;\n                                                     }\n                                                     if (!z) {\n                                                     }\n                                                     j4 = j2;\n                                                     i7 = i14;\n                                                     zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                     i12++;\n                                                     zzdiVar6.zzf(zzdaVar5);\n                                                 } else {\n                                                     zzn();\n                                                     if (zzkf.zzz(zzdaVar5.zzaA(), str6) == null) {\n                                                         if (zzdaVar4 == null || Math.abs(zzdaVar4.zzn() - zzdaVar5.zzn()) > 1000) {\n                                                             zzdiVar6 = zzdiVar4;\n                                                             zzdaVar3 = zzdaVar5;\n                                                             i9 = i2;\n                                                             i11 = i12;\n                                                         } else {\n                                                             zzda zzay3 = zzdaVar4.zzay();\n                                                             if (clsR5CBZFU7VF5OSZW2.zzag(zzdaVar5, zzay3)) {\n                                                                 zzdiVar6 = zzdiVar4;\n                                                                 i8 = i2;\n                                                                 zzdiVar6.zze(i8, zzay3);\n                                                                 i11 = i;\n                                                                 zzdaVar2 = null;\n                                                                 zzdaVar4 = null;\n                                                             } else {\n                                                                 zzdiVar6 = zzdiVar4;\n                                                                 i8 = i2;\n                                                                 zzdaVar2 = zzdaVar5;\n                                                                 i11 = i12;\n                                                             }\n                                                             zzdaVar3 = zzdaVar2;\n                                                             i9 = i8;\n                                                         }\n                                                         str10 = str4;\n                                                         str9 = str5;\n                                                         if (!z && str7.equals(zzdaVar5.zzk())) {\n                                                             if (zzdaVar5.zzb() != 0) {\n                                                                 ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zze().zzb(\"Engagement event does not contain any parameters. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                                             } else {\n                                                                 zzn();\n                                                                 Long l2 = (Long) zzkf.zzA(zzdaVar5.zzaA(), str9);\n                                                                 if (l2 == null) {\n                                                                     ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zze().zzb(\"Engagement event does not include duration. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                                                 } else {\n                                                                     j4 = j2 + l2.longValue();\n                                                                     i7 = i14;\n                                                                     zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                                     i12++;\n                                                                     zzdiVar6.zzf(zzdaVar5);\n                                                                 }\n                                                             }\n                                                         }\n                                                         j4 = j2;\n                                                         i7 = i14;\n                                                         zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                         i12++;\n                                                         zzdiVar6.zzf(zzdaVar5);\n                                                     } else {\n                                                         zzdiVar6 = zzdiVar4;\n                                                         i4 = i2;\n                                                         i5 = i;\n                                                         str10 = str4;\n                                                         str9 = str5;\n                                                         i11 = i5;\n                                                         i9 = i4;\n                                                         if (!z) {\n                                                             if (zzdaVar5.zzb() != 0) {\n                                                             }\n                                                         }\n                                                         j4 = j2;\n                                                         i7 = i14;\n                                                         zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                         i12++;\n                                                         zzdiVar6.zzf(zzdaVar5);\n                                                     }\n                                                 }\n                                             }\n                                             if (str7.equals(zzdaVar5.zzk())) {\n                                             }\n                                         }\n                                     }\n                                     c = 65535;\n                                     if (c != 0) {\n                                         i2 = i9;\n                                         str6 = \"_fr\";\n                                         str5 = \"_et\";\n                                         i = i11;\n                                         zzj = false;\n                                         str7 = \"_e\";\n                                         zzdiVar4 = zzbu;\n                                         if (zzj) {\n                                         }\n                                         if (str7.equals(zzdaVar5.zzk())) {\n                                         }\n                                     }\n                                 } else {\n                                     if (zzk2.equals(\"_ug\")) {\n                                         c = 2;\n                                         if (c != 0) {\n                                         }\n                                     }\n                                     c = 65535;\n                                     if (c != 0) {\n                                     }\n                                 }\n                             }\n                             i = i11;\n                             int i20 = 0;\n                             boolean z2 = false;\n                             boolean z3 = false;\n                             while (true) {\n                                 str5 = str15;\n                                 if (i20 >= zzdaVar5.zzb()) {\n                                     break;\n                                 }\n                                 if (\"_c\".equals(zzdaVar5.zzc(i20).zzb())) {\n                                     zzde zzbu2 = zzdaVar5.zzc(i20).zzbu();\n                                     zzdiVar5 = zzbu;\n                                     i3 = i9;\n                                     zzbu2.zzd(1L);\n                                     zzdaVar5.zzd(i20, zzbu2.zzaA());\n                                     str8 = str14;\n                                     z2 = true;\n                                 } else {\n                                     zzdiVar5 = zzbu;\n                                     i3 = i9;\n                                     if (\"_r\".equals(zzdaVar5.zzc(i20).zzb())) {\n                                         zzde zzbu3 = zzdaVar5.zzc(i20).zzbu();\n                                         str8 = str14;\n                                         zzbu3.zzd(1L);\n                                         zzdaVar5.zzd(i20, zzbu3.zzaA());\n                                         z3 = true;\n                                     } else {\n                                         str8 = str14;\n                                     }\n                                 }\n                                 i20++;\n                                 str14 = str8;\n                                 zzbu = zzdiVar5;\n                                 str15 = str5;\n                                 i9 = i3;\n                             }\n                             zzdiVar4 = zzbu;\n                             i2 = i9;\n                             String str17 = str14;\n                             if (z2 || !zzj) {\n                                 str6 = str17;\n                             } else {\n                                 ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zzk().zzb(\"Marking event as conversion\", ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzm().zzc(zzdaVar5.zzk()));\n                                 zzde zzn2 = zzdf.zzn();\n                                 zzn2.zza(\"_c\");\n                                 str6 = str17;\n                                 zzn2.zzd(1L);\n                                 zzdaVar5.zzg(zzn2);\n                             }\n                             if (!z3) {\n                                 ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zzk().zzb(\"Marking event as real-time\", ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzm().zzc(zzdaVar5.zzk()));\n                                 zzde zzn3 = zzdf.zzn();\n                                 zzn3.zza(\"_r\");\n                                 zzn3.zzd(1L);\n                                 zzdaVar5.zzg(zzn3);\n                             }\n                             str7 = \"_e\";\n                             if (zzi().zzu(zzy(), zzkcVar3.zza.zzA(), false, false, false, false, true).zze > ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzc().zzk(zzkcVar3.zza.zzA(), zzdw.zzn)) {\n                                 zzkd.zzad(zzdaVar5, \"_r\");\n                             } else {\n                                 i13 = 1;\n                             }\n                             if (zzkk.zzh(zzdaVar5.zzk()) && zzj && zzi().zzu(zzy(), zzkcVar3.zza.zzA(), false, false, true, false, false).zzc > ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzc().zzk(zzkcVar3.zza.zzA(), zzdw.zzm)) {\n                                 ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zze().zzb(\"Too many conversions. Not logging as conversion. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                 zzde zzdeVar = null;\n                                 boolean z4 = false;\n                                 int i21 = -1;\n                                 for (int i22 = 0; i22 < zzdaVar5.zzb(); i22++) {\n                                     zzdf zzc = zzdaVar5.zzc(i22);\n                                     if (\"_c\".equals(zzc.zzb())) {\n                                         zzdeVar = zzc.zzbu();\n                                         i21 = i22;\n                                     } else if (\"_err\".equals(zzc.zzb())) {\n                                         z4 = true;\n                                     }\n                                 }\n                                 if (z4) {\n                                     if (zzdeVar != null) {\n                                         zzdaVar5.zzj(i21);\n                                     } else {\n                                         zzdeVar = null;\n                                     }\n                                 }\n                                 if (zzdeVar != null) {\n                                     zzde zzay4 = zzdeVar.zzay();\n                                     zzay4.zza(\"_err\");\n                                     zzay4.zzd(10L);\n                                     zzdaVar5.zzd(i21, zzay4.zzaA());\n                                 } else {\n                                     ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zzb().zzb(\"Did not find conversion parameter. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                 }\n                             }\n                             if (zzj) {\n                             }\n                             if (str7.equals(zzdaVar5.zzk())) {\n                             }\n                         }\n                         i10 = i7 + 1;\n                         zzbu = zzdiVar6;\n                         str11 = str10;\n                         str12 = str2;\n                         zzn = z;\n                         str13 = str3;\n                     }\n                     zzdi zzdiVar7 = zzbu;\n                     if (zzn) {\n                         int i23 = i12;\n                         j3 = j2;\n                         int i24 = 0;\n                         while (i24 < i23) {\n                             zzdb zzd4 = zzdiVar7.zzd(i24);\n                             if (\"_e\".equals(zzd4.zzd())) {\n                                 zzn();\n                                 if (zzkf.zzz(zzd4, \"_fr\") != null) {\n                                     zzdiVar7.zzi(i24);\n                                     i23--;\n                                     i24--;\n                                     i24++;\n                                 }\n                             }\n                             zzn();\n                             zzdf zzz4 = zzkf.zzz(zzd4, \"_et\");\n                             if (zzz4 != null) {\n                                 Long valueOf = zzz4.zze() ? Long.valueOf(zzz4.zzf()) : null;\n                                 if (valueOf != null && valueOf.longValue() > 0) {\n                                     j3 += valueOf.longValue();\n                                 }\n                             }\n                             i24++;\n                         }\n                     } else {\n                         j3 = j2;\n                     }\n                     clsR5CBZFU7VF5OSZW2.zzaf(zzdiVar7, j3, false);\n                     Iterator it = zzdiVar7.zzb().iterator();\n                     while (true) {\n                         if (it.hasNext()) {\n                             if (\"_s\".equals(((zzdb) it.next()).zzd())) {\n                                 zzi().zzi(zzdiVar7.zzG(), \"_se\");\n                                 break;\n                             }\n                         } else {\n                             break;\n                         }\n                     }\n                     if (zzkf.zzu(zzdiVar7, \"_sid\") >= 0) {\n                         clsR5CBZFU7VF5OSZW2.zzaf(zzdiVar7, j3, true);\n                     } else {\n                         int zzu = zzkf.zzu(zzdiVar7, \"_se\");\n                         if (zzu >= 0) {\n                             zzdiVar7.zzq(zzu);\n                             ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zzb().zzb(\"Session engagement user property is in the bundle without session ID. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                         }\n                     }\n                     zzkf zzn4 = zzn();\n                     ((zzge) zzn4).zzx.zzat().zzk().zza(\"Checking account type status for ad personalization signals\");\n                     if (((zzju) zzn4).zza.zzf().zzf(zzdiVar7.zzG()) && (zzs = ((zzju) zzn4).zza.zzi().zzs(zzdiVar7.zzG())) != null && zzs.zzaf() && ((zzge) zzn4).zzx.zzz().zzf()) {\n                         ((zzge) zzn4).zzx.zzat().zzj().zza(\"Turning off ad personalization due to account type\");\n                         zzdt zzj2 = zzdu.zzj();\n                         zzj2.zzb(str2);\n                         zzj2.zza(((zzge) zzn4).zzx.zzz().zzd());\n                         zzj2.zze(1L);\n                         zzdu zzaA2 = zzj2.zzaA();\n                         int i25 = 0;\n                         while (true) {\n                             if (i25 >= zzdiVar7.zzk()) {\n                                 zzdiVar7.zzn(zzaA2);\n                                 break;\n                             } else if (str2.equals(zzdiVar7.zzl(i25).zzc())) {\n                                 zzdiVar7.zzm(i25, zzaA2);\n                                 break;\n                             } else {\n                                 i25++;\n                             }\n                         }\n                     }\n                     zzdiVar7.zzt(Long.MAX_VALUE);\n                     zzdiVar7.zzv(Long.MIN_VALUE);\n                     for (int i26 = 0; i26 < zzdiVar7.zzc(); i26++) {\n                         zzdb zzd5 = zzdiVar7.zzd(i26);\n                         if (zzd5.zzf() < zzdiVar7.zzs()) {\n                             zzdiVar7.zzt(zzd5.zzf());\n                         }\n                         if (zzd5.zzf() > zzdiVar7.zzu()) {\n                             zzdiVar7.zzv(zzd5.zzf());\n                         }\n                     }\n                     zzdiVar7.zzac();\n                     zzdiVar7.zzZ();\n                     zzdiVar7.zzY(zzl().zzb(zzdiVar7.zzG(), zzdiVar7.zzb(), zzdiVar7.zzj(), Long.valueOf(zzdiVar7.zzs()), Long.valueOf(zzdiVar7.zzu())));\n                     if (((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzc().zzx(zzkcVar3.zza.zzA())) {\n                         try {\n                             Map hashMap = new HashMap();\n                             ArrayList arrayList2 = new ArrayList();\n                             SecureRandom zzf = ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzl().zzf();\n                             int i27 = 0;\n                             while (i27 < zzdiVar7.zzc()) {\n                                 zzda zzbu4 = zzdiVar7.zzd(i27).zzbu();\n                                 if (zzbu4.zzk().equals(\"_ep\")) {\n                                     zzn();\n                                     String str18 = (String) zzkf.zzA(zzbu4.zzaA(), \"_en\");\n                                     zzao zzaoVar = (zzao) hashMap.get(str18);\n                                     if (zzaoVar == null) {\n                                         zzaoVar = zzi().zzf(zzkcVar3.zza.zzA(), str18);\n                                         hashMap.put(str18, zzaoVar);\n                                     }\n                                     if (zzaoVar.zzi == null) {\n                                         if (zzaoVar.zzj.longValue() > 1) {\n                                             zzn();\n                                             zzkf.zzx(zzbu4, \"_sr\", zzaoVar.zzj);\n                                         }\n                                         Boolean bool = zzaoVar.zzk;\n                                         if (bool != null && bool.booleanValue()) {\n                                             zzn();\n                                             zzkf.zzx(zzbu4, \"_efs\", 1L);\n                                         }\n                                         arrayList2.add(zzbu4.zzaA());\n                                     }\n                                     zzdiVar7.zze(i27, zzbu4);\n                                     zzdiVar3 = zzdiVar7;\n                                     zzkcVar2 = zzkcVar3;\n                                     secureRandom = zzf;\n                                     map2 = hashMap;\n                                 } else {\n                                     zzfc zzf2 = zzf();\n                                     String zzA = zzkcVar3.zza.zzA();\n                                     String zza = zzf2.zza(zzA, \"measurement.account.time_zone_offset_minutes\");\n                                     if (!TextUtils.isEmpty(zza)) {\n                                         try {\n                                             parseLong = Long.parseLong(zza);\n                                         } catch (NumberFormatException e) {\n                                             ((zzge) zzf2).zzx.zzat().zze().zzc(\"Unable to parse timezone offset. appId\", zzei.zzl(zzA), e);\n                                         }\n                                         long zzab2 = ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzl().zzab(zzbu4.zzn(), parseLong);\n                                         zzdb zzaA3 = zzbu4.zzaA();\n                                         long j5 = parseLong;\n                                         Long l3 = 1L;\n                                         if (!TextUtils.isEmpty(\"_dbg\")) {\n                                             Iterator it2 = zzaA3.zza().iterator();\n                                             while (true) {\n                                                 if (!it2.hasNext()) {\n                                                     break;\n                                                 }\n                                                 zzdf zzdfVar = (zzdf) it2.next();\n                                                 Iterator it3 = it2;\n                                                 if (!\"_dbg\".equals(zzdfVar.zzb())) {\n                                                     it2 = it3;\n                                                 } else if (l3.equals(Long.valueOf(zzdfVar.zzf()))) {\n                                                     zzk = 1;\n                                                 }\n                                             }\n                                         }\n                                         zzk = zzf().zzk(zzkcVar3.zza.zzA(), zzbu4.zzk());\n                                         if (zzk > 0) {\n                                             ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zze().zzc(\"Sample rate must be positive. event, rate\", zzbu4.zzk(), Integer.valueOf(zzk));\n                                             arrayList2.add(zzbu4.zzaA());\n                                             zzdiVar7.zze(i27, zzbu4);\n                                         } else {\n                                             zzao zzaoVar2 = (zzao) hashMap.get(zzbu4.zzk());\n                                             if (zzaoVar2 == null && (zzaoVar2 = zzi().zzf(zzkcVar3.zza.zzA(), zzbu4.zzk())) == null) {\n                                                 ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzat().zze().zzc(\"Event being bundled has no eventAggregate. appId, eventName\", zzkcVar3.zza.zzA(), zzbu4.zzk());\n                                                 zzaoVar2 = new zzao(zzkcVar3.zza.zzA(), zzbu4.zzk(), 1L, 1L, 1L, zzbu4.zzn(), 0L, (Long) null, (Long) null, (Long) null, (Boolean) null);\n                                             }\n                                             zzn();\n                                             Long l4 = (Long) zzkf.zzA(zzbu4.zzaA(), \"_eid\");\n                                             Boolean valueOf2 = Boolean.valueOf(l4 != null);\n                                             if (zzk == 1) {\n                                                 arrayList2.add(zzbu4.zzaA());\n                                                 if (valueOf2.booleanValue() && (zzaoVar2.zzi != null || zzaoVar2.zzj != null || zzaoVar2.zzk != null)) {\n                                                     hashMap.put(zzbu4.zzk(), zzaoVar2.zzc((Long) null, (Long) null, (Boolean) null));\n                                                 }\n                                                 zzdiVar7.zze(i27, zzbu4);\n                                             } else {\n                                                 if (zzf.nextInt(zzk) == 0) {\n                                                     zzn();\n                                                     zzkcVar2 = zzkcVar3;\n                                                     secureRandom = zzf;\n                                                     Long valueOf3 = Long.valueOf(zzk);\n                                                     zzkf.zzx(zzbu4, \"_sr\", valueOf3);\n                                                     arrayList2.add(zzbu4.zzaA());\n                                                     if (valueOf2.booleanValue()) {\n                                                         zzaoVar2 = zzaoVar2.zzc((Long) null, valueOf3, (Boolean) null);\n                                                     }\n                                                     hashMap.put(zzbu4.zzk(), zzaoVar2.zzb(zzbu4.zzn(), zzab2));\n                                                     map2 = hashMap;\n                                                     zzdiVar3 = zzdiVar7;\n                                                 } else {\n                                                     zzkcVar2 = zzkcVar3;\n                                                     secureRandom = zzf;\n                                                     Long l5 = zzaoVar2.zzh;\n                                                     if (l5 != null) {\n                                                         zzab = l5.longValue();\n                                                         l = l4;\n                                                         map = hashMap;\n                                                         zzdiVar2 = zzdiVar7;\n                                                     } else {\n                                                         zzdiVar2 = zzdiVar7;\n                                                         l = l4;\n                                                         map = hashMap;\n                                                         zzab = ((zzkd) this).zzl.zzl().zzab(zzbu4.zzp(), j5);\n                                                     }\n                                                     if (zzab != zzab2) {\n                                                         zzn();\n                                                         zzkf.zzx(zzbu4, \"_efs\", 1L);\n                                                         zzn();\n                                                         Long valueOf4 = Long.valueOf(zzk);\n                                                         zzkf.zzx(zzbu4, \"_sr\", valueOf4);\n                                                         arrayList2.add(zzbu4.zzaA());\n                                                         if (valueOf2.booleanValue()) {\n                                                             zzaoVar2 = zzaoVar2.zzc((Long) null, valueOf4, true);\n                                                         }\n                                                         map2 = map;\n                                                         map2.put(zzbu4.zzk(), zzaoVar2.zzb(zzbu4.zzn(), zzab2));\n                                                     } else {\n                                                         map2 = map;\n                                                         if (valueOf2.booleanValue()) {\n                                                             map2.put(zzbu4.zzk(), zzaoVar2.zzc(l, (Long) null, (Boolean) null));\n                                                         }\n                                                     }\n                                                     zzdiVar3 = zzdiVar2;\n                                                 }\n                                                 zzdiVar3.zze(i27, zzbu4);\n                                             }\n                                         }\n                                         zzdiVar3 = zzdiVar7;\n                                         zzkcVar2 = zzkcVar3;\n                                         secureRandom = zzf;\n                                         map2 = hashMap;\n                                     }\n                                     parseLong = 0;\n                                     long zzab22 = ((zzkd) clsR5CBZFU7VF5OSZW2).zzl.zzl().zzab(zzbu4.zzn(), parseLong);\n                                     zzdb zzaA32 = zzbu4.zzaA();\n                                     long j52 = parseLong;\n                                     Long l32 = 1L;\n                                     if (!TextUtils.isEmpty(\"_dbg\")) {\n                                     }\n                                     zzk = zzf().zzk(zzkcVar3.zza.zzA(), zzbu4.zzk());\n                                     if (zzk > 0) {\n                                     }\n                                     zzdiVar3 = zzdiVar7;\n                                     zzkcVar2 = zzkcVar3;\n                                     secureRandom = zzf;\n                                     map2 = hashMap;\n                                 }\n                                 i27++;\n                                 zzdiVar7 = zzdiVar3;\n                                 hashMap = map2;\n                                 zzkcVar3 = zzkcVar2;\n                                 clsR5CBZFU7VF5OSZW2 = this;\n                                 zzf = secureRandom;\n                             }\n                             Map map3 = hashMap;\n                             zzdiVar = zzdiVar7;\n                             zzkc zzkcVar4 = zzkcVar3;\n                             if (arrayList2.size() < zzdiVar.zzc()) {\n                                 zzdiVar.zzh();\n                                 zzdiVar.zzg(arrayList2);\n                             }\n                             for (Map.Entry entry : map3.entrySet()) {\n                                 zzi().zzh((zzao) entry.getValue());\n                             }\n                             zzkcVar = zzkcVar4;\n                         } catch (Throwable th) {\n                             th = th;\n                             Throwable th2 = th;\n                             zzi().zzd();\n                             throw th2;\n                         }\n                     } else {\n                         zzdiVar = zzdiVar7;\n                         zzkcVar = zzkcVar3;\n                     }\n                     String zzA2 = zzkcVar.zza.zzA();\n                     zzg zzs2 = zzi().zzs(zzA2);\n                     if (zzs2 == null) {\n                         clsR5CBZFU7VF5OSZW = this;\n                         ((zzkd) clsR5CBZFU7VF5OSZW).zzl.zzat().zzb().zzb(\"Bundling raw events w/o app info. appId\", zzei.zzl(zzkcVar.zza.zzA()));\n                     } else {\n                         clsR5CBZFU7VF5OSZW = this;\n                         if (zzdiVar.zzc() > 0) {\n                             long zzr = zzs2.zzr();\n                             if (zzr != 0) {\n                                 zzdiVar.zzy(zzr);\n                             } else {\n                                 zzdiVar.zzz();\n                             }\n                             long zzp = zzs2.zzp();\n                             if (zzp != 0) {\n                                 zzr = zzp;\n                             }\n                             if (zzr != 0) {\n                                 zzdiVar.zzw(zzr);\n                             } else {\n                                 zzdiVar.zzx();\n                             }\n                             zzs2.zzN();\n                             zzdiVar.zzS((int) zzs2.zzI());\n                             zzs2.zzq(zzdiVar.zzs());\n                             zzs2.zzs(zzdiVar.zzu());\n                             String zzab3 = zzs2.zzab();\n                             if (zzab3 != null) {\n                                 zzdiVar.zzT(zzab3);\n                             } else {\n                                 zzdiVar.zzU();\n                             }\n                             zzi().zzt(zzs2);\n                         }\n                     }\n                     if (zzdiVar.zzc() > 0) {\n                         ((zzkd) clsR5CBZFU7VF5OSZW).zzl.zzas();\n                         zzcp zzb = zzf().zzb(zzkcVar.zza.zzA());\n                         try {\n                             try {\n                                 if (zzb != null && zzb.zza()) {\n                                     zzdiVar.zzad(zzb.zzb());\n                                     zzi = zzi();\n                                     zzaA = zzdiVar.zzaA();\n                                     zzi.zzg();\n                                     zzi.zzX();\n                                     Preconditions.checkNotNull(zzaA);\n                                     Preconditions.checkNotEmpty(zzaA.zzA());\n                                     Preconditions.checkState(zzaA.zzn());\n                                     zzi.zzy();\n                                     currentTimeMillis = ((zzge) zzi).zzx.zzax().currentTimeMillis();\n                                     zzo = zzaA.zzo();\n                                     ((zzge) zzi).zzx.zzc();\n                                     if (zzo >= currentTimeMillis - zzae.zzA()) {\n                                         long zzo2 = zzaA.zzo();\n                                         ((zzge) zzi).zzx.zzc();\n                                     }\n                                     ((zzge) zzi).zzx.zzat().zze().zzd(\"Storing bundle outside of the max uploading time span. appId, now, timestamp\", zzei.zzl(zzaA.zzA()), Long.valueOf(currentTimeMillis), Long.valueOf(zzaA.zzo()));\n                                     byte[] zzs3 = ((zzju) zzi).zza.zzn().zzs(zzaA.zzbp());\n                                     ((zzge) zzi).zzx.zzat().zzk().zzb(\"Saving bundle, size\", Integer.valueOf(zzs3.length));\n                                     contentValues = new ContentValues();\n                                     contentValues.put(\"app_id\", zzaA.zzA());\n                                     contentValues.put(\"bundle_end_timestamp\", Long.valueOf(zzaA.zzo()));\n                                     contentValues.put(\"data\", zzs3);\n                                     contentValues.put(\"has_realtime\", Integer.valueOf(i13));\n                                     if (zzaA.zzab()) {\n                                         contentValues.put(\"retry_count\", Integer.valueOf(zzaA.zzac()));\n                                     }\n                                     if (zzi.zze().insert(\"queue\", null, contentValues) == -1) {\n                                         ((zzge) zzi).zzx.zzat().zzb().zzb(\"Failed to insert bundle (got -1). appId\", zzei.zzl(zzaA.zzA()));\n                                     }\n                                 }\n                                 if (zzi.zze().insert(\"queue\", null, contentValues) == -1) {\n                                 }\n                             } catch (SQLiteException e2) {\n                                 ((zzge) zzi).zzx.zzat().zzb().zzc(\"Error storing bundle. appId\", zzei.zzl(zzaA.zzA()), e2);\n                             }\n                             byte[] zzs32 = ((zzju) zzi).zza.zzn().zzs(zzaA.zzbp());\n                             ((zzge) zzi).zzx.zzat().zzk().zzb(\"Saving bundle, size\", Integer.valueOf(zzs32.length));\n                             contentValues = new ContentValues();\n                             contentValues.put(\"app_id\", zzaA.zzA());\n                             contentValues.put(\"bundle_end_timestamp\", Long.valueOf(zzaA.zzo()));\n                             contentValues.put(\"data\", zzs32);\n                             contentValues.put(\"has_realtime\", Integer.valueOf(i13));\n                             if (zzaA.zzab()) {\n                             }\n                         } catch (IOException e3) {\n                             ((zzge) zzi).zzx.zzat().zzb().zzc(\"Data loss. Failed to serialize bundle. appId\", zzei.zzl(zzaA.zzA()), e3);\n                         }\n                         if (TextUtils.isEmpty(zzkcVar.zza.zzP())) {\n                             zzdiVar.zzad(-1L);\n                         } else {\n                             ((zzkd) clsR5CBZFU7VF5OSZW).zzl.zzat().zze().zzb(\"Did not find measurement config or missing version info. appId\", zzei.zzl(zzkcVar.zza.zzA()));\n                         }\n                         zzi = zzi();\n                         zzaA = zzdiVar.zzaA();\n                         zzi.zzg();\n                         zzi.zzX();\n                         Preconditions.checkNotNull(zzaA);\n                         Preconditions.checkNotEmpty(zzaA.zzA());\n                         Preconditions.checkState(zzaA.zzn());\n                         zzi.zzy();\n                         currentTimeMillis = ((zzge) zzi).zzx.zzax().currentTimeMillis();\n                         zzo = zzaA.zzo();\n                         ((zzge) zzi).zzx.zzc();\n                         if (zzo >= currentTimeMillis - zzae.zzA()) {\n                         }\n                         ((zzge) zzi).zzx.zzat().zze().zzd(\"Storing bundle outside of the max uploading time span. appId, now, timestamp\", zzei.zzl(zzaA.zzA()), Long.valueOf(currentTimeMillis), Long.valueOf(zzaA.zzo()));\n                     }\n                     zzai zzi2 = zzi();\n                     List list2 = zzkcVar.zzb;\n                     Preconditions.checkNotNull(list2);\n                     zzi2.zzg();\n                     zzi2.zzX();\n                     StringBuilder sb = new StringBuilder(\"rowid in (\");\n                     for (int i28 = 0; i28 < list2.size(); i28++) {\n                         if (i28 != 0) {\n                             sb.append(\",\");\n                         }\n                         sb.append(((Long) list2.get(i28)).longValue());\n                     }\n                     sb.append(\")\");\n                     int delete = zzi2.zze().delete(\"raw_events\", sb.toString(), null);\n                     if (delete != list2.size()) {\n                         ((zzge) zzi2).zzx.zzat().zzb().zzc(\"Deleted fewer rows from raw events table than expected\", Integer.valueOf(delete), Integer.valueOf(list2.size()));\n                     }\n                     zzai zzi3 = zzi();\n                     try {\n                         zzi3.zze().execSQL(\"delete from raw_events_metadata where app_id=? and metadata_fingerprint not in (select distinct metadata_fingerprint from raw_events where app_id=?)\", new String[]{zzA2, zzA2});\n                     } catch (SQLiteException e4) {\n                         ((zzge) zzi3).zzx.zzat().zzb().zzc(\"Failed to remove unused event metadata. appId\", zzei.zzl(zzA2), e4);\n                     }\n                     zzi().zzc();\n                     zzi().zzd();\n                     return true;\n                 }\n                 zzi().zzc();\n                 zzi().zzd();\n                 return false;\n             } catch (Throwable th3) {\n                 th = th3;\n                 Throwable th22 = th;\n                 zzi().zzd();\n                 throw th22;\n             }\n         } catch (Throwable th4) {\n             th = th4;\n             Throwable th222 = th;\n             zzi().zzd();\n             throw th222;\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                4836
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.807-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8c899c60-5a1e-47c9-bde7-a21df4caac4d",
              "value": "public void onCreate(SQLiteDatabase sQLiteDatabase) {\n         sQLiteDatabase.execSQL(\"CREATE TABLE serverCache (path TEXT PRIMARY KEY, value BLOB);\");\n         sQLiteDatabase.execSQL(\"CREATE TABLE writes (id INTEGER, path TEXT, type TEXT, part INTEGER, node BLOB, UNIQUE (id, part));\");\n         sQLiteDatabase.execSQL(\"CREATE TABLE trackedQueries (id INTEGER PRIMARY KEY, path TEXT, queryParams TEXT, lastUse INTEGER, complete INTEGER, active INTEGER);\");\n         sQLiteDatabase.execSQL(\"CREATE TABLE trackedKeys (id INTEGER, key TEXT);\");\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine$PersistentCacheOpenHelper.java",
              "file_line": [
                66
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.947-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "983360aa-7d82-441e-9b22-dcbd2065c349",
              "value": "public long serverCacheEstimatedSizeInBytes() {\n         Cursor rawQuery = ((SqlPersistenceStorageEngine) this).database.rawQuery(String.format(\"SELECT sum(length(%s) + length(%s)) FROM %s\", \"value\", \"path\", \"serverCache\"), null);\n         try {\n             if (rawQuery.moveToFirst()) {\n                 return rawQuery.getLong(0);\n             }\n             throw new IllegalStateException(\"Couldn't read database result!\");\n         } finally {\n             rawQuery.close();\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine.java",
              "file_line": [
                4696
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.999-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "427a78cd-08b2-4448-874d-d2318dfb31bd",
              "value": "public final void zzi(String str, String str2) {\n         Preconditions.checkNotEmpty(str);\n         Preconditions.checkNotEmpty(str2);\n         zzg();\n         zzX();\n         try {\n             zze().delete(\"user_attributes\", \"app_id=? and name=?\", new String[]{str, str2});\n         } catch (SQLiteException e) {\n             ((zzge) this).zzx.zzat().zzb().zzd(\"Error deleting user property. appId\", zzei.zzl(str), ((zzge) this).zzx.zzm().zze(str2), e);\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzai.java",
              "file_line": [
                4712
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.037-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1e988e2c-4f65-48c4-b8ca-ea7d15eb49c4",
              "value": "public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) {\n         Utilities.hardAssert(i2 == 2, \"Why is onUpgrade() called with a different version?\");\n         if (i <= 1) {\n             dropTable(sQLiteDatabase, \"serverCache\");\n             sQLiteDatabase.execSQL(\"CREATE TABLE serverCache (path TEXT PRIMARY KEY, value BLOB);\");\n             dropTable(sQLiteDatabase, \"complete\");\n             sQLiteDatabase.execSQL(\"CREATE TABLE trackedKeys (id INTEGER, key TEXT);\");\n             sQLiteDatabase.execSQL(\"CREATE TABLE trackedQueries (id INTEGER PRIMARY KEY, path TEXT, queryParams TEXT, lastUse INTEGER, complete INTEGER, active INTEGER);\");\n             return;\n         }\n         throw new AssertionError(\"We don't handle upgrading to \" + i2);\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine$PersistentCacheOpenHelper.java",
              "file_line": [
                118
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.964-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3343ffcd-b661-4277-bc9c-078197b7ccf6",
              "value": "public final boolean zzn() {\n         int i;\n         zzg();\n         if (!((zzec) this).zzb && zzp()) {\n             int i2 = 5;\n             for (i = 0; i < 5; i = i + 1) {\n                 SQLiteDatabase sQLiteDatabase = null;\n                 try {\n                     SQLiteDatabase zzo = zzo();\n                     if (zzo == null) {\n                         ((zzec) this).zzb = true;\n                         return false;\n                     }\n                     zzo.beginTransaction();\n                     zzo.delete(\"messages\", \"type == ?\", new String[]{Integer.toString(3)});\n                     zzo.setTransactionSuccessful();\n                     zzo.endTransaction();\n                     zzo.close();\n                     return true;\n                 } catch (SQLiteDatabaseLockedException unused) {\n                     SystemClock.sleep(i2);\n                     i2 += 20;\n                     i = 0 == 0 ? i + 1 : 0;\n                     sQLiteDatabase.close();\n                 } catch (SQLiteFullException e) {\n                     ((zzge) this).zzx.zzat().zzb().zzb(\"Error deleting app launch break from local database\", e);\n                     ((zzec) this).zzb = true;\n                     if (0 == 0) {\n                     }\n                     sQLiteDatabase.close();\n                 } catch (SQLiteException e2) {\n                     if (0 != 0) {\n                         try {\n                             if (sQLiteDatabase.inTransaction()) {\n                                 sQLiteDatabase.endTransaction();\n                             }\n                         } catch (Throwable th) {\n                             if (0 != 0) {\n                                 sQLiteDatabase.close();\n                             }\n                             throw th;\n                         }\n                     }\n                     ((zzge) this).zzx.zzat().zzb().zzb(\"Error deleting app launch break from local database\", e2);\n                     ((zzec) this).zzb = true;\n                     if (0 != 0) {\n                         sQLiteDatabase.close();\n                     }\n                 }\n             }\n             ((zzge) this).zzx.zzat().zze().zza(\"Error deleting app launch break from local database in reasonable time\");\n         }\n         return false;\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzec.java",
              "file_line": [
                1824
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.126-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4de8f831-9dc1-492a-b649-4ce929fa6e6a",
              "value": "public void pruneCache(Path path, PruneForest pruneForest) {\n         int i;\n         int i2;\n         if (pruneForest.prunesAnything()) {\n             verifyInsideTransaction();\n             long currentTimeMillis = System.currentTimeMillis();\n             Cursor loadNestedQuery = loadNestedQuery(path, new String[]{\"rowid\", \"path\"});\n             ImmutableTree immutableTree = new ImmutableTree((Object) null);\n             ImmutableTree immutableTree2 = new ImmutableTree((Object) null);\n             while (loadNestedQuery.moveToNext()) {\n                 long j = loadNestedQuery.getLong(0);\n                 Path path2 = new Path(loadNestedQuery.getString(1));\n                 if (!path.contains(path2)) {\n                     ((SqlPersistenceStorageEngine) this).logger.warn(\"We are pruning at \" + path + \" but we have data stored higher up at \" + path2 + \". Ignoring.\");\n                 } else {\n                     Path relative = Path.getRelative(path, path2);\n                     if (pruneForest.shouldPruneUnkeptDescendants(relative)) {\n                         immutableTree = immutableTree.set(relative, Long.valueOf(j));\n                     } else if (pruneForest.shouldKeep(relative)) {\n                         immutableTree2 = immutableTree2.set(relative, Long.valueOf(j));\n                     } else {\n                         ((SqlPersistenceStorageEngine) this).logger.warn(\"We are pruning at \" + path + \" and have data at \" + path2 + \" that isn't marked for pruning or keeping. Ignoring.\");\n                     }\n                 }\n             }\n             if (immutableTree.isEmpty()) {\n                 i = 0;\n                 i2 = 0;\n             } else {\n                 ArrayList<Pair> arrayList = new ArrayList();\n                 pruneTreeRecursive(path, Path.getEmptyPath(), immutableTree, immutableTree2, pruneForest, arrayList);\n                 Collection values = immutableTree.values();\n                 ((SqlPersistenceStorageEngine) this).database.delete(\"serverCache\", \"rowid IN (\" + commaSeparatedList(values) + \")\", null);\n                 for (Pair pair : arrayList) {\n                     saveNested(path.child((Path) pair.getFirst()), (Node) pair.getSecond());\n                 }\n                 i = values.size();\n                 i2 = arrayList.size();\n             }\n             long currentTimeMillis2 = System.currentTimeMillis() - currentTimeMillis;\n             if (((SqlPersistenceStorageEngine) this).logger.logsDebug()) {\n                 ((SqlPersistenceStorageEngine) this).logger.debug(String.format(Locale.US, \"Pruned %d rows with %d nodes resaved in %dms\", Integer.valueOf(i), Integer.valueOf(i2), Long.valueOf(currentTimeMillis2)), new Object[0]);\n             }\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine.java",
              "file_line": [
                3752
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.546-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "140f46fd-e868-488b-a53d-54123cd01ac5",
              "value": "final void zzy() {\n         zzg();\n         zzX();\n         if (zzK()) {\n             long zza = ((zzge) this).zzx.zzd().zzf.zza();\n             long elapsedRealtime = ((zzge) this).zzx.zzax().elapsedRealtime();\n             long abs = Math.abs(elapsedRealtime - zza);\n             ((zzge) this).zzx.zzc();\n             if (abs > ((Long) zzdw.zzx.zzb((Object) null)).longValue()) {\n                 ((zzge) this).zzx.zzd().zzf.zzb(elapsedRealtime);\n                 zzg();\n                 zzX();\n                 if (zzK()) {\n                     SQLiteDatabase zze = zze();\n                     ((zzge) this).zzx.zzc();\n                     int delete = zze.delete(\"queue\", \"abs(bundle_end_timestamp - ?) > cast(? as integer)\", new String[]{String.valueOf(((zzge) this).zzx.zzax().currentTimeMillis()), String.valueOf(zzae.zzA())});\n                     if (delete > 0) {\n                         ((zzge) this).zzx.zzat().zzk().zzb(\"Deleted stale rows. rowsDeleted\", Integer.valueOf(delete));\n                     }\n                 }\n             }\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzai.java",
              "file_line": [
                8979
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.078-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "865f194c-b2b9-4160-98d7-e41a1c61907a",
              "value": "if (r10 > (com.google.android.gms.measurement.internal.zzae.zzA() + r8)) goto L341;\n      */\n     \n     private final boolean zzae(String str, long j) {\n         String str2;\n         long j2;\n         long j3;\n         zzdi zzdiVar;\n         zzkc zzkcVar;\n         long parseLong;\n         int zzk;\n         zzkc zzkcVar2;\n         SecureRandom secureRandom;\n         zzdi zzdiVar2;\n         Long l;\n         Map map;\n         long zzab;\n         Map map2;\n         zzdi zzdiVar3;\n         ClsBZH1OEM6MPAI1F8 clsBZH1OEM6MPAI1F8;\n         zzai zzi;\n         zzdj zzaA;\n         long currentTimeMillis;\n         long zzo;\n         ContentValues contentValues;\n         zzg zzs;\n         String str3;\n         String str4;\n         boolean z;\n         int i;\n         String str5;\n         zzdi zzdiVar4;\n         int i2;\n         String str6;\n         String str7;\n         zzdi zzdiVar5;\n         int i3;\n         String str8;\n         zzdi zzdiVar6;\n         int i4;\n         int i5;\n         String str9;\n         String str10;\n         int i6;\n         zzda zzdaVar;\n         int i7;\n         int i8;\n         zzda zzdaVar2;\n         char c;\n         ClsBZH1OEM6MPAI1F8 clsBZH1OEM6MPAI1F82 = this;\n         String str11 = \"_sn\";\n         String str12 = \"_npa\";\n         String str13 = \"_ai\";\n         zzi().zzb();\n         try {\n             zzkc zzkcVar3 = new zzkc(clsBZH1OEM6MPAI1F82, (zzjw) null);\n             zzi().zzU((String) null, j, ((zzkd) clsBZH1OEM6MPAI1F82).zzy, zzkcVar3);\n             List list = zzkcVar3.zzc;\n             try {\n                 if (list != null && !list.isEmpty()) {\n                     zzdi zzbu = zzkcVar3.zza.zzbu();\n                     zzbu.zzh();\n                     boolean zzn = ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzc().zzn(zzkcVar3.zza.zzA(), zzdw.zzT);\n                     zzda zzdaVar3 = null;\n                     zzda zzdaVar4 = null;\n                     int i9 = -1;\n                     int i10 = 0;\n                     int i11 = -1;\n                     long j4 = 0;\n                     int i12 = 0;\n                     int i13 = 0;\n                     while (true) {\n                         String str14 = \"_fr\";\n                         String str15 = \"_et\";\n                         str2 = str12;\n                         j2 = j4;\n                         if (i10 >= zzkcVar3.zzc.size()) {\n                             break;\n                         }\n                         zzda zzdaVar5 = (zzda) ((zzdb) zzkcVar3.zzc.get(i10)).zzbu();\n                         int i14 = i10;\n                         if (zzf().zzi(zzkcVar3.zza.zzA(), zzdaVar5.zzk())) {\n                             ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zze().zzc(\"Dropping blacklisted raw event. appId\", zzei.zzl(zzkcVar3.zza.zzA()), ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzm().zzc(zzdaVar5.zzk()));\n                             if (!zzf().zzl(zzkcVar3.zza.zzA()) && !zzf().zzm(zzkcVar3.zza.zzA()) && !\"_err\".equals(zzdaVar5.zzk())) {\n                                 ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzl().zzM(((zzkd) clsBZH1OEM6MPAI1F82).zzA, zzkcVar3.zza.zzA(), 11, \"_ev\", zzdaVar5.zzk(), 0);\n                             }\n                             str3 = str13;\n                             zzdiVar6 = zzbu;\n                             z = zzn;\n                             j4 = j2;\n                             i7 = i14;\n                             str10 = str11;\n                         } else {\n                             if (zzdaVar5.zzk().equals(zzgi.zza(str13))) {\n                                 zzdaVar5.zzl(str13);\n                                 ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zzk().zza(\"Renaming ad_impression to _ai\");\n                                 if (Log.isLoggable(((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zzn(), 5)) {\n                                     int i15 = 0;\n                                     while (i15 < zzdaVar5.zzb()) {\n                                         String str16 = str13;\n                                         if (\"ad_platform\".equals(zzdaVar5.zzc(i15).zzb()) && !TextUtils.isEmpty(zzdaVar5.zzc(i15).zzd()) && \"admob\".equalsIgnoreCase(zzdaVar5.zzc(i15).zzd())) {\n                                             ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zzh().zza(\"AdMob ad impression logged from app. Potentially duplicative.\");\n                                         }\n                                         i15++;\n                                         str13 = str16;\n                                     }\n                                 }\n                             }\n                             str3 = str13;\n                             boolean zzj = zzf().zzj(zzkcVar3.zza.zzA(), zzdaVar5.zzk());\n                             if (zzj) {\n                                 str4 = str11;\n                                 z = zzn;\n                             } else {\n                                 zzn();\n                                 String zzk2 = zzdaVar5.zzk();\n                                 Preconditions.checkNotEmpty(zzk2);\n                                 z = zzn;\n                                 int hashCode = zzk2.hashCode();\n                                 str4 = str11;\n                                 if (hashCode == 94660) {\n                                     if (zzk2.equals(\"_in\")) {\n                                         c = 0;\n                                         if (c != 0) {\n                                         }\n                                     }\n                                     c = 65535;\n                                     if (c != 0) {\n                                     }\n                                 } else if (hashCode != 95025) {\n                                     if (hashCode == 95027 && zzk2.equals(\"_ui\")) {\n                                         c = 1;\n                                         if (c != 0 && c != 1 && c != 2) {\n                                             i2 = i9;\n                                             str6 = \"_fr\";\n                                             str5 = \"_et\";\n                                             i = i11;\n                                             zzj = false;\n                                             str7 = \"_e\";\n                                             zzdiVar4 = zzbu;\n                                             if (zzj) {\n                                                 ArrayList arrayList = new ArrayList(zzdaVar5.zza());\n                                                 int i16 = -1;\n                                                 int i17 = -1;\n                                                 for (int i18 = 0; i18 < arrayList.size(); i18++) {\n                                                     if (\"value\".equals(((zzdf) arrayList.get(i18)).zzb())) {\n                                                         i16 = i18;\n                                                     } else if (\"currency\".equals(((zzdf) arrayList.get(i18)).zzb())) {\n                                                         i17 = i18;\n                                                     }\n                                                 }\n                                                 if (i16 != -1) {\n                                                     if (((zzdf) arrayList.get(i16)).zze() || ((zzdf) arrayList.get(i16)).zzi()) {\n                                                         if (i17 != -1) {\n                                                             String zzd = ((zzdf) arrayList.get(i17)).zzd();\n                                                             if (zzd.length() == 3) {\n                                                                 int i19 = 0;\n                                                                 while (i19 < zzd.length()) {\n                                                                     int codePointAt = zzd.codePointAt(i19);\n                                                                     if (Character.isLetter(codePointAt)) {\n                                                                         i19 += Character.charCount(codePointAt);\n                                                                     }\n                                                                 }\n                                                             }\n                                                         }\n                                                         ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zzh().zza(\"Value parameter discarded. You must also supply a 3-letter ISO_4217 currency code in the currency parameter.\");\n                                                         zzdaVar5.zzj(i16);\n                                                         zzkd.zzad(zzdaVar5, \"_c\");\n                                                         zzkd.zzac(zzdaVar5, 19, \"currency\");\n                                                         break;\n                                                     }\n                                                     ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zzh().zza(\"Value must be specified with a numeric type.\");\n                                                     zzdaVar5.zzj(i16);\n                                                     zzkd.zzad(zzdaVar5, \"_c\");\n                                                     zzkd.zzac(zzdaVar5, 18, \"value\");\n                                                 }\n                                                 if (str7.equals(zzdaVar5.zzk())) {\n                                                     zzdiVar6 = zzdiVar4;\n                                                     i4 = i2;\n                                                     if (\"_vs\".equals(zzdaVar5.zzk())) {\n                                                         zzn();\n                                                         str9 = str5;\n                                                         if (zzkf.zzz(zzdaVar5.zzaA(), str9) == null) {\n                                                             if (zzdaVar3 == null || Math.abs(zzdaVar3.zzn() - zzdaVar5.zzn()) > 1000) {\n                                                                 i11 = i;\n                                                                 zzdaVar4 = zzdaVar5;\n                                                                 i9 = i12;\n                                                             } else {\n                                                                 zzda zzay = zzdaVar3.zzay();\n                                                                 if (clsBZH1OEM6MPAI1F82.zzag(zzay, zzdaVar5)) {\n                                                                     i6 = i;\n                                                                     zzdiVar6.zze(i6, zzay);\n                                                                     i9 = i4;\n                                                                     zzdaVar = null;\n                                                                     zzdaVar3 = null;\n                                                                 } else {\n                                                                     i6 = i;\n                                                                     zzdaVar = zzdaVar5;\n                                                                     i9 = i12;\n                                                                 }\n                                                                 zzdaVar4 = zzdaVar;\n                                                                 i11 = i6;\n                                                             }\n                                                             str10 = str4;\n                                                         } else {\n                                                             i5 = i;\n                                                             str10 = str4;\n                                                             i11 = i5;\n                                                             i9 = i4;\n                                                         }\n                                                     } else {\n                                                         i5 = i;\n                                                         str9 = str5;\n                                                         if (((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzc().zzn(zzkcVar3.zza.zzA(), zzdw.zzak) && \"_ab\".equals(zzdaVar5.zzk())) {\n                                                             zzn();\n                                                             if (zzkf.zzz(zzdaVar5.zzaA(), str9) == null && zzdaVar3 != null && Math.abs(zzdaVar3.zzn() - zzdaVar5.zzn()) <= 4000) {\n                                                                 zzda zzay2 = zzdaVar3.zzay();\n                                                                 clsBZH1OEM6MPAI1F82.zzah(zzay2, zzdaVar5);\n                                                                 Preconditions.checkArgument(str7.equals(zzay2.zzk()));\n                                                                 zzn();\n                                                                 str10 = str4;\n                                                                 zzdf zzz = zzkf.zzz(zzay2.zzaA(), str10);\n                                                                 zzn();\n                                                                 zzdf zzz2 = zzkf.zzz(zzay2.zzaA(), \"_sc\");\n                                                                 zzn();\n                                                                 zzdf zzz3 = zzkf.zzz(zzay2.zzaA(), \"_si\");\n                                                                 String zzd2 = zzz != null ? zzz.zzd() : \"\";\n                                                                 if (!TextUtils.isEmpty(zzd2)) {\n                                                                     zzn();\n                                                                     zzkf.zzx(zzdaVar5, str10, zzd2);\n                                                                 }\n                                                                 String zzd3 = zzz2 != null ? zzz2.zzd() : \"\";\n                                                                 if (!TextUtils.isEmpty(zzd3)) {\n                                                                     zzn();\n                                                                     zzkf.zzx(zzdaVar5, \"_sc\", zzd3);\n                                                                 }\n                                                                 if (zzz3 != null) {\n                                                                     zzn();\n                                                                     zzkf.zzx(zzdaVar5, \"_si\", Long.valueOf(zzz3.zzf()));\n                                                                 }\n                                                                 zzdiVar6.zze(i5, zzay2);\n                                                                 i11 = i5;\n                                                                 i9 = i4;\n                                                                 zzdaVar3 = null;\n                                                             }\n                                                         }\n                                                         str10 = str4;\n                                                         i11 = i5;\n                                                         i9 = i4;\n                                                     }\n                                                     if (!z) {\n                                                     }\n                                                     j4 = j2;\n                                                     i7 = i14;\n                                                     zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                     i12++;\n                                                     zzdiVar6.zzf(zzdaVar5);\n                                                 } else {\n                                                     zzn();\n                                                     if (zzkf.zzz(zzdaVar5.zzaA(), str6) == null) {\n                                                         if (zzdaVar4 == null || Math.abs(zzdaVar4.zzn() - zzdaVar5.zzn()) > 1000) {\n                                                             zzdiVar6 = zzdiVar4;\n                                                             zzdaVar3 = zzdaVar5;\n                                                             i9 = i2;\n                                                             i11 = i12;\n                                                         } else {\n                                                             zzda zzay3 = zzdaVar4.zzay();\n                                                             if (clsBZH1OEM6MPAI1F82.zzag(zzdaVar5, zzay3)) {\n                                                                 zzdiVar6 = zzdiVar4;\n                                                                 i8 = i2;\n                                                                 zzdiVar6.zze(i8, zzay3);\n                                                                 i11 = i;\n                                                                 zzdaVar2 = null;\n                                                                 zzdaVar4 = null;\n                                                             } else {\n                                                                 zzdiVar6 = zzdiVar4;\n                                                                 i8 = i2;\n                                                                 zzdaVar2 = zzdaVar5;\n                                                                 i11 = i12;\n                                                             }\n                                                             zzdaVar3 = zzdaVar2;\n                                                             i9 = i8;\n                                                         }\n                                                         str10 = str4;\n                                                         str9 = str5;\n                                                         if (!z && str7.equals(zzdaVar5.zzk())) {\n                                                             if (zzdaVar5.zzb() != 0) {\n                                                                 ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zze().zzb(\"Engagement event does not contain any parameters. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                                             } else {\n                                                                 zzn();\n                                                                 Long l2 = (Long) zzkf.zzA(zzdaVar5.zzaA(), str9);\n                                                                 if (l2 == null) {\n                                                                     ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zze().zzb(\"Engagement event does not include duration. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                                                 } else {\n                                                                     j4 = j2 + l2.longValue();\n                                                                     i7 = i14;\n                                                                     zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                                     i12++;\n                                                                     zzdiVar6.zzf(zzdaVar5);\n                                                                 }\n                                                             }\n                                                         }\n                                                         j4 = j2;\n                                                         i7 = i14;\n                                                         zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                         i12++;\n                                                         zzdiVar6.zzf(zzdaVar5);\n                                                     } else {\n                                                         zzdiVar6 = zzdiVar4;\n                                                         i4 = i2;\n                                                         i5 = i;\n                                                         str10 = str4;\n                                                         str9 = str5;\n                                                         i11 = i5;\n                                                         i9 = i4;\n                                                         if (!z) {\n                                                             if (zzdaVar5.zzb() != 0) {\n                                                             }\n                                                         }\n                                                         j4 = j2;\n                                                         i7 = i14;\n                                                         zzkcVar3.zzc.set(i7, zzdaVar5.zzaA());\n                                                         i12++;\n                                                         zzdiVar6.zzf(zzdaVar5);\n                                                     }\n                                                 }\n                                             }\n                                             if (str7.equals(zzdaVar5.zzk())) {\n                                             }\n                                         }\n                                     }\n                                     c = 65535;\n                                     if (c != 0) {\n                                         i2 = i9;\n                                         str6 = \"_fr\";\n                                         str5 = \"_et\";\n                                         i = i11;\n                                         zzj = false;\n                                         str7 = \"_e\";\n                                         zzdiVar4 = zzbu;\n                                         if (zzj) {\n                                         }\n                                         if (str7.equals(zzdaVar5.zzk())) {\n                                         }\n                                     }\n                                 } else {\n                                     if (zzk2.equals(\"_ug\")) {\n                                         c = 2;\n                                         if (c != 0) {\n                                         }\n                                     }\n                                     c = 65535;\n                                     if (c != 0) {\n                                     }\n                                 }\n                             }\n                             i = i11;\n                             int i20 = 0;\n                             boolean z2 = false;\n                             boolean z3 = false;\n                             while (true) {\n                                 str5 = str15;\n                                 if (i20 >= zzdaVar5.zzb()) {\n                                     break;\n                                 }\n                                 if (\"_c\".equals(zzdaVar5.zzc(i20).zzb())) {\n                                     zzde zzbu2 = zzdaVar5.zzc(i20).zzbu();\n                                     zzdiVar5 = zzbu;\n                                     i3 = i9;\n                                     zzbu2.zzd(1L);\n                                     zzdaVar5.zzd(i20, zzbu2.zzaA());\n                                     str8 = str14;\n                                     z2 = true;\n                                 } else {\n                                     zzdiVar5 = zzbu;\n                                     i3 = i9;\n                                     if (\"_r\".equals(zzdaVar5.zzc(i20).zzb())) {\n                                         zzde zzbu3 = zzdaVar5.zzc(i20).zzbu();\n                                         str8 = str14;\n                                         zzbu3.zzd(1L);\n                                         zzdaVar5.zzd(i20, zzbu3.zzaA());\n                                         z3 = true;\n                                     } else {\n                                         str8 = str14;\n                                     }\n                                 }\n                                 i20++;\n                                 str14 = str8;\n                                 zzbu = zzdiVar5;\n                                 str15 = str5;\n                                 i9 = i3;\n                             }\n                             zzdiVar4 = zzbu;\n                             i2 = i9;\n                             String str17 = str14;\n                             if (z2 || !zzj) {\n                                 str6 = str17;\n                             } else {\n                                 ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zzk().zzb(\"Marking event as conversion\", ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzm().zzc(zzdaVar5.zzk()));\n                                 zzde zzn2 = zzdf.zzn();\n                                 zzn2.zza(\"_c\");\n                                 str6 = str17;\n                                 zzn2.zzd(1L);\n                                 zzdaVar5.zzg(zzn2);\n                             }\n                             if (!z3) {\n                                 ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zzk().zzb(\"Marking event as real-time\", ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzm().zzc(zzdaVar5.zzk()));\n                                 zzde zzn3 = zzdf.zzn();\n                                 zzn3.zza(\"_r\");\n                                 zzn3.zzd(1L);\n                                 zzdaVar5.zzg(zzn3);\n                             }\n                             str7 = \"_e\";\n                             if (zzi().zzu(zzy(), zzkcVar3.zza.zzA(), false, false, false, false, true).zze > ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzc().zzk(zzkcVar3.zza.zzA(), zzdw.zzn)) {\n                                 zzkd.zzad(zzdaVar5, \"_r\");\n                             } else {\n                                 i13 = 1;\n                             }\n                             if (zzkk.zzh(zzdaVar5.zzk()) && zzj && zzi().zzu(zzy(), zzkcVar3.zza.zzA(), false, false, true, false, false).zzc > ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzc().zzk(zzkcVar3.zza.zzA(), zzdw.zzm)) {\n                                 ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zze().zzb(\"Too many conversions. Not logging as conversion. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                 zzde zzdeVar = null;\n                                 boolean z4 = false;\n                                 int i21 = -1;\n                                 for (int i22 = 0; i22 < zzdaVar5.zzb(); i22++) {\n                                     zzdf zzc = zzdaVar5.zzc(i22);\n                                     if (\"_c\".equals(zzc.zzb())) {\n                                         zzdeVar = zzc.zzbu();\n                                         i21 = i22;\n                                     } else if (\"_err\".equals(zzc.zzb())) {\n                                         z4 = true;\n                                     }\n                                 }\n                                 if (z4) {\n                                     if (zzdeVar != null) {\n                                         zzdaVar5.zzj(i21);\n                                     } else {\n                                         zzdeVar = null;\n                                     }\n                                 }\n                                 if (zzdeVar != null) {\n                                     zzde zzay4 = zzdeVar.zzay();\n                                     zzay4.zza(\"_err\");\n                                     zzay4.zzd(10L);\n                                     zzdaVar5.zzd(i21, zzay4.zzaA());\n                                 } else {\n                                     ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zzb().zzb(\"Did not find conversion parameter. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                                 }\n                             }\n                             if (zzj) {\n                             }\n                             if (str7.equals(zzdaVar5.zzk())) {\n                             }\n                         }\n                         i10 = i7 + 1;\n                         zzbu = zzdiVar6;\n                         str11 = str10;\n                         str12 = str2;\n                         zzn = z;\n                         str13 = str3;\n                     }\n                     zzdi zzdiVar7 = zzbu;\n                     if (zzn) {\n                         int i23 = i12;\n                         j3 = j2;\n                         int i24 = 0;\n                         while (i24 < i23) {\n                             zzdb zzd4 = zzdiVar7.zzd(i24);\n                             if (\"_e\".equals(zzd4.zzd())) {\n                                 zzn();\n                                 if (zzkf.zzz(zzd4, \"_fr\") != null) {\n                                     zzdiVar7.zzi(i24);\n                                     i23--;\n                                     i24--;\n                                     i24++;\n                                 }\n                             }\n                             zzn();\n                             zzdf zzz4 = zzkf.zzz(zzd4, \"_et\");\n                             if (zzz4 != null) {\n                                 Long valueOf = zzz4.zze() ? Long.valueOf(zzz4.zzf()) : null;\n                                 if (valueOf != null && valueOf.longValue() > 0) {\n                                     j3 += valueOf.longValue();\n                                 }\n                             }\n                             i24++;\n                         }\n                     } else {\n                         j3 = j2;\n                     }\n                     clsBZH1OEM6MPAI1F82.zzaf(zzdiVar7, j3, false);\n                     Iterator it = zzdiVar7.zzb().iterator();\n                     while (true) {\n                         if (it.hasNext()) {\n                             if (\"_s\".equals(((zzdb) it.next()).zzd())) {\n                                 zzi().zzi(zzdiVar7.zzG(), \"_se\");\n                                 break;\n                             }\n                         } else {\n                             break;\n                         }\n                     }\n                     if (zzkf.zzu(zzdiVar7, \"_sid\") >= 0) {\n                         clsBZH1OEM6MPAI1F82.zzaf(zzdiVar7, j3, true);\n                     } else {\n                         int zzu = zzkf.zzu(zzdiVar7, \"_se\");\n                         if (zzu >= 0) {\n                             zzdiVar7.zzq(zzu);\n                             ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zzb().zzb(\"Session engagement user property is in the bundle without session ID. appId\", zzei.zzl(zzkcVar3.zza.zzA()));\n                         }\n                     }\n                     zzkf zzn4 = zzn();\n                     ((zzge) zzn4).zzx.zzat().zzk().zza(\"Checking account type status for ad personalization signals\");\n                     if (((zzju) zzn4).zza.zzf().zzf(zzdiVar7.zzG()) && (zzs = ((zzju) zzn4).zza.zzi().zzs(zzdiVar7.zzG())) != null && zzs.zzaf() && ((zzge) zzn4).zzx.zzz().zzf()) {\n                         ((zzge) zzn4).zzx.zzat().zzj().zza(\"Turning off ad personalization due to account type\");\n                         zzdt zzj2 = zzdu.zzj();\n                         zzj2.zzb(str2);\n                         zzj2.zza(((zzge) zzn4).zzx.zzz().zzd());\n                         zzj2.zze(1L);\n                         zzdu zzaA2 = zzj2.zzaA();\n                         int i25 = 0;\n                         while (true) {\n                             if (i25 >= zzdiVar7.zzk()) {\n                                 zzdiVar7.zzn(zzaA2);\n                                 break;\n                             } else if (str2.equals(zzdiVar7.zzl(i25).zzc())) {\n                                 zzdiVar7.zzm(i25, zzaA2);\n                                 break;\n                             } else {\n                                 i25++;\n                             }\n                         }\n                     }\n                     zzdiVar7.zzt(Long.MAX_VALUE);\n                     zzdiVar7.zzv(Long.MIN_VALUE);\n                     for (int i26 = 0; i26 < zzdiVar7.zzc(); i26++) {\n                         zzdb zzd5 = zzdiVar7.zzd(i26);\n                         if (zzd5.zzf() < zzdiVar7.zzs()) {\n                             zzdiVar7.zzt(zzd5.zzf());\n                         }\n                         if (zzd5.zzf() > zzdiVar7.zzu()) {\n                             zzdiVar7.zzv(zzd5.zzf());\n                         }\n                     }\n                     zzdiVar7.zzac();\n                     zzdiVar7.zzZ();\n                     zzdiVar7.zzY(zzl().zzb(zzdiVar7.zzG(), zzdiVar7.zzb(), zzdiVar7.zzj(), Long.valueOf(zzdiVar7.zzs()), Long.valueOf(zzdiVar7.zzu())));\n                     if (((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzc().zzx(zzkcVar3.zza.zzA())) {\n                         try {\n                             Map hashMap = new HashMap();\n                             ArrayList arrayList2 = new ArrayList();\n                             SecureRandom zzf = ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzl().zzf();\n                             int i27 = 0;\n                             while (i27 < zzdiVar7.zzc()) {\n                                 zzda zzbu4 = zzdiVar7.zzd(i27).zzbu();\n                                 if (zzbu4.zzk().equals(\"_ep\")) {\n                                     zzn();\n                                     String str18 = (String) zzkf.zzA(zzbu4.zzaA(), \"_en\");\n                                     zzao zzaoVar = (zzao) hashMap.get(str18);\n                                     if (zzaoVar == null) {\n                                         zzaoVar = zzi().zzf(zzkcVar3.zza.zzA(), str18);\n                                         hashMap.put(str18, zzaoVar);\n                                     }\n                                     if (zzaoVar.zzi == null) {\n                                         if (zzaoVar.zzj.longValue() > 1) {\n                                             zzn();\n                                             zzkf.zzx(zzbu4, \"_sr\", zzaoVar.zzj);\n                                         }\n                                         Boolean bool = zzaoVar.zzk;\n                                         if (bool != null && bool.booleanValue()) {\n                                             zzn();\n                                             zzkf.zzx(zzbu4, \"_efs\", 1L);\n                                         }\n                                         arrayList2.add(zzbu4.zzaA());\n                                     }\n                                     zzdiVar7.zze(i27, zzbu4);\n                                     zzdiVar3 = zzdiVar7;\n                                     zzkcVar2 = zzkcVar3;\n                                     secureRandom = zzf;\n                                     map2 = hashMap;\n                                 } else {\n                                     zzfc zzf2 = zzf();\n                                     String zzA = zzkcVar3.zza.zzA();\n                                     String zza = zzf2.zza(zzA, \"measurement.account.time_zone_offset_minutes\");\n                                     if (!TextUtils.isEmpty(zza)) {\n                                         try {\n                                             parseLong = Long.parseLong(zza);\n                                         } catch (NumberFormatException e) {\n                                             ((zzge) zzf2).zzx.zzat().zze().zzc(\"Unable to parse timezone offset. appId\", zzei.zzl(zzA), e);\n                                         }\n                                         long zzab2 = ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzl().zzab(zzbu4.zzn(), parseLong);\n                                         zzdb zzaA3 = zzbu4.zzaA();\n                                         long j5 = parseLong;\n                                         Long l3 = 1L;\n                                         if (!TextUtils.isEmpty(\"_dbg\")) {\n                                             Iterator it2 = zzaA3.zza().iterator();\n                                             while (true) {\n                                                 if (!it2.hasNext()) {\n                                                     break;\n                                                 }\n                                                 zzdf zzdfVar = (zzdf) it2.next();\n                                                 Iterator it3 = it2;\n                                                 if (!\"_dbg\".equals(zzdfVar.zzb())) {\n                                                     it2 = it3;\n                                                 } else if (l3.equals(Long.valueOf(zzdfVar.zzf()))) {\n                                                     zzk = 1;\n                                                 }\n                                             }\n                                         }\n                                         zzk = zzf().zzk(zzkcVar3.zza.zzA(), zzbu4.zzk());\n                                         if (zzk > 0) {\n                                             ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zze().zzc(\"Sample rate must be positive. event, rate\", zzbu4.zzk(), Integer.valueOf(zzk));\n                                             arrayList2.add(zzbu4.zzaA());\n                                             zzdiVar7.zze(i27, zzbu4);\n                                         } else {\n                                             zzao zzaoVar2 = (zzao) hashMap.get(zzbu4.zzk());\n                                             if (zzaoVar2 == null && (zzaoVar2 = zzi().zzf(zzkcVar3.zza.zzA(), zzbu4.zzk())) == null) {\n                                                 ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzat().zze().zzc(\"Event being bundled has no eventAggregate. appId, eventName\", zzkcVar3.zza.zzA(), zzbu4.zzk());\n                                                 zzaoVar2 = new zzao(zzkcVar3.zza.zzA(), zzbu4.zzk(), 1L, 1L, 1L, zzbu4.zzn(), 0L, (Long) null, (Long) null, (Long) null, (Boolean) null);\n                                             }\n                                             zzn();\n                                             Long l4 = (Long) zzkf.zzA(zzbu4.zzaA(), \"_eid\");\n                                             Boolean valueOf2 = Boolean.valueOf(l4 != null);\n                                             if (zzk == 1) {\n                                                 arrayList2.add(zzbu4.zzaA());\n                                                 if (valueOf2.booleanValue() && (zzaoVar2.zzi != null || zzaoVar2.zzj != null || zzaoVar2.zzk != null)) {\n                                                     hashMap.put(zzbu4.zzk(), zzaoVar2.zzc((Long) null, (Long) null, (Boolean) null));\n                                                 }\n                                                 zzdiVar7.zze(i27, zzbu4);\n                                             } else {\n                                                 if (zzf.nextInt(zzk) == 0) {\n                                                     zzn();\n                                                     zzkcVar2 = zzkcVar3;\n                                                     secureRandom = zzf;\n                                                     Long valueOf3 = Long.valueOf(zzk);\n                                                     zzkf.zzx(zzbu4, \"_sr\", valueOf3);\n                                                     arrayList2.add(zzbu4.zzaA());\n                                                     if (valueOf2.booleanValue()) {\n                                                         zzaoVar2 = zzaoVar2.zzc((Long) null, valueOf3, (Boolean) null);\n                                                     }\n                                                     hashMap.put(zzbu4.zzk(), zzaoVar2.zzb(zzbu4.zzn(), zzab2));\n                                                     map2 = hashMap;\n                                                     zzdiVar3 = zzdiVar7;\n                                                 } else {\n                                                     zzkcVar2 = zzkcVar3;\n                                                     secureRandom = zzf;\n                                                     Long l5 = zzaoVar2.zzh;\n                                                     if (l5 != null) {\n                                                         zzab = l5.longValue();\n                                                         l = l4;\n                                                         map = hashMap;\n                                                         zzdiVar2 = zzdiVar7;\n                                                     } else {\n                                                         zzdiVar2 = zzdiVar7;\n                                                         l = l4;\n                                                         map = hashMap;\n                                                         zzab = ((zzkd) this).zzl.zzl().zzab(zzbu4.zzp(), j5);\n                                                     }\n                                                     if (zzab != zzab2) {\n                                                         zzn();\n                                                         zzkf.zzx(zzbu4, \"_efs\", 1L);\n                                                         zzn();\n                                                         Long valueOf4 = Long.valueOf(zzk);\n                                                         zzkf.zzx(zzbu4, \"_sr\", valueOf4);\n                                                         arrayList2.add(zzbu4.zzaA());\n                                                         if (valueOf2.booleanValue()) {\n                                                             zzaoVar2 = zzaoVar2.zzc((Long) null, valueOf4, true);\n                                                         }\n                                                         map2 = map;\n                                                         map2.put(zzbu4.zzk(), zzaoVar2.zzb(zzbu4.zzn(), zzab2));\n                                                     } else {\n                                                         map2 = map;\n                                                         if (valueOf2.booleanValue()) {\n                                                             map2.put(zzbu4.zzk(), zzaoVar2.zzc(l, (Long) null, (Boolean) null));\n                                                         }\n                                                     }\n                                                     zzdiVar3 = zzdiVar2;\n                                                 }\n                                                 zzdiVar3.zze(i27, zzbu4);\n                                             }\n                                         }\n                                         zzdiVar3 = zzdiVar7;\n                                         zzkcVar2 = zzkcVar3;\n                                         secureRandom = zzf;\n                                         map2 = hashMap;\n                                     }\n                                     parseLong = 0;\n                                     long zzab22 = ((zzkd) clsBZH1OEM6MPAI1F82).zzl.zzl().zzab(zzbu4.zzn(), parseLong);\n                                     zzdb zzaA32 = zzbu4.zzaA();\n                                     long j52 = parseLong;\n                                     Long l32 = 1L;\n                                     if (!TextUtils.isEmpty(\"_dbg\")) {\n                                     }\n                                     zzk = zzf().zzk(zzkcVar3.zza.zzA(), zzbu4.zzk());\n                                     if (zzk > 0) {\n                                     }\n                                     zzdiVar3 = zzdiVar7;\n                                     zzkcVar2 = zzkcVar3;\n                                     secureRandom = zzf;\n                                     map2 = hashMap;\n                                 }\n                                 i27++;\n                                 zzdiVar7 = zzdiVar3;\n                                 hashMap = map2;\n                                 zzkcVar3 = zzkcVar2;\n                                 clsBZH1OEM6MPAI1F82 = this;\n                                 zzf = secureRandom;\n                             }\n                             Map map3 = hashMap;\n                             zzdiVar = zzdiVar7;\n                             zzkc zzkcVar4 = zzkcVar3;\n                             if (arrayList2.size() < zzdiVar.zzc()) {\n                                 zzdiVar.zzh();\n                                 zzdiVar.zzg(arrayList2);\n                             }\n                             for (Map.Entry entry : map3.entrySet()) {\n                                 zzi().zzh((zzao) entry.getValue());\n                             }\n                             zzkcVar = zzkcVar4;\n                         } catch (Throwable th) {\n                             th = th;\n                             Throwable th2 = th;\n                             zzi().zzd();\n                             throw th2;\n                         }\n                     } else {\n                         zzdiVar = zzdiVar7;\n                         zzkcVar = zzkcVar3;\n                     }\n                     String zzA2 = zzkcVar.zza.zzA();\n                     zzg zzs2 = zzi().zzs(zzA2);\n                     if (zzs2 == null) {\n                         clsBZH1OEM6MPAI1F8 = this;\n                         ((zzkd) clsBZH1OEM6MPAI1F8).zzl.zzat().zzb().zzb(\"Bundling raw events w/o app info. appId\", zzei.zzl(zzkcVar.zza.zzA()));\n                     } else {\n                         clsBZH1OEM6MPAI1F8 = this;\n                         if (zzdiVar.zzc() > 0) {\n                             long zzr = zzs2.zzr();\n                             if (zzr != 0) {\n                                 zzdiVar.zzy(zzr);\n                             } else {\n                                 zzdiVar.zzz();\n                             }\n                             long zzp = zzs2.zzp();\n                             if (zzp != 0) {\n                                 zzr = zzp;\n                             }\n                             if (zzr != 0) {\n                                 zzdiVar.zzw(zzr);\n                             } else {\n                                 zzdiVar.zzx();\n                             }\n                             zzs2.zzN();\n                             zzdiVar.zzS((int) zzs2.zzI());\n                             zzs2.zzq(zzdiVar.zzs());\n                             zzs2.zzs(zzdiVar.zzu());\n                             String zzab3 = zzs2.zzab();\n                             if (zzab3 != null) {\n                                 zzdiVar.zzT(zzab3);\n                             } else {\n                                 zzdiVar.zzU();\n                             }\n                             zzi().zzt(zzs2);\n                         }\n                     }\n                     if (zzdiVar.zzc() > 0) {\n                         ((zzkd) clsBZH1OEM6MPAI1F8).zzl.zzas();\n                         zzcp zzb = zzf().zzb(zzkcVar.zza.zzA());\n                         try {\n                             try {\n                                 if (zzb != null && zzb.zza()) {\n                                     zzdiVar.zzad(zzb.zzb());\n                                     zzi = zzi();\n                                     zzaA = zzdiVar.zzaA();\n                                     zzi.zzg();\n                                     zzi.zzX();\n                                     Preconditions.checkNotNull(zzaA);\n                                     Preconditions.checkNotEmpty(zzaA.zzA());\n                                     Preconditions.checkState(zzaA.zzn());\n                                     zzi.zzy();\n                                     currentTimeMillis = ((zzge) zzi).zzx.zzax().currentTimeMillis();\n                                     zzo = zzaA.zzo();\n                                     ((zzge) zzi).zzx.zzc();\n                                     if (zzo >= currentTimeMillis - zzae.zzA()) {\n                                         long zzo2 = zzaA.zzo();\n                                         ((zzge) zzi).zzx.zzc();\n                                     }\n                                     ((zzge) zzi).zzx.zzat().zze().zzd(\"Storing bundle outside of the max uploading time span. appId, now, timestamp\", zzei.zzl(zzaA.zzA()), Long.valueOf(currentTimeMillis), Long.valueOf(zzaA.zzo()));\n                                     byte[] zzs3 = ((zzju) zzi).zza.zzn().zzs(zzaA.zzbp());\n                                     ((zzge) zzi).zzx.zzat().zzk().zzb(\"Saving bundle, size\", Integer.valueOf(zzs3.length));\n                                     contentValues = new ContentValues();\n                                     contentValues.put(\"app_id\", zzaA.zzA());\n                                     contentValues.put(\"bundle_end_timestamp\", Long.valueOf(zzaA.zzo()));\n                                     contentValues.put(\"data\", zzs3);\n                                     contentValues.put(\"has_realtime\", Integer.valueOf(i13));\n                                     if (zzaA.zzab()) {\n                                         contentValues.put(\"retry_count\", Integer.valueOf(zzaA.zzac()));\n                                     }\n                                     if (zzi.zze().insert(\"queue\", null, contentValues) == -1) {\n                                         ((zzge) zzi).zzx.zzat().zzb().zzb(\"Failed to insert bundle (got -1). appId\", zzei.zzl(zzaA.zzA()));\n                                     }\n                                 }\n                                 if (zzi.zze().insert(\"queue\", null, contentValues) == -1) {\n                                 }\n                             } catch (SQLiteException e2) {\n                                 ((zzge) zzi).zzx.zzat().zzb().zzc(\"Error storing bundle. appId\", zzei.zzl(zzaA.zzA()), e2);\n                             }\n                             byte[] zzs32 = ((zzju) zzi).zza.zzn().zzs(zzaA.zzbp());\n                             ((zzge) zzi).zzx.zzat().zzk().zzb(\"Saving bundle, size\", Integer.valueOf(zzs32.length));\n                             contentValues = new ContentValues();\n                             contentValues.put(\"app_id\", zzaA.zzA());\n                             contentValues.put(\"bundle_end_timestamp\", Long.valueOf(zzaA.zzo()));\n                             contentValues.put(\"data\", zzs32);\n                             contentValues.put(\"has_realtime\", Integer.valueOf(i13));\n                             if (zzaA.zzab()) {\n                             }\n                         } catch (IOException e3) {\n                             ((zzge) zzi).zzx.zzat().zzb().zzc(\"Data loss. Failed to serialize bundle. appId\", zzei.zzl(zzaA.zzA()), e3);\n                         }\n                         if (TextUtils.isEmpty(zzkcVar.zza.zzP())) {\n                             zzdiVar.zzad(-1L);\n                         } else {\n                             ((zzkd) clsBZH1OEM6MPAI1F8).zzl.zzat().zze().zzb(\"Did not find measurement config or missing version info. appId\", zzei.zzl(zzkcVar.zza.zzA()));\n                         }\n                         zzi = zzi();\n                         zzaA = zzdiVar.zzaA();\n                         zzi.zzg();\n                         zzi.zzX();\n                         Preconditions.checkNotNull(zzaA);\n                         Preconditions.checkNotEmpty(zzaA.zzA());\n                         Preconditions.checkState(zzaA.zzn());\n                         zzi.zzy();\n                         currentTimeMillis = ((zzge) zzi).zzx.zzax().currentTimeMillis();\n                         zzo = zzaA.zzo();\n                         ((zzge) zzi).zzx.zzc();\n                         if (zzo >= currentTimeMillis - zzae.zzA()) {\n                         }\n                         ((zzge) zzi).zzx.zzat().zze().zzd(\"Storing bundle outside of the max uploading time span. appId, now, timestamp\", zzei.zzl(zzaA.zzA()), Long.valueOf(currentTimeMillis), Long.valueOf(zzaA.zzo()));\n                     }\n                     zzai zzi2 = zzi();\n                     List list2 = zzkcVar.zzb;\n                     Preconditions.checkNotNull(list2);\n                     zzi2.zzg();\n                     zzi2.zzX();\n                     StringBuilder sb = new StringBuilder(\"rowid in (\");\n                     for (int i28 = 0; i28 < list2.size(); i28++) {\n                         if (i28 != 0) {\n                             sb.append(\",\");\n                         }\n                         sb.append(((Long) list2.get(i28)).longValue());\n                     }\n                     sb.append(\")\");\n                     int delete = zzi2.zze().delete(\"raw_events\", sb.toString(), null);\n                     if (delete != list2.size()) {\n                         ((zzge) zzi2).zzx.zzat().zzb().zzc(\"Deleted fewer rows from raw events table than expected\", Integer.valueOf(delete), Integer.valueOf(list2.size()));\n                     }\n                     zzai zzi3 = zzi();\n                     try {\n                         zzi3.zze().execSQL(\"delete from raw_events_metadata where app_id=? and metadata_fingerprint not in (select distinct metadata_fingerprint from raw_events where app_id=?)\", new String[]{zzA2, zzA2});\n                     } catch (SQLiteException e4) {\n                         ((zzge) zzi3).zzx.zzat().zzb().zzc(\"Failed to remove unused event metadata. appId\", zzei.zzl(zzA2), e4);\n                     }\n                     zzi().zzc();\n                     zzi().zzd();\n                     return true;\n                 }\n                 zzi().zzc();\n                 zzi().zzd();\n                 return false;\n             } catch (Throwable th3) {\n                 th = th3;\n                 Throwable th22 = th;\n                 zzi().zzd();\n                 throw th22;\n             }\n         } catch (Throwable th4) {\n             th = th4;\n             Throwable th222 = th;\n             zzi().zzd();\n             throw th222;\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                4583
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.162-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c56fab2e-e772-4147-9943-f105fbad77bf",
              "value": "r0 = e;\n      */\n         r0 = e;\n      */\n         r13 = true;\n      */\n         ((com.google.android.gms.measurement.internal.zzge) r8).zzx.zzat().zzb().zzc(\"Error pruning currencies. appId\", com.google.android.gms.measurement.internal.zzei.zzl(r10), r0);\n      */\n         if (r14.size() != 0) goto L176;\n      */\n         r17 = 1;\n      */\n         r0 = e;\n      */\n     \n     final void zzC(com.google.android.gms.measurement.internal.zzas r35, com.google.android.gms.measurement.internal.zzp r36) {\n         \n         throw new UnsupportedOperationException(\"Method not decompiled: com.aat.Cls50RZGJ6Z2L3QOU8.zzC(com.google.android.gms.measurement.internal.zzas, com.google.android.gms.measurement.internal.zzp):void\");\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                11230
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.212-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "661058d1-ecb3-4927-b023-96c77390ffdb",
              "value": "final void zzG(int i, Throwable th, byte[] bArr, String str) {\n         zzai zzi;\n         long longValue;\n         ((zzkd) this).zzl.zzau().zzg();\n         zzs();\n         if (bArr == null) {\n             try {\n                 bArr = new byte[0];\n             } finally {\n                 ((zzkd) this).zzs = false;\n                 zzak();\n             }\n         }\n         List<Long> list = ((zzkd) this).zzw;\n         ((zzkd) this).zzw = null;\n         if (i != 200) {\n             if (i == 204) {\n                 i = 204;\n             }\n             ((zzkd) this).zzl.zzat().zzk().zzc(\"Network upload failed. Will retry later. code, error\", Integer.valueOf(i), th);\n             ((zzkd) this).zzl.zzd().zzd.zzb(((zzkd) this).zzl.zzax().currentTimeMillis());\n             if (i != 503 || i == 429) {\n                 ((zzkd) this).zzl.zzd().zze.zzb(((zzkd) this).zzl.zzax().currentTimeMillis());\n             }\n             zzi().zzz(list);\n             zzaj();\n         }\n         if (th == null) {\n             try {\n                 ((zzkd) this).zzl.zzd().zzc.zzb(((zzkd) this).zzl.zzax().currentTimeMillis());\n                 ((zzkd) this).zzl.zzd().zzd.zzb(0L);\n                 zzaj();\n                 ((zzkd) this).zzl.zzat().zzk().zzc(\"Successful upload. Got network response. code, size\", Integer.valueOf(i), Integer.valueOf(bArr.length));\n                 zzi().zzb();\n                 try {\n                     for (Long l : list) {\n                         try {\n                             zzi = zzi();\n                             longValue = l.longValue();\n                             zzi.zzg();\n                             zzi.zzX();\n                         } catch (SQLiteException e) {\n                             List list2 = ((zzkd) this).zzx;\n                             if (list2 == null || !list2.contains(l)) {\n                                 throw e;\n                             }\n                         }\n                         try {\n                             if (zzi.zze().delete(\"queue\", \"rowid=?\", new String[]{String.valueOf(longValue)}) != 1) {\n                                 throw new SQLiteException(\"Deleted fewer rows from queue than expected\");\n                                 break;\n                             }\n                         } catch (SQLiteException e2) {\n                             ((zzge) zzi).zzx.zzat().zzb().zzb(\"Failed to delete a bundle in a queue table\", e2);\n                             throw e2;\n                             break;\n                         }\n                     }\n                     zzi().zzc();\n                     zzi().zzd();\n                     ((zzkd) this).zzx = null;\n                     if (zzh().zzb() && zzai()) {\n                         zzF();\n                     } else {\n                         ((zzkd) this).zzy = -1L;\n                         zzaj();\n                     }\n                     ((zzkd) this).zza = 0L;\n                 } catch (Throwable th2) {\n                     zzi().zzd();\n                     throw th2;\n                 }\n             } catch (SQLiteException e3) {\n                 ((zzkd) this).zzl.zzat().zzb().zzb(\"Database error while trying to delete uploaded bundles\", e3);\n                 ((zzkd) this).zza = ((zzkd) this).zzl.zzax().elapsedRealtime();\n                 ((zzkd) this).zzl.zzat().zzk().zzb(\"Disable upload, time\", Long.valueOf(((zzkd) this).zza));\n             }\n         }\n         ((zzkd) this).zzl.zzat().zzk().zzc(\"Network upload failed. Will retry later. code, error\", Integer.valueOf(i), th);\n         ((zzkd) this).zzl.zzd().zzd.zzb(((zzkd) this).zzl.zzax().currentTimeMillis());\n         if (i != 503) {\n         }\n         ((zzkd) this).zzl.zzd().zze.zzb(((zzkd) this).zzl.zzax().currentTimeMillis());\n         zzi().zzz(list);\n         zzaj();\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzkd.java",
              "file_line": [
                13712
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.345-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5731fe00-f166-444d-8abe-b36acaada292",
              "value": "private void saveWrite(Path path, long j, String str, byte[] bArr) {\n         verifyInsideTransaction();\n         ((SqlPersistenceStorageEngine) this).database.delete(\"writes\", \"id = ?\", new String[]{String.valueOf(j)});\n         if (bArr.length >= 262144) {\n             List splitBytes = SqlPersistenceStorageEngine.splitBytes(bArr, 262144);\n             for (int i = 0; i < splitBytes.size(); i++) {\n                 ContentValues contentValues = new ContentValues();\n                 contentValues.put(\"id\", Long.valueOf(j));\n                 contentValues.put(\"path\", SqlPersistenceStorageEngine.pathToKey(path));\n                 contentValues.put(\"type\", str);\n                 contentValues.put(\"part\", Integer.valueOf(i));\n                 contentValues.put(\"node\", (byte[]) splitBytes.get(i));\n                 ((SqlPersistenceStorageEngine) this).database.insertWithOnConflict(\"writes\", null, contentValues, 5);\n             }\n             return;\n         }\n         ContentValues contentValues2 = new ContentValues();\n         contentValues2.put(\"id\", Long.valueOf(j));\n         contentValues2.put(\"path\", SqlPersistenceStorageEngine.pathToKey(path));\n         contentValues2.put(\"type\", str);\n         contentValues2.put(\"part\", (Integer) null);\n         contentValues2.put(\"node\", bArr);\n         ((SqlPersistenceStorageEngine) this).database.insertWithOnConflict(\"writes\", null, contentValues2, 5);\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine.java",
              "file_line": [
                1838
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.443-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "eda1997e-9a60-485d-9ec8-17590b40cb52",
              "value": "public void deleteTrackedQuery(long j) {\n         verifyInsideTransaction();\n         String valueOf = String.valueOf(j);\n         ((SqlPersistenceStorageEngine) this).database.delete(\"trackedQueries\", \"id = ?\", new String[]{valueOf});\n         ((SqlPersistenceStorageEngine) this).database.delete(\"trackedKeys\", \"id = ?\", new String[]{valueOf});\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine.java",
              "file_line": [
                2452
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.491-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ad1b95ea-a901-425c-84b3-ff35487a1630",
              "value": "public void removeAllUserWrites() {\n         verifyInsideTransaction();\n         long currentTimeMillis = System.currentTimeMillis();\n         int delete = ((SqlPersistenceStorageEngine) this).database.delete(\"writes\", null, null);\n         long currentTimeMillis2 = System.currentTimeMillis() - currentTimeMillis;\n         if (((SqlPersistenceStorageEngine) this).logger.logsDebug()) {\n             ((SqlPersistenceStorageEngine) this).logger.debug(String.format(Locale.US, \"Deleted %d (all) write(s) in %dms\", Integer.valueOf(delete), Long.valueOf(currentTimeMillis2)), new Object[0]);\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine.java",
              "file_line": [
                3933
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.662-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "82ef7e8a-55b5-4c9a-b310-7193c7517abe",
              "value": "public void removeUserWrite(long j) {\n         verifyInsideTransaction();\n         long currentTimeMillis = System.currentTimeMillis();\n         int delete = ((SqlPersistenceStorageEngine) this).database.delete(\"writes\", \"id = ?\", new String[]{String.valueOf(j)});\n         long currentTimeMillis2 = System.currentTimeMillis() - currentTimeMillis;\n         if (((SqlPersistenceStorageEngine) this).logger.logsDebug()) {\n             ((SqlPersistenceStorageEngine) this).logger.debug(String.format(Locale.US, \"Deleted %d write(s) with writeId %d in %dms\", Integer.valueOf(delete), Long.valueOf(j), Long.valueOf(currentTimeMillis2)), new Object[0]);\n         }\n     }",
              "vulnerability_id": "6c0a30dc-6e80-4297-a6d8-6fd73884d25f",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/database/android/SqlPersistenceStorageEngine.java",
              "file_line": [
                4022
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.741-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "6be1aecd-878c-4496-91bb-ee06b6972a3d",
          "title": "Package Code Loading",
          "severity": "high",
          "translations": [
            {
              "description": "<p>Android Package Code Loading involves insecure practices in the dynamic loading of external or additional code within Android applications. Through a detailed analysis of the <b>Challenge 3</b> application&#39;s Smali code, specific methods like Context.createPackageContext() and ClassLoader.loadClass() were highlighted as potential entry points for security breaches. These methods, if not securely implemented, can allow unauthorized code execution within the app, as they enable the application to load and execute code from external or untrusted sources dynamically. This capability significantly increases the risk of malicious activities if an attacker gains the ability to influence what code is loaded.\nThe following snippet shows the insecure implementation</p>\n",
              "remediation": "<p>The assessment team recommends implementing the following remediation strategies:</p>\n<ul>\n<li>Secure Coding Practices: Ensure that dynamic code loading adheres to secure coding guidelines, avoiding methods that load code from external or unverified sources.</li>\n<li>Input Validation: Implement rigorous validation for any inputs affecting dynamically loaded code. Use whitelisting to allow only safe, intended inputs.</li>\n<li>Use of Safer APIs: Replace methods like Context.createPackageContext() and ClassLoader.loadClass() with alternatives that minimize security risks associated with external code execution.</li>\n</ul>\n",
              "impact": "<p>An attacker can exploit the Package Code Loading to execute unauthorized code within the application. This could compromise the app’s security, allowing the attacker to manipulate app behavior, access sensitive information, or introduce additional malicious functionality. The capability to dynamically load code could also enable persistent threats within the device, potentially affecting other applications and the operating system, leading to a comprehensive security breach.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El error “Package Code Loading” de Android implica prácticas no recomendadas en la carga dinámica de código externo o adicional dentro de las aplicaciones Android. A partir de un análisis detallado del código Smali de la aplicación <b>Challenge 3</b>, se identificaron métodos específicos —como Context.createPackageContext() y ClassLoader.loadClass()— como potenciales puntos de entrada para atacantes. Si estos métodos no se implementan de manera segura, podrían dar lugar a la ejecución no autorizada de código dentro de la aplicación, ya que le permiten a la aplicación cargar y ejecutar código de fuentes externas y no confiables de manera dinámica. Esta capacidad aumenta significativamente el riesgo de las actividades malintencionadas si un atacante obtiene la habilidad de alterar el código que se carga.\nEl siguiente fragmento muestra la implementación insegura:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda implementar las siguientes estrategias de remediación:</p>\n<ul>\n<li>Prácticas de codificación segura: asegúrese de que la carga dinámica de código cumpla con las pautas de codificación segura, y evite métodos que carguen código de fuentes externas o no verificadas.</li>\n<li>Validación de entrada: implemente una validación rigurosa para cualquier entrada que afecte el código cargado dinámicamente. Utilice listas blancas para permitir solo entradas seguras y previstas.</li>\n<li>Uso de API más seguras: reemplace métodos como Context.createPackageContext() y ClassLoader.loadClass() con alternativas que minimicen los riesgos de seguridad asociados con la ejecución de código externo.</li>\n</ul>\n",
              "impact": "<p>Un atacante puede aprovechar “Package Code Loading” para ejecutar código no autorizado dentro de la aplicación. Esto podría comprometer la seguridad de la aplicación y permitir al atacante manipular el comportamiento de la aplicación, acceder a información sensible o introducir funciones maliciosas adicionales. La capacidad de cargar código dinámicamente también podría permitir la existencia de amenazas persistentes dentro del dispositivo, lo que podría afectar a otras aplicaciones y al sistema operativo y provocar una violación de seguridad total.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "createPackageContext | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/create-package-context"
            },
            {
              "label": "Command Injection - Ostorlab: Mobile application security testing for android and ios",
              "url": "https://docs.ostorlab.co/kb/INSECURE_PACKAGE_CONTEXT/index.html"
            },
            {
              "label": "CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')",
              "url": "https://cwe.mitre.org/data/definitions/470.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0085"
          },
          "evidences": [
            {
              "id": "0fbb48a3-55f7-4b74-8223-db2b8582521c",
              "value": "public static int getLocalVersion(Context context, String str) {\n         try {\n             ClassLoader classLoader = context.getApplicationContext().getClassLoader();\n             StringBuilder sb = new StringBuilder(String.valueOf(str).length() + 61);\n             sb.append(\"com.google.android.gms.dynamite.descriptors.\");\n             sb.append(str);\n             sb.append(\".ModuleDescriptor\");\n             Class<?> loadClass = classLoader.loadClass(sb.toString());\n             Field declaredField = loadClass.getDeclaredField(\"MODULE_ID\");\n             Field declaredField2 = loadClass.getDeclaredField(\"MODULE_VERSION\");\n             if (!declaredField.get(null).equals(str)) {\n                 String valueOf = String.valueOf(declaredField.get(null));\n                 StringBuilder sb2 = new StringBuilder(String.valueOf(valueOf).length() + 51 + String.valueOf(str).length());\n                 sb2.append(\"Module descriptor id '\");\n                 sb2.append(valueOf);\n                 sb2.append(\"' didn't match expected id '\");\n                 sb2.append(str);\n                 sb2.append(\"'\");\n                 Log.e(\"DynamiteModule\", sb2.toString());\n                 return 0;\n             }\n             return declaredField2.getInt(null);\n         } catch (ClassNotFoundException unused) {\n             StringBuilder sb3 = new StringBuilder(String.valueOf(str).length() + 45);\n             sb3.append(\"Local module descriptor class for \");\n             sb3.append(str);\n             sb3.append(\" not found.\");\n             Log.w(\"DynamiteModule\", sb3.toString());\n             return 0;\n         } catch (Exception e) {\n             String valueOf2 = String.valueOf(e.getMessage());\n             Log.e(\"DynamiteModule\", valueOf2.length() != 0 ? \"Failed to load module descriptor class: \".concat(valueOf2) : new String(\"Failed to load module descriptor class: \"));\n             return 0;\n         }\n     }",
              "vulnerability_id": "6be1aecd-878c-4496-91bb-ee06b6972a3d",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/dynamite/DynamiteModule.java",
              "file_line": [
                184
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.250-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5d61dea9-0626-4418-bae8-eaa03dac2c6c",
              "value": "public static int zza(Context context, String str, boolean z) {\n         Class<?> loadClass;\n         Field declaredField;\n         Boolean bool;\n         try {\n             synchronized (DynamiteModule.class) {\n                 Boolean bool2 = DynamiteModule.zzif;\n                 if (bool2 == null) {\n                     try {\n                         loadClass = context.getApplicationContext().getClassLoader().loadClass(DynamiteModule.DynamiteLoaderClassLoader.class.getName());\n                         declaredField = loadClass.getDeclaredField(\"sClassLoader\");\n                     } catch (ClassNotFoundException | IllegalAccessException | NoSuchFieldException e) {\n                         String valueOf = String.valueOf(e);\n                         StringBuilder sb = new StringBuilder(String.valueOf(valueOf).length() + 30);\n                         sb.append(\"Failed to load module via V2: \");\n                         sb.append(valueOf);\n                         Log.w(\"DynamiteModule\", sb.toString());\n                         bool2 = Boolean.FALSE;\n                     }\n                     synchronized (loadClass) {\n                         ClassLoader classLoader = (ClassLoader) declaredField.get(null);\n                         if (classLoader != null) {\n                             if (classLoader == ClassLoader.getSystemClassLoader()) {\n                                 bool = Boolean.FALSE;\n                             } else {\n                                 try {\n                                     DynamiteModule.zza(classLoader);\n                                 } catch (DynamiteModule.LoadingException unused) {\n                                 }\n                                 bool = Boolean.TRUE;\n                             }\n                         } else if (\"com.google.android.gms\".equals(context.getApplicationContext().getPackageName())) {\n                             declaredField.set(null, ClassLoader.getSystemClassLoader());\n                             bool = Boolean.FALSE;\n                         } else {\n                             try {\n                                 int zzc = DynamiteModule.zzc(context, str, z);\n                                 String str2 = DynamiteModule.zzii;\n                                 if (str2 != null && !str2.isEmpty()) {\n                                     zzh zzhVar = new zzh(DynamiteModule.zzii, ClassLoader.getSystemClassLoader());\n                                     DynamiteModule.zza(zzhVar);\n                                     declaredField.set(null, zzhVar);\n                                     DynamiteModule.zzif = Boolean.TRUE;\n                                     return zzc;\n                                 }\n                                 return zzc;\n                             } catch (DynamiteModule.LoadingException unused2) {\n                                 declaredField.set(null, ClassLoader.getSystemClassLoader());\n                                 bool = Boolean.FALSE;\n                             }\n                         }\n                         bool2 = bool;\n                         DynamiteModule.zzif = bool2;\n                     }\n                 }\n                 if (bool2.booleanValue()) {\n                     try {\n                         return DynamiteModule.zzc(context, str, z);\n                     } catch (DynamiteModule.LoadingException e2) {\n                         String valueOf2 = String.valueOf(e2.getMessage());\n                         Log.w(\"DynamiteModule\", valueOf2.length() != 0 ? \"Failed to retrieve remote module version: \".concat(valueOf2) : new String(\"Failed to retrieve remote module version: \"));\n                         return 0;\n                     }\n                 }\n                 return DynamiteModule.zzb(context, str, z);\n             }\n         } catch (Throwable th) {\n             CrashUtils.addDynamiteErrorToDropBox(context, th);\n             throw th;\n         }\n     }",
              "vulnerability_id": "6be1aecd-878c-4496-91bb-ee06b6972a3d",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/dynamite/DynamiteModule.java",
              "file_line": [
                777
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.291-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9aa18668-2d74-4b85-a500-8e4b1b9c5291",
              "value": "private static zzi zzj(Context context) {\n         zzi zzjVar;\n         synchronized (DynamiteModule.class) {\n             zzi zziVar = DynamiteModule.zzig;\n             if (zziVar != null) {\n                 return zziVar;\n             }\n             if (GoogleApiAvailabilityLight.getInstance().isGooglePlayServicesAvailable(context) != 0) {\n                 return null;\n             }\n             try {\n                 IBinder iBinder = (IBinder) context.createPackageContext(\"com.google.android.gms\", 3).getClassLoader().loadClass(\"com.google.android.gms.chimera.container.DynamiteLoaderImpl\").newInstance();\n                 if (iBinder == null) {\n                     zzjVar = null;\n                 } else {\n                     zzi queryLocalInterface = iBinder.queryLocalInterface(\"com.google.android.gms.dynamite.IDynamiteLoader\");\n                     if (queryLocalInterface instanceof zzi) {\n                         zzjVar = queryLocalInterface;\n                     } else {\n                         zzjVar = new zzj(iBinder);\n                     }\n                 }\n                 if (zzjVar != null) {\n                     DynamiteModule.zzig = zzjVar;\n                     return zzjVar;\n                 }\n             } catch (Exception e) {\n                 String valueOf = String.valueOf(e.getMessage());\n                 Log.e(\"DynamiteModule\", valueOf.length() != 0 ? \"Failed to load IDynamiteLoader from GmsCore: \".concat(valueOf) : new String(\"Failed to load IDynamiteLoader from GmsCore: \"));\n             }\n             return null;\n         }\n     }",
              "vulnerability_id": "6be1aecd-878c-4496-91bb-ee06b6972a3d",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/dynamite/DynamiteModule.java",
              "file_line": [
                2206
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.331-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "24b38d51-3005-4f22-83bc-c9211ea26e2e",
          "title": "External Result Receiver",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The vulnerability known as &quot;External Result Receiver&quot; in Android involves a significant security risk where exported components improperly handle ResultReceiver objects passed via intents. This issue allows external entities to send intents with ResultReceiver objects to the <b>Challenge 3</b> application, which could then be manipulated to execute unintended actions or retrieve sensitive information. The core vulnerability arises from the application&#39;s exported components, which do not adequately validate or restrict the incoming ResultReceiver objects, potentially leading to unauthorized access or control over the application&#39;s internal states and functionalities. This vulnerability underscores the need for strict validation and limitation of exported components in handling intent-based communications. \nThe following code snippet shows the insecure implementation</p>\n",
              "remediation": "<p>The assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Restrict Component Exportation: Modify the application's manifest to ensure that components intended to receive ResultReceiver objects are not exported unless absolutely necessary. Use the android:exported=false attribute to prevent unintended external access.\n</li>\n<li>Implement Intent Validation: Enhance the validation process for incoming intents within the application. Verify any ResultReceiver received through intents to ensure it originates from a trusted source, and confirm that its usage aligns with secure and intended operational parameters.</li>\n</ul>\n",
              "impact": "<p>An attacker can exploit the &quot;External Result Receiver&quot; vulnerability to execute unintended actions within the application or access sensitive information by manipulating ResultReceiver objects sent via intents. This could lead to unauthorized actions being performed, such as altering application data or behavior, which might compromise the app’s functionality and user data security. The ability to intercept and modify these communications also raises concerns about the integrity and confidentiality of the data processed by the application, potentially leading to further security breaches within the system.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>La vulnerabilidad conocida como &quot;External Result Receiver&quot; en Android implica un riesgo de seguridad significativo, ya que los componentes importados controlan inadecuadamente los objetos ResultReceiver que se envían a través de las intenciones. Este problema permite que entidades externas envíen intenciones con objetos ResultReceiver a la aplicación <b>Challenge 3</b>, que luego podrían manipularse para llevar a cabo acciones no deseadas o recuperar información sensible. La vulnerabilidad surge de los componentes exportados de la aplicación, que no validan o limitan adecuadamente los objetos ResultReceiver entrantes. Esto podría facilitar el acceso no autorizado y la pérdida de control de los estados y funcionamientos internos de la aplicación. Esta vulnerabilidad resalta la necesidad de una validación y limitación estrictas de los componentes exportados en la comunicación basada en intenciones.\nEl siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Restringir la exportación de componentes: modifique el manifiesto de la aplicación para garantizar que los componentes destinados a recibir objetos ResultReceiver no se exporten a menos que sea absolutamente necesario. Utilice el atributo android:exported=false para evitar el acceso externo no deseado.\n</li>\n<li>Implementar la validación de intenciones: mejore el proceso de validación de intenciones entrantes dentro de la aplicación. Verifique cualquier ResultReceiver recibido a través de intenciones para asegurarse de que provenga de una fuente confiable y confirmar que su uso se alinea con los parámetros operativos seguros previstos.</li>\n</ul>\n",
              "impact": "<p>Un atacante puede aprovechar la vulnerabilidad &quot;External Result Receiver&quot; para llevar a cabo acciones no deseadas dentro de la aplicación o acceder a información sensible manipulando objetos ResultReceiver enviados mediante intenciones. Esto podría dar lugar a que se realicen acciones no autorizadas, como alterar los datos o el comportamiento de la aplicación, y podría comprometer la funcionalidad de la aplicación y la seguridad de los datos de los usuarios. La capacidad de interceptar y modificar estas comunicaciones pone en riesgo la integridad y confidencialidad de los datos procesados por la aplicación y puede generar más violaciones de seguridad dentro del sistema.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "ResultReceiver | Android Developers",
              "url": "https://developer.android.com/reference/android/os/ResultReceiver#send(int,%20android.os.Bundle)"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0084"
          },
          "evidences": [
            {
              "id": "8aa03315-800f-485f-a782-4685548e645a",
              "value": "static ComponentName getCallingActivity(Intent intent) {\n         ComponentName componentName = (ComponentName) intent.getParcelableExtra(\"androidx.core.app.EXTRA_CALLING_ACTIVITY\");\n         return componentName == null ? (ComponentName) intent.getParcelableExtra(\"android.support.v4.app.EXTRA_CALLING_ACTIVITY\") : componentName;\n     }",
              "vulnerability_id": "24b38d51-3005-4f22-83bc-c9211ea26e2e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat.java",
              "file_line": [
                204
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.875-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5aeb1684-49b1-4628-b6cb-de86a2e0a1c9",
              "value": "public Uri getStream(int i) {\n         if (((ShareCompat.IntentReader) this).mStreams == null && isMultipleShare()) {\n             ((ShareCompat.IntentReader) this).mStreams = ((ShareCompat.IntentReader) this).mIntent.getParcelableArrayListExtra(\"android.intent.extra.STREAM\");\n         }\n         ArrayList arrayList = ((ShareCompat.IntentReader) this).mStreams;\n         if (arrayList != null) {\n             return (Uri) arrayList.get(i);\n         }\n         if (i == 0) {\n             return (Uri) ((ShareCompat.IntentReader) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n         }\n         throw new IndexOutOfBoundsException(\"Stream items available: \" + getStreamCount() + \" index requested: \" + i);\n     }",
              "vulnerability_id": "24b38d51-3005-4f22-83bc-c9211ea26e2e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat$IntentReader.java",
              "file_line": [
                574
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.844-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4bfdae82-e8db-4b63-9bb1-8b4ba886f31a",
              "value": "public static Uri getReferrer(Activity activity) {\n         if (Build.VERSION.SDK_INT >= 22) {\n             return activity.getReferrer();\n         }\n         Intent intent = activity.getIntent();\n         Uri uri = (Uri) intent.getParcelableExtra(\"android.intent.extra.REFERRER\");\n         if (uri != null) {\n             return uri;\n         }\n         String stringExtra = intent.getStringExtra(\"android.intent.extra.REFERRER_NAME\");\n         if (stringExtra != null) {\n             return Uri.parse(stringExtra);\n         }\n         return null;\n     }",
              "vulnerability_id": "24b38d51-3005-4f22-83bc-c9211ea26e2e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ActivityCompat.java",
              "file_line": [
                112
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.703-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5ffacd21-967c-4b1f-954c-27cb98aacefc",
              "value": "public ShareCompat.IntentBuilder addStream(Uri uri) {\n         Uri uri2 = (Uri) ((ShareCompat.IntentBuilder) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n         ArrayList arrayList = ((ShareCompat.IntentBuilder) this).mStreams;\n         if (arrayList == null && uri2 == null) {\n             return setStream(uri);\n         }\n         if (arrayList == null) {\n             ((ShareCompat.IntentBuilder) this).mStreams = new ArrayList();\n         }\n         if (uri2 != null) {\n             ((ShareCompat.IntentBuilder) this).mIntent.removeExtra(\"android.intent.extra.STREAM\");\n             ((ShareCompat.IntentBuilder) this).mStreams.add(uri2);\n         }\n         ((ShareCompat.IntentBuilder) this).mStreams.add(uri);\n         return this;\n     }",
              "vulnerability_id": "24b38d51-3005-4f22-83bc-c9211ea26e2e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat$IntentBuilder.java",
              "file_line": [
                389
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.742-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3e7e35c2-a788-48de-afbe-e573859fc2e3",
              "value": "public Uri getStream() {\n         return (Uri) ((ShareCompat.IntentReader) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n     }",
              "vulnerability_id": "24b38d51-3005-4f22-83bc-c9211ea26e2e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat$IntentReader.java",
              "file_line": [
                519
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.773-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "27f15559-f9de-419b-ad74-f93d6330465c",
              "value": "static boolean handlePerformPrivateCommand(String str, Bundle bundle, InputConnectionCompat.OnCommitContentListener onCommitContentListener) {\n         boolean z;\n         ResultReceiver resultReceiver;\n         ?? r0 = 0;\n         r0 = 0;\n         if (bundle == null) {\n             return false;\n         }\n         if (TextUtils.equals(\"androidx.core.view.inputmethod.InputConnectionCompat.COMMIT_CONTENT\", str)) {\n             z = false;\n         } else if (!TextUtils.equals(\"android.support.v13.view.inputmethod.InputConnectionCompat.COMMIT_CONTENT\", str)) {\n             return false;\n         } else {\n             z = true;\n         }\n         try {\n             resultReceiver = (ResultReceiver) bundle.getParcelable(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_RESULT_RECEIVER\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_RESULT_RECEIVER\");\n             try {\n                 Uri uri = (Uri) bundle.getParcelable(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_URI\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_URI\");\n                 ClipDescription clipDescription = (ClipDescription) bundle.getParcelable(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_DESCRIPTION\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_DESCRIPTION\");\n                 Uri uri2 = (Uri) bundle.getParcelable(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_LINK_URI\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_LINK_URI\");\n                 int i = bundle.getInt(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_FLAGS\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_FLAGS\");\n                 Bundle bundle2 = (Bundle) bundle.getParcelable(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_OPTS\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_OPTS\");\n                 if (uri != null && clipDescription != null) {\n                     r0 = onCommitContentListener.onCommitContent(new InputContentInfoCompat(uri, clipDescription, uri2), i, bundle2);\n                 }\n                 if (resultReceiver != 0) {\n                     resultReceiver.send(r0, null);\n                 }\n                 return r0;\n             } catch (Throwable th) {\n                 th = th;\n                 if (resultReceiver != 0) {\n                     resultReceiver.send(0, null);\n                 }\n                 throw th;\n             }\n         } catch (Throwable th2) {\n             th = th2;\n             resultReceiver = 0;\n         }\n     }",
              "vulnerability_id": "24b38d51-3005-4f22-83bc-c9211ea26e2e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/view/inputmethod/InputConnectionCompat.java",
              "file_line": [
                496
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.943-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0ac540b1-9e38-4f21-80e6-75c9bf54540d",
              "value": "public static NetworkInfo getNetworkInfoFromBroadcast(ConnectivityManager connectivityManager, Intent intent) {\n         NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(\"networkInfo\");\n         if (networkInfo != null) {\n             return connectivityManager.getNetworkInfo(networkInfo.getType());\n         }\n         return null;\n     }",
              "vulnerability_id": "24b38d51-3005-4f22-83bc-c9211ea26e2e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/net/ConnectivityManagerCompat.java",
              "file_line": [
                38
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.902-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "f10b0ae2-6da5-4871-acda-97c69240a162",
          "title": "Content Provider Leak",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Challenge 3</b> implements a Content Provider that may allow unauthorized access or data manipulation. Content Providers enable structured data sharing between applications, but if not properly configured, they can expose sensitive data or allow unintended modifications.</p>\n<p>Improper permission handling, insecure URI grants, or unintended data exposure could lead to unauthorized access, affecting both data confidentiality and integrity. This issue may be further exploited if the application lacks proper validation when processing external requests.</p>\n",
              "remediation": "<p>The assessment team recommends ensuring that Content Providers are not unintentionally exposed by explicitly setting android:exported=&quot;false&quot; in the application&#39;s manifest for components that should not be accessed externally. If external access is required, appropriate permissions must be enforced using android:permission, android:readPermission, and android:writePermission.</p>\n<p>Additionally, developers should validate and sanitize all incoming data to prevent unauthorized access or modifications. When granting URI permissions, the use of FLAG_GRANT_READ_URI_PERMISSION and FLAG_GRANT_WRITE_URI_PERMISSION should be restricted to trusted applications. Finally, avoid reflecting attacker-controlled data in result intents, as this could be leveraged to manipulate application behavior.</p>\n",
              "impact": "<p>An attacker could exploit this issue to:</p>\n<ul>\n<li>Access sensitive data stored in the Content Provider, potentially exposing confidential user information.</li>\n<li>Modify or delete records, impacting data integrity and application functionality.</li>\n<li>Gain unauthorized privileges by exploiting weak URI permissions or permission misconfigurations.</li>\n<li>Manipulate application behavior, potentially leading to unintended actions or privilege escalation.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Challenge 3</b> implementa un Proveedor de contenido que puede permitir el acceso no autorizado o la manipulación de datos. Los proveedores de contenido permiten compartir datos estructurados entre aplicaciones, pero si no se configuran correctamente, pueden exponer datos confidenciales o permitir modificaciones no deseadas.</p>\n<p>La gestión inadecuada de permisos, las concesiones de URI inseguras o la exposición no intencionada de los datos podrían provocar un acceso no autorizado, lo que afectaría tanto a la confidencialidad como a la integridad de los datos. Este problema puede explotarse aún más si la aplicación carece de una validación adecuada al procesar solicitudes externas.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda garantizar que los proveedores de contenido no queden expuestos involuntariamente configurando explícitamente android:exported=&quot;false&quot; en el manifiesto de la aplicación para los componentes a los que no se debe acceder externamente. Si se requiere acceso externo, se deben aplicar los permisos adecuados mediante android:permission, android:readPermission y android:writePermission.</p>\n<p>Además, los desarrolladores deben validar y desinfectar todos los datos entrantes para evitar modificaciones o accesos no autorizados. Al otorgar permisos URI, el uso de FLAG_GRANT_READ_URI_PERMISSION y FLAG_GRANT_WRITE_URI_PERMISSION debe restringirse a aplicaciones confiables. Por último, evite reflejar datos controlados por el atacante en los resultados, ya que esto podría aprovecharse para manipular el comportamiento de la aplicación.</p>\n",
              "impact": "<p>Un atacante podría aprovechar este problema para:</p>\n<ul>\n<li>Acceder a datos confidenciales almacenados en el Proveedor de contenido, exponiendo potencialmente información confidencial del usuario.</li>\n<li>Modificar o eliminar registros, lo que afecta la integridad de los datos y la funcionalidad de la aplicación.</li>\n<li>Obtenga privilegios no autorizados explotando permisos de URI débiles o configuraciones incorrectas de permisos.</li>\n<li>Manipular el comportamiento de las aplicaciones, lo que podría provocar acciones no deseadas o una escalada de privilegios.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#content-providers"
            },
            {
              "label": "Getting a Result from an Activity | Android Developers",
              "url": "https://developer.android.com/training/basics/intents/result?hl=es-419"
            },
            {
              "label": "Content Provider Basics | Android Developers",
              "url": "https://developer.android.com/guide/topics/providers/content-provider-basics?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0064"
          },
          "evidences": [
            {
              "id": "c78b9b31-b31d-4f25-be01-6adaa3101c38",
              "value": "protected void onActivityResult(int i, int i2, Intent intent) {\n         super.onActivityResult(i, i2, intent);\n         if (i == 1) {\n             boolean booleanExtra = getIntent().getBooleanExtra(\"notify_manager\", true);\n             ((GoogleApiActivity) this).zabp = 0;\n             setResult(i2, intent);\n             if (booleanExtra) {\n                 GoogleApiManager zab = GoogleApiManager.zab(this);\n                 if (i2 == -1) {\n                     zab.zao();\n                 } else if (i2 == 0) {\n                     zab.zaa(new ConnectionResult(13, (PendingIntent) null), getIntent().getIntExtra(\"failing_client_id\", -1));\n                 }\n             }\n         } else if (i == 2) {\n             ((GoogleApiActivity) this).zabp = 0;\n             setResult(i2, intent);\n         }\n         finish();\n     }",
              "vulnerability_id": "f10b0ae2-6da5-4871-acda-97c69240a162",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/common/api/GoogleApiActivity.java",
              "file_line": [
                105
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.172-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "d26fb052-09cd-4f53-b731-a6bf9d3125a1",
          "title": "Android Start Internal Components",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Challenge 3</b> may improperly start internal components (activities or services) via implicit intents, potentially exposing sensitive functionality to unauthorized applications.</p>\n<p>Android applications often use methods like startActivity(), startActivityForResult(), and startService() to launch internal components. If these methods handle unvalidated intents, an attacker could craft a malicious intent to trigger unintended behaviors, interact with private components, or manipulate application logic.</p>\n<p>Additionally, if getParcelableExtra() is used without strict validation, an attacker could inject a malformed or unauthorized Parcelable object, potentially leading to unintended data processing or security risks.</p>\n",
              "remediation": "<p>The assessment team recommends the following mitigations to reduce the risks associated with insecure component invocation:</p>\n<ul>\n<li>Use explicit intents whenever possible: Restrict inter-component communication to explicitly defined targets to prevent unintended access by other applications.</li>\n<li>Validate all incoming intents: Ensure that every received intent is checked for its origin, expected parameters, and content integrity before processing.</li>\n<li>Restrict exported components: In the AndroidManifest.xml file, set android:exported=\"false\" for components that do not need to be accessed by external applications.</li>\n<li>Apply permission-based access control: If an internal component must be accessible externally, enforce strict access control via custom permissions (android:permission) to limit who can interact with it.</li>\n<li>Sanitize getParcelableExtra() inputs: Ensure that only expected Parcelable objects are processed, rejecting unexpected or malformed inputs.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit this issue to:</p>\n<ul>\n<li>Trigger unintended application behavior: If an internal component (such as an activity or service) is started improperly, it might perform unintended actions, such as navigating to a restricted screen or executing a function that was meant to be internal.</li>\n<li>Access sensitive data through exposed components: If an internal activity or service is unintentionally accessible, an attacker may extract sensitive information by interacting with it in ways not originally intended by the developers.</li>\n<li>Manipulate inter-component communication: If the application relies on intents to exchange data between components, an attacker might craft a malicious intent to manipulate this communication, leading to incorrect processing of user data or system functions.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Challenge 3</b> puede iniciar incorrectamente componentes internos (actividades o servicios) a través de intenciones implícitas, exponiendo potencialmente funcionalidades confidenciales a aplicaciones no autorizadas.</p>\n<p>Las aplicaciones de Android suelen utilizar métodos como startActivity(), startActivityForResult() y startService() para iniciar componentes internos. Si estos métodos manejan intenciones no validadas, un atacante podría crear una intención maliciosa para desencadenar comportamientos no deseados, interactuar con componentes privados o manipular la lógica de la aplicación.</p>\n<p>Además, si se utiliza getParcelableExtra() sin una validación estricta, un atacante podría inyectar un objeto Parcelable con formato incorrecto o no autorizado, lo que podría provocar un procesamiento de datos no deseado o riesgos de seguridad.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes mitigaciones para reducir los riesgos asociados con la invocación de componentes inseguros:</p>\n<ul>\n<li>Utilice intenciones explícitas siempre que sea posible: restrinja la comunicación entre componentes a objetivos definidos explícitamente para evitar el acceso no deseado de otras aplicaciones.</li>\n<li>Validar todos los intents entrantes: asegúrese de que se verifique el origen, los parámetros esperados y la integridad del contenido de cada intent recibido antes de procesarlo.</li>\n<li>Restringir los componentes exportados: en el archivo AndroidManifest.xml, configure android:exported=\"false\" para los componentes a los que no es necesario acceder mediante aplicaciones externas.</li>\n<li>Aplique control de acceso basado en permisos: si un componente interno debe ser accesible externamente, aplique un control de acceso estricto a través de permisos personalizados (android:permiso) para limitar quién puede interactuar con él.</li>\n<li>Desinfectar las entradas getParcelableExtra(): asegúrese de que solo se procesen los objetos Parcelable esperados, rechazando las entradas inesperadas o con formato incorrecto.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar este problema para:</p>\n<ul>\n<li>Desencadenar un comportamiento no deseado de la aplicación: si un componente interno (como una actividad o servicio) se inicia incorrectamente, podría realizar acciones no deseadas, como navegar a una pantalla restringida o ejecutar una función que estaba destinada a ser interna.</li>\n<li>Acceder a datos confidenciales a través de componentes expuestos: si se puede acceder involuntariamente a una actividad o servicio interno, un atacante puede extraer información confidencial interactuando con ella de maneras no previstas originalmente por los desarrolladores.</li>\n<li>Manipular la comunicación entre componentes: si la aplicación se basa en intentos de intercambiar datos entre componentes, un atacante podría idear una intención maliciosa para manipular esta comunicación, lo que llevaría a un procesamiento incorrecto de los datos del usuario o de las funciones del sistema.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#intents"
            },
            {
              "label": "Intent Redirection | Security | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/intent-redirection?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "729de444-54a3-442b-ac3a-f1a801940e8a",
              "value": "public static void startActivityForResult(Activity activity, Intent intent, int i, Bundle bundle) {\n         if (Build.VERSION.SDK_INT >= 16) {\n             activity.startActivityForResult(intent, i, bundle);\n         } else {\n             activity.startActivityForResult(intent, i);\n         }\n     }",
              "vulnerability_id": "d26fb052-09cd-4f53-b731-a6bf9d3125a1",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ActivityCompat.java",
              "file_line": [
                437
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.818-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1373b627-c0de-4e5e-870a-4c7f2f15266a",
              "value": "public void startChooser() {\n         ((ShareCompat.IntentBuilder) this).mContext.startActivity(createChooserIntent());\n     }",
              "vulnerability_id": "d26fb052-09cd-4f53-b731-a6bf9d3125a1",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat$IntentBuilder.java",
              "file_line": [
                834
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.843-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "4fb6cd88-fe2f-478f-8c12-4c609218ba73",
          "title": "Os Command Injection",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The &quot;Android OS Command Injection&quot; vulnerability was identified in the <b>Challenge 3</b> Android applications where specific methods that execute operating system commands are used insecurely. These methods, found in the decompiled application code, include Runtime.exec(), ProcessBuilder.command(), and similar functions in the Os class. When these functions are exposed to external inputs without proper validation and sanitization, they can be exploited to execute arbitrary system commands. This can lead to unauthorized actions, data theft, or manipulation of the operating system, posing a high security risk.\nThe following code snippet shows the insecure implementation.</p>\n",
              "remediation": "<p>The assessment team recommends the following:</p>\n<ul>\n<li>Validate and Sanitize Inputs: Ensure all inputs that could influence OS command execution are rigorously validated and sanitized to prevent malicious data from triggering unintended command execution.\n</li>\n<li>Use Secure Methods: Avoid using methods like Runtime.exec() or ProcessBuilder.command() directly with user-controlled inputs. Where possible, use higher-level APIs that abstract these details and handle security more robustly.\n</li>\n<li>Implement Least Privilege Principle: Restrict the permissions of the application runtime environment to the minimum necessary. This limits the impact of any potential command execution.</li>\n</ul>\n",
              "impact": "<p>An attacker can execute arbitrary commands on the device&#39;s operating system, potentially gaining unauthorized access to the system&#39;s resources and sensitive data. This could lead to a range of impacts, including data theft, installation of malicious software, or manipulation of system functionalities.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>Se identificó la vulnerabilidad &quot;Android OS Command Injection&quot; en las aplicaciones de Android de <b>Challenge 3</b> en las que se utilizan, de manera insegura, métodos específicos que ejecutan comandos del sistema operativo. Estos métodos, hallados en el código decompilado de la aplicción, incluyen Runtime.exec(), ProcessBuilder.command() y otras funciones similares en la clase de SO. Cuando estás funciones son expuestas a entredas externas sin la validación y desinfección apropiadas, se las puede explotar para ejectuar comandos de sistema arbitrarios. Esto puede producir acciones no autorizadas, robo de información, o manipulación del sistema operativo, lo cual implica un riesgo algo.\nEl siguiente fragmento de código muestra la implementación no segura.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda lo siguiente:</p>\n<ul>\n<li>Validar y desinfectar entradas: asegúrese de que todas las entradas que\npodrían influir en la ejecución de comandos del sistema operativo se validen y\ndesinfecten rigurosamente para evitar que datos malintencionados ejecuten\ncomandos no deseados.\n</li>\n<li>Utilizar métodos seguros: evite el uso directo de métodos como Runtime.exec()\no ProcessBuilder.command() con entradas controladas por el usuario. Siempre que\nsea posible, utilice API de nivel superior que abstraigan estos detalles y\nmanejen la seguridad de manera más sólida.\n</li>\n<li>Implementar el principio de mínimo privilegio: mantenga los permisos del\nentorno de ejecución de la aplicación al mínimo necesario. Esto limita el\nimpacto de cualquier posible ejecución de comando.</li>\n</ul>\n",
              "impact": "<p>Un atacante puede ejecutar comandos arbitrarios en el sistema operativo del dispositivo, lo cual podría permitirle obtener acceso no autorizado a los recursos y datos confidenciales del sistema. Esto podría tener una gran variedad de consecuencias, incluido el robo de datos, la instalación de software malintencionado o la manipulación de las funcionalidades del sistema.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Command Injection - Ostorlab: Mobile application security testing for android and ios",
              "url": "https://docs.ostorlab.co/kb/APK_INSECURE_EXEC_CMD/index.html"
            },
            {
              "label": "Command injection in Java - OWASP",
              "url": "https://wiki.owasp.org/index.php/Command_injection_in_Java"
            },
            {
              "label": "Runtime - Android Developers",
              "url": "https://developer.android.com/reference/kotlin/java/lang/Runtime"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0083"
          },
          "evidences": [
            {
              "id": "b4a30498-f5ba-4e7d-8879-1210ae9f30f8",
              "value": "private static String[] mountReader() {\n         InputStream inputStream;\n         String str;\n         try {\n             inputStream = Runtime.getRuntime().exec(\"mount\").getInputStream();\n         } catch (IOException e) {\n             e.printStackTrace();\n             inputStream = null;\n         }\n         if (inputStream == null) {\n             return null;\n         }\n         try {\n             str = new Scanner(inputStream).useDelimiter(\"\\\\A\").next();\n         } catch (NoSuchElementException e2) {\n             e2.printStackTrace();\n             str = \"\";\n         }\n         return str.split(\"\\n\");\n     }",
              "vulnerability_id": "4fb6cd88-fe2f-478f-8c12-4c609218ba73",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/just/mobile/sec/challenge3/RootUtil.java",
              "file_line": [
                724
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.470-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2a45dcf4-3824-471e-b77c-6938bf50e1b4",
              "value": "private static String[] propsReader() {\n         InputStream inputStream;\n         String str;\n         try {\n             inputStream = Runtime.getRuntime().exec(\"getprop\").getInputStream();\n         } catch (IOException e) {\n             e.printStackTrace();\n             inputStream = null;\n         }\n         try {\n             str = new Scanner(inputStream).useDelimiter(\"\\\\A\").next();\n         } catch (NoSuchElementException unused) {\n             str = \"\";\n         }\n         return str.split(\"\\n\");\n     }",
              "vulnerability_id": "4fb6cd88-fe2f-478f-8c12-4c609218ba73",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/just/mobile/sec/challenge3/RootUtil.java",
              "file_line": [
                800
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.507-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "367d4376-65b2-4f89-aa39-e6fe0ac7185d",
          "title": "Arbitrary File Theft",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Challenge 3</b> may expose sensitive files through improper use of the external cache directory (externalCacheDir).</p>\n<p>Android applications typically use externalCacheDir to temporarily store data, such as images or documents retrieved from external sources (e.g., camera, file manager). These actions are triggered using implicit intents via startActivityForResult(), which means the application waits for the external app (e.g., camera, file manager) to respond with a URI pointing to the requested file along with a status code.</p>\n<p>If the implementation of onActivityResult() does not properly validate received intents, the application may accept and process intents from any app. Furthermore, if the URI is not validated correctly, the application may blindly trust attacker-supplied URIs. A malicious application can exploit this behavior by injecting a manipulated intent targeting the victim application&#39;s internal files, causing <b>Challenge 3</b> to buffer its own internal files (such as authentication tokens or user data) into externalCacheDir, effectively exposing them to unauthorized access.</p>\n<p>Since externalCacheDir is stored in external storage (/storage/emulated/0/Android/data/<b>Challenge 3</b>/cache), it is publicly accessible to any application with READ_EXTERNAL_STORAGE permissions.</p>\n",
              "remediation": "<p>The assessment team recommends the following mitigations to prevent unauthorized access to private files through external cache storage:</p>\n<ul>\n<li>Use internal storage (getCacheDir()) instead of externalCacheDir: Store sensitive temporary files in internal storage, which is private to the application.</li>\n<li>Enforce strict validation of intent data: Ensure that incoming intents (e.g., from startActivityForResult()) are properly validated and restricted to prevent unauthorized file manipulations.</li>\n<li>Implement Scoped Storage: If external storage must be used, follow Scoped Storage best practices to limit file access to the application’s own directory and prevent exposure to third-party apps.</li>\n<li>Regularly clear externalCacheDir: Automatically delete temporary files in externalCacheDir once they are no longer needed to minimize the exposure window.</li>\n<li>Restrict storage permissions: Avoid requesting READ_EXTERNAL_STORAGE or WRITE_EXTERNAL_STORAGE unless absolutely necessary.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit this vulnerability to:</p>\n<ul>\n<li>Access sensitive application data: Private files, including authentication tokens, session cookies, or user-generated content, may be exposed if stored temporarily in externalCacheDir.</li>\n<li>Extract internal configuration files: If the application unintentionally buffers internal files in external storage, an attacker could retrieve them and analyze them for further exploitation.</li>\n<li>Bypass Android’s storage security model: This technique allows an attacker to indirectly access files stored in the app's private directory (/data/user/0/<b>Challenge 3</b>), circumventing direct access restrictions.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Challenge 3</b> puede exponer archivos confidenciales mediante el uso inadecuado del directorio de caché externo (externalCacheDir).</p>\n<p>Las aplicaciones de Android suelen utilizar externalCacheDir para almacenar temporalmente datos, como imágenes o documentos recuperados de fuentes externas (por ejemplo, cámara, administrador de archivos). Estas acciones se activan mediante intenciones implícitas a través de startActivityForResult(), lo que significa que la aplicación espera a que la aplicación externa (por ejemplo, cámara, administrador de archivos) responda con un URI que apunte al archivo solicitado junto con un código de estado.</p>\n<p>Si la implementación de onActivityResult() no valida adecuadamente los intents recibidos, la aplicación puede aceptar y procesar intents desde cualquier aplicación. Además, si el URI no se valida correctamente, la aplicación puede confiar ciegamente en los URI proporcionados por el atacante. Una aplicación maliciosa puede aprovechar este comportamiento inyectando una intención manipulada dirigida a los archivos internos de la aplicación víctima, lo que hace que <b>Challenge 3</b> guarde sus propios archivos internos (como tokens de autenticación o datos de usuario) en externalCacheDir, exponiéndolos efectivamente a acceso no autorizado.</p>\n<p>Dado que externalCacheDir se almacena en un almacenamiento externo (/storage/emulated/0/Android/data/<b>Challenge 3</b>/cache), cualquier aplicación con permisos READ_EXTERNAL_STORAGE puede acceder a él públicamente.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes mitigaciones para evitar el acceso no autorizado a archivos privados a través del almacenamiento en caché externo:</p>\n<ul>\n<li>Utilice almacenamiento interno (getCacheDir()) en lugar de externalCacheDir: almacene archivos temporales confidenciales en el almacenamiento interno, que es privado para la aplicación.</li>\n<li>Aplique una validación estricta de los datos de intención: asegúrese de que las intenciones entrantes (por ejemplo, desde startActivityForResult()) estén validadas y restringidas adecuadamente para evitar manipulaciones no autorizadas de archivos.</li>\n<li>Implementar Scoped Storage: si se debe utilizar almacenamiento externo, siga las mejores prácticas de Scoped Storage para limitar el acceso a archivos al propio directorio de la aplicación y evitar la exposición a aplicaciones de terceros.</li>\n<li>Borre periódicamente externalCacheDir: elimine automáticamente los archivos temporales en externalCacheDir una vez que ya no sean necesarios para minimizar la ventana de exposición.</li>\n<li>Restringir los permisos de almacenamiento: evite solicitar READ_EXTERNAL_STORAGE o WRITE_EXTERNAL_STORAGE a menos que sea absolutamente necesario.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar esta vulnerabilidad para:</p>\n<ul>\n<li>Acceda a datos confidenciales de la aplicación: los archivos privados, incluidos los tokens de autenticación, las cookies de sesión o el contenido generado por el usuario, pueden quedar expuestos si se almacenan temporalmente en externalCacheDir.</li>\n<li>Extraer archivos de configuración internos: si la aplicación almacena involuntariamente archivos internos en un almacenamiento externo, un atacante podría recuperarlos y analizarlos para su posterior explotación.</li>\n<li>Omitir el modelo de seguridad de almacenamiento de Android: esta técnica permite a un atacante acceder indirectamente a archivos almacenados en el directorio privado de la aplicación (/data/user/0/<b>Challenge 3</b>), eludiendo las restricciones de acceso directo.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "MASTG-TEST-0026: Testing Implicit Intents - Case 1: Arbitrary File Read",
              "url": "https://mas.owasp.org/MASTG/tests/android/MASVS-CODE/MASTG-TEST-0026/#case-1-arbitrary-file-read"
            },
            {
              "label": "Get a result from an activity | Android Developers",
              "url": "https://developer.android.com/training/basics/intents/result"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "f5632045-6a44-46cf-b2d7-fda8f5538cb6",
              "value": "private final FileOutputStream zabz() {\n         File file = ((BitmapTeleporter) this).zalj;\n         if (file == null) {\n             throw new IllegalStateException(\"setTempDir() must be called before writing this object to a parcel\");\n         }\n         try {\n             File createTempFile = File.createTempFile(\"teleporter\", \".tmp\", file);\n             try {\n                 FileOutputStream fileOutputStream = new FileOutputStream(createTempFile);\n                 ((BitmapTeleporter) this).zalg = ParcelFileDescriptor.open(createTempFile, 268435456);\n                 createTempFile.delete();\n                 return fileOutputStream;\n             } catch (FileNotFoundException unused) {\n                 throw new IllegalStateException(\"Temporary file is somehow already deleted\");\n             }\n         } catch (IOException e) {\n             throw new IllegalStateException(\"Could not create temporary file\", e);\n         }\n     }",
              "vulnerability_id": "367d4376-65b2-4f89-aa39-e6fe0ac7185d",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/common/data/BitmapTeleporter.java",
              "file_line": [
                159
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.635-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "15831d9c-3486-4e83-9e2c-38fd89f130d3",
          "title": "Arbitrary Code Execution",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team discovered a significant vulnerability in the <b>Challenge 3</b> application that involves the potential for arbitrary code execution. This was identified through the use of various class loading mechanisms within Android&#39;s Dalvik virtual machine system, specifically through methods like DexClassLoader and DexFile. These classes allow dynamic loading of executable code from external sources, which can be exploited if an attacker is able to manipulate the source files or the loading process.</p>\n<p>In practice, this vulnerability could allow malicious actors to load and execute arbitrary code within the context of the application without the user&#39;s knowledge. This could lead to unauthorized access to application data, manipulation of application behavior, or even control over the Android device itself.</p>\n<p>The following code snippet shows the insecure implementation:</p>\n",
              "remediation": "<p>The assessment team recommends the following remediation strategies to address the vulnerability associated with arbitrary code execution through dynamic class loading:</p>\n<ul>\n<li>Validate and Authenticate Code Sources: Ensure that all dynamically loaded code, especially from external sources, is thoroughly validated and authenticated before execution. Implement cryptographic techniques to verify the integrity and origin of the code.\n</li>\n<li>Use Secure Class Loaders: Minimize the use of custom class loaders and rely on the system class loader whenever possible. If custom class loaders are necessary, restrict their use to trusted environments and ensure they do not permit the loading of untrusted code.\n</li>\n<li>Implement Least Privilege Access: Restrict the permissions granted to dynamically loaded code to follow the principle of least privilege. Ensure that loaded code runs in a sandboxed environment with limited access to system resources and sensitive data.</li>\n</ul>\n",
              "impact": "<p>An attacker can exploit this vulnerability to dynamically load and execute arbitrary code on the device. This capability enables unauthorized access to application data and system resources, potentially compromising the entire device. By manipulating or replacing the dynamically loaded code, attackers could control application behaviors, exfiltrate sensitive information, introduce malware, or perform actions on behalf of the user without their consent.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió una vulnerabilidad importante en la aplicación <b>Challenge 3</b> relacionada con la ejecución de código arbitrario. Esto se identificó a partir del uso de varios mecanismos de carga de clase en el sistema de máquina virtual Dalvik de Android, específicamente, con métodos como DexClassLoader y DexFile. Estas clases permiten que se cargue código ejecutable de manera dinámica de fuentes externas, lo cual puede ser explotado por un atacante que logra manipular los archivos fuente o el proceso de carga. En la práctica, esta vulnerabilidad podría permitir que actores malintencionados carguen y ejecuten código arbitrario en el contexto de la aplicación sin el conocimiento del usuario. Esto podría producir el acceso no autorizado a la información de la aplicación, la manipulación del comportamiento de la aplicación e incluso la pérdida del control sobre el dispositivo Android.</p>\n<p>El siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes estrategias de remediación para abordar la vulnerabilidad asociada con la ejecución de código arbitrario mediante la carga dinámica de clases:</p>\n<ul>\n<li>Validar y autenticar fuentes de código: asegúrese de que todo el código cargado dinámicamente, especialmente el código cargado de fuentes externas, esté completamente validado y autenticado antes de su ejecución. También se recomienda implementar técnicas criptográficas para verificar la integridad y origen del código.\n</li>\n<li>Utilizar cargadores de clases seguros: minimice el uso de cargadores de clases personalizados y confíe en el cargador de clases del sistema siempre que sea posible. Si se necesitan cargadores de clases personalizados, restrinja su uso a entornos confiables y asegúrese de que no permitan la carga de código que no sea de confianza.\n</li>\n<li>Implementar acceso con privilegios mínimos: restrinja los permisos otorgados al código cargado dinámicamente para seguir el principio de privilegios mínimos. Asegúrese de que el código cargado se ejecute en un entorno aislado con acceso limitado a los recursos del sistema y a los datos confidenciales.</li>\n</ul>\n",
              "impact": "<p>Un atacante puede aprovechar esta vulnerabilidad para cargar y ejecutar dinámicamente código arbitrario en el dispositivo. Esto permite el acceso no autorizado a datos de aplicaciones y recursos del sistema, lo que podría comprometer todo el dispositivo. Al manipular o reemplazar el código cargado dinámicamente, los atacantes podrían controlar el comportamiento de las aplicaciones, filtrar información confidencial, introducir malware o realizar acciones en nombre del usuario sin su consentimiento.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "DexFile | Android Developers",
              "url": "https://developer.android.com/reference/dalvik/system/DexFile#loadClass(java.lang.String,%20java.lang.ClassLoader)"
            },
            {
              "label": "DexFile | Android Developers",
              "url": "https://developer.android.com/reference/dalvik/system/DexFile#loadDex(java.lang.String,%20java.lang.String,%20int)"
            },
            {
              "label": "DexFile | Android Developers",
              "url": "https://developer.android.com/reference/dalvik/system/DexFile"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0085"
          },
          "evidences": [
            {
              "id": "5718282c-9e4a-457c-9634-ea94578e3a59",
              "value": "Cls6W05KXC8VEDA30Q(String str, ClassLoader classLoader) {\n         super(str, classLoader);\n     }",
              "vulnerability_id": "15831d9c-3486-4e83-9e2c-38fd89f130d3",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/dynamite/zzh.java",
              "file_line": [
                10
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.397-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "d54716af-ebe0-4494-8a3f-41128df130ea",
          "title": "Use of External Storage with Media Types",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Challenge 3</b> processes media files using external storage. External storage in Android is publicly accessible, meaning any application with the necessary permissions can read or modify files stored there. If sensitive data is stored or handled insecurely in external storage, the application may be exposed to security risks.</p>\n",
              "remediation": "<p>The assessment team recommends storing sensitive media files in internal storage whenever possible to prevent unauthorized access. Applications targeting Android 10 (API level 29) and above should implement scoped storage to restrict access to external storage. Additionally, it is essential to validate and sanitize files read from external storage to prevent injection attacks and to limit the use of permissions such as READ_EXTERNAL_STORAGE and WRITE_EXTERNAL_STORAGE to only essential cases.</p>\n",
              "impact": "<p>Improper use of external storage can lead to:</p>\n<ul>\n<li>Data Tampering: Malicious applications can modify media files stored in external storage, potentially altering their content.</li>\n<li>Data Leakage: Sensitive information stored in external storage may be accessed by unauthorized applications.</li>\n<li>Code Injection: If the application processes media files from external storage without validation, an attacker could introduce malicious payloads.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Challenge 3</b> procesa archivos multimedia utilizando almacenamiento externo. El almacenamiento externo en Android es de acceso público, lo que significa que cualquier aplicación con los permisos necesarios puede leer o modificar los archivos almacenados allí. Si los datos confidenciales se almacenan o manejan de manera insegura en un almacenamiento externo, la aplicación puede quedar expuesta a riesgos de seguridad.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda almacenar archivos multimedia confidenciales en un almacenamiento interno siempre que sea posible para evitar el acceso no autorizado. Las aplicaciones destinadas a Android 10 (nivel de API 29) y superiores deben implementar almacenamiento con alcance para restringir el acceso al almacenamiento externo. Además, es esencial validar y desinfectar los archivos leídos desde el almacenamiento externo para evitar ataques de inyección y limitar el uso de permisos como READ_EXTERNAL_STORAGE y WRITE_EXTERNAL_STORAGE solo a casos esenciales.</p>\n",
              "impact": "<p>El uso inadecuado del almacenamiento externo puede provocar:</p>\n<ul>\n<li>Manipulación de datos: las aplicaciones maliciosas pueden modificar archivos multimedia almacenados en un almacenamiento externo, alterando potencialmente su contenido.</li>\n<li>Fuga de datos: aplicaciones no autorizadas pueden acceder a la información confidencial almacenada en un almacenamiento externo.</li>\n<li>Inyección de código: si la aplicación procesa archivos multimedia desde un almacenamiento externo sin validación, un atacante podría introducir cargas útiles maliciosas.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#external-storage"
            },
            {
              "label": "Sensitive Data Stored in External Storage | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sensitive-data-external-storage"
            },
            {
              "label": "MASTG-TEST-0201: Runtime Use of APIs to Access External Storage | OWASP Mobile Application Security",
              "url": "https://mas.owasp.org/MASTG/tests-beta/android/MASVS-STORAGE/MASTG-TEST-0201/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "f6b21b7a-27fc-48fd-9f51-80e4a0329939",
              "value": "public static Cursor query(ContentResolver contentResolver, Uri uri, String[] strArr, String str, String[] strArr2, String str2, CancellationSignal cancellationSignal) {\n         android.os.CancellationSignal cancellationSignal2;\n         if (Build.VERSION.SDK_INT >= 16) {\n             if (cancellationSignal != null) {\n                 try {\n                     cancellationSignal2 = cancellationSignal.getCancellationSignalObject();\n                 } catch (Exception e) {\n                     if (e instanceof OperationCanceledException) {\n                         throw new androidx.core.os.OperationCanceledException();\n                     }\n                     throw e;\n                 }\n             } else {\n                 cancellationSignal2 = null;\n             }\n             return contentResolver.query(uri, strArr, str, strArr2, str2, cancellationSignal2);\n         }\n         if (cancellationSignal != null) {\n             cancellationSignal.throwIfCanceled();\n         }\n         return contentResolver.query(uri, strArr, str, strArr2, str2);\n     }",
              "vulnerability_id": "d54716af-ebe0-4494-8a3f-41128df130ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/ContentResolverCompat.java",
              "file_line": [
                96
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:27.070-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "84a9430b-c23f-4680-bae7-21dc300e8c17",
              "value": "static FontsContractCompat.FontInfo[] getFontFromProvider(Context context, FontRequest fontRequest, String str, CancellationSignal cancellationSignal) {\n         Uri withAppendedId;\n         ArrayList arrayList = new ArrayList();\n         Uri build = new Uri.Builder().scheme(\"content\").authority(str).build();\n         Uri build2 = new Uri.Builder().scheme(\"content\").authority(str).appendPath(\"file\").build();\n         Cursor cursor = null;\n         try {\n             if (Build.VERSION.SDK_INT > 16) {\n                 cursor = context.getContentResolver().query(build, new String[]{\"_id\", \"file_id\", \"font_ttc_index\", \"font_variation_settings\", \"font_weight\", \"font_italic\", \"result_code\"}, \"query = ?\", new String[]{fontRequest.getQuery()}, null, cancellationSignal);\n             } else {\n                 cursor = context.getContentResolver().query(build, new String[]{\"_id\", \"file_id\", \"font_ttc_index\", \"font_variation_settings\", \"font_weight\", \"font_italic\", \"result_code\"}, \"query = ?\", new String[]{fontRequest.getQuery()}, null);\n             }\n             if (cursor != null && cursor.getCount() > 0) {\n                 int columnIndex = cursor.getColumnIndex(\"result_code\");\n                 ArrayList arrayList2 = new ArrayList();\n                 int columnIndex2 = cursor.getColumnIndex(\"_id\");\n                 int columnIndex3 = cursor.getColumnIndex(\"file_id\");\n                 int columnIndex4 = cursor.getColumnIndex(\"font_ttc_index\");\n                 int columnIndex5 = cursor.getColumnIndex(\"font_weight\");\n                 int columnIndex6 = cursor.getColumnIndex(\"font_italic\");\n                 while (cursor.moveToNext()) {\n                     int i = columnIndex != -1 ? cursor.getInt(columnIndex) : 0;\n                     int i2 = columnIndex4 != -1 ? cursor.getInt(columnIndex4) : 0;\n                     if (columnIndex3 == -1) {\n                         withAppendedId = ContentUris.withAppendedId(build, cursor.getLong(columnIndex2));\n                     } else {\n                         withAppendedId = ContentUris.withAppendedId(build2, cursor.getLong(columnIndex3));\n                     }\n                     arrayList2.add(new FontsContractCompat.FontInfo(withAppendedId, i2, columnIndex5 != -1 ? cursor.getInt(columnIndex5) : 400, columnIndex6 != -1 && cursor.getInt(columnIndex6) == 1, i));\n                 }\n                 arrayList = arrayList2;\n             }\n             return (FontsContractCompat.FontInfo[]) arrayList.toArray(new FontsContractCompat.FontInfo[0]);\n         } finally {\n             if (cursor != null) {\n                 cursor.close();\n             }\n         }\n     }",
              "vulnerability_id": "d54716af-ebe0-4494-8a3f-41128df130ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/provider/FontsContractCompat.java",
              "file_line": [
                502
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:27.100-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c2197cb3-1cbf-47ac-9be4-c7aa7018990d",
              "value": "private static long queryForLong(Context context, Uri uri, String str, long j) {\n         Cursor cursor = null;\n         try {\n             cursor = context.getContentResolver().query(uri, new String[]{str}, null, null, null);\n             return (!cursor.moveToFirst() || cursor.isNull(0)) ? j : cursor.getLong(0);\n         } catch (Exception e) {\n             Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             return j;\n         } finally {\n             DocumentsContractApi19.closeQuietly(cursor);\n         }\n     }",
              "vulnerability_id": "d54716af-ebe0-4494-8a3f-41128df130ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/DocumentsContractApi19.java",
              "file_line": [
                485
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:27.165-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d0e55852-baf5-4e2a-95e1-ac93a7795c89",
              "value": "public static String zza(ContentResolver contentResolver, String str, String str2) {\n         synchronized (zzei.class) {\n             if (zzei.zze == null) {\n                 zzei.zzk.set(false);\n                 zzei.zze = new HashMap();\n                 zzei.zzl = new Object();\n                 zzei.zzm = false;\n                 contentResolver.registerContentObserver(zzei.zza, true, new zzeh((Handler) null));\n             } else if (zzei.zzk.getAndSet(false)) {\n                 zzei.zze.clear();\n                 zzei.zzf.clear();\n                 zzei.zzg.clear();\n                 zzei.zzh.clear();\n                 zzei.zzi.clear();\n                 zzei.zzl = new Object();\n                 zzei.zzm = false;\n             }\n             Object obj = zzei.zzl;\n             if (zzei.zze.containsKey(str)) {\n                 String str3 = (String) zzei.zze.get(str);\n                 if (str3 != null) {\n                     r3 = str3;\n                 }\n                 return r3;\n             }\n             int length = zzei.zzj.length;\n             Cursor query = contentResolver.query(zzei.zza, null, null, new String[]{str}, null);\n             if (query == null) {\n                 return null;\n             }\n             try {\n                 if (!query.moveToFirst()) {\n                     zzei.zzc(obj, str, (String) null);\n                     return null;\n                 }\n                 String string = query.getString(1);\n                 if (string != null && string.equals(null)) {\n                     string = null;\n                 }\n                 zzei.zzc(obj, str, string);\n                 return string != null ? string : null;\n             } finally {\n                 query.close();\n             }\n         }\n     }",
              "vulnerability_id": "d54716af-ebe0-4494-8a3f-41128df130ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/internal/measurement/zzei.java",
              "file_line": [
                326
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:27.290-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "58579c06-96f6-4a24-a72c-1ed14672a5e4",
              "value": "private static String queryForString(Context context, Uri uri, String str, String str2) {\n         Cursor cursor = null;\n         try {\n             cursor = context.getContentResolver().query(uri, new String[]{str}, null, null, null);\n             return (!cursor.moveToFirst() || cursor.isNull(0)) ? str2 : cursor.getString(0);\n         } catch (Exception e) {\n             Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             return str2;\n         } finally {\n             DocumentsContractApi19.closeQuietly(cursor);\n         }\n     }",
              "vulnerability_id": "d54716af-ebe0-4494-8a3f-41128df130ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/DocumentsContractApi19.java",
              "file_line": [
                589
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:27.204-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3258ebaf-3a7c-46fc-8172-e1eb0ea632d1",
              "value": "public static boolean exists(Context context, Uri uri) {\n         Cursor cursor = null;\n         try {\n             cursor = context.getContentResolver().query(uri, new String[]{\"document_id\"}, null, null, null);\n             return cursor.getCount() > 0;\n         } catch (Exception e) {\n             Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             return false;\n         } finally {\n             DocumentsContractApi19.closeQuietly(cursor);\n         }\n     }",
              "vulnerability_id": "d54716af-ebe0-4494-8a3f-41128df130ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/DocumentsContractApi19.java",
              "file_line": [
                191
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:27.140-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c864499c-8fe1-423c-9513-e55b3848c632",
              "value": "Cursor getSearchManagerSuggestions(SearchableInfo searchableInfo, String str, int i) {\n         String suggestAuthority;\n         String[] strArr = null;\n         if (searchableInfo == null || (suggestAuthority = searchableInfo.getSuggestAuthority()) == null) {\n             return null;\n         }\n         Uri.Builder fragment = new Uri.Builder().scheme(\"content\").authority(suggestAuthority).query(\"\").fragment(\"\");\n         String suggestPath = searchableInfo.getSuggestPath();\n         if (suggestPath != null) {\n             fragment.appendEncodedPath(suggestPath);\n         }\n         fragment.appendPath(\"search_suggest_query\");\n         String suggestSelection = searchableInfo.getSuggestSelection();\n         if (suggestSelection != null) {\n             strArr = new String[]{str};\n         } else {\n             fragment.appendPath(str);\n         }\n         String[] strArr2 = strArr;\n         if (i > 0) {\n             fragment.appendQueryParameter(\"limit\", String.valueOf(i));\n         }\n         return ((SuggestionsAdapter) this).mContext.getContentResolver().query(fragment.build(), null, suggestSelection, strArr2, null);\n     }",
              "vulnerability_id": "d54716af-ebe0-4494-8a3f-41128df130ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SuggestionsAdapter.java",
              "file_line": [
                1838
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:27.047-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5635aba8-4b6e-4563-a762-d45cdd103b86",
              "value": "public DocumentFile[] listFiles() {\n         ContentResolver contentResolver = ((TreeDocumentFile) this).mContext.getContentResolver();\n         Uri uri = ((TreeDocumentFile) this).mUri;\n         Uri buildChildDocumentsUriUsingTree = DocumentsContract.buildChildDocumentsUriUsingTree(uri, DocumentsContract.getDocumentId(uri));\n         ArrayList arrayList = new ArrayList();\n         Cursor cursor = null;\n         try {\n             try {\n                 cursor = contentResolver.query(buildChildDocumentsUriUsingTree, new String[]{\"document_id\"}, null, null, null);\n                 while (cursor.moveToNext()) {\n                     arrayList.add(DocumentsContract.buildDocumentUriUsingTree(((TreeDocumentFile) this).mUri, cursor.getString(0)));\n                 }\n             } catch (Exception e) {\n                 Log.w(\"DocumentFile\", \"Failed query: \" + e);\n             }\n             Uri[] uriArr = (Uri[]) arrayList.toArray(new Uri[arrayList.size()]);\n             DocumentFile[] documentFileArr = new DocumentFile[uriArr.length];\n             for (int i = 0; i < uriArr.length; i++) {\n                 documentFileArr[i] = new TreeDocumentFile(this, ((TreeDocumentFile) this).mContext, uriArr[i]);\n             }\n             return documentFileArr;\n         } finally {\n             TreeDocumentFile.closeQuietly(cursor);\n         }\n     }",
              "vulnerability_id": "d54716af-ebe0-4494-8a3f-41128df130ea",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/documentfile/provider/TreeDocumentFile.java",
              "file_line": [
                373
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:27.236-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "234c7d3a-2058-45db-96eb-c4620dd041df",
          "title": "Google Maps API Key Disclosed",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>Challenge 3</b> mobile application integrates Google Maps for geolocation functionality and the API key is disclosed in &lt;Source Code, Response, etc&gt;. It was found that the configuration of this API key could be accessed and used by unauthorized users, enabling them to consume the API without any restrictions.</p>\n<p>The code snippet below illustrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends implementing an IP/Referer or application restriction to control who can utilize the API key. Furthermore, the team suggests using a client ID authentication solution and signatures instead of relying solely on API keys.</p>\n<p>Additionally, it is advised to either remove the API key from the JavaScript file or restrict its use through the Google Developer Console at <a href=\"https://console.developers.google.com/\">https://console.developers.google.com/</a>.</p>\n",
              "impact": "<p>If Google Maps API keys are not properly secured and configured, an attacker could potentially:</p>\n<p>Consume the company’s monthly quota for the service.\nIncur significant financial costs to the company by unauthorized usage of the service, especially if there are no limitations set on API budgets.\nExecute a denial-of-service attack targeting the service, especially if there are controls for maximum billing in the Google account settings.\nIn this specific case, it was found that an attacker could generate requests using a Staticmap at an estimated cost of $2 per 1000 requests.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación móvil <b>Challenge 3</b> integra Google Maps para funcionalidades de geolocalización y la clave API se revela en &lt;Código Fuente, Respuesta, etc&gt;. Se encontró que la configuración de esta clave API podría ser accedida y utilizada por usuarios no autorizados, permitiéndoles consumir la API sin restricciones.</p>\n<p>El fragmento de código a continuación muestra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda implementar una restricción de IP/Referer o de aplicación para controlar quién puede utilizar la clave API. Además, el equipo sugiere usar una solución de autenticación con ID de cliente y firmas en lugar de depender únicamente de claves API.</p>\n<p>Adicionalmente, se aconseja eliminar la clave API del archivo JavaScript o restringir su uso a través de la Consola de Desarrolladores de Google en <a href=\"https://console.developers.google.com/\">https://console.developers.google.com/</a>.</p>\n",
              "impact": "<p>Si las claves de la API de Google Maps no están debidamente aseguradas y configuradas, un atacante podría:</p>\n<p>Consumir la cuota mensual de la empresa para el servicio.\nIncurrir en costos financieros significativos para la empresa mediante el uso no autorizado del servicio, especialmente si no hay límites establecidos en los presupuestos de la API.\nEjecutar un ataque de denegación de servicio dirigido al servicio, especialmente si existen controles para el límite máximo de facturación en las configuraciones de la cuenta de Google.\nEn este caso específico, se encontró que un atacante podría generar solicitudes utilizando un Staticmap a un costo estimado de $2 por cada 1000 solicitudes.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "API security best practices  |  Google Maps Platform  |  Google for Developers",
              "url": "https://developers.google.com/maps/api-security-best-practices"
            },
            {
              "label": "CWE - CWE-798: Use of Hard-coded Credentials (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/798.html"
            },
            {
              "label": "Use of hard-coded password | OWASP Foundation",
              "url": "https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-AUTH-1",
            "maswe": "MASWE-0005"
          },
          "evidences": [
            {
              "id": "1f675afd-f6f7-4926-a9e7-657c4d8b2be8",
              "value": "<string name=\"fab_transformation_sheet_behavior\">com.google.android.material.transformation.FabTransformationSheetBehavior</string>\n    <string name=\"gcm_defaultSenderId\">874324969710</string>\n    <string name=\"google_api_key\">AIzaSyAtX1L4eGoJZ38I_UIUpVcArSRQ_pgEk54</string>\n    <string name=\"google_app_id\">1:874324969710:android:c86209005a182da9a24bff</string>\n    <string name=\"google_crash_reporting_api_key\">AIzaSyAtX1L4eGoJZ38I_UIUpVcArSRQ_pgEk54</string>",
              "vulnerability_id": "234c7d3a-2058-45db-96eb-c4620dd041df",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/res/values/strings.xml",
              "file_line": [
                62
              ],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T20:56:27.345-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2c9dbe21-acf4-4a41-9936-0fc6d85f9f38",
              "value": "<string name=\"google_api_key\">AIzaSyAtX1L4eGoJZ38I_UIUpVcArSRQ_pgEk54</string>\n    <string name=\"google_app_id\">1:874324969710:android:c86209005a182da9a24bff</string>\n    <string name=\"google_crash_reporting_api_key\">AIzaSyAtX1L4eGoJZ38I_UIUpVcArSRQ_pgEk54</string>\n    <string name=\"google_storage_bucket\">justmobilesecurity-challenges.appspot.com</string>\n    <string name=\"hide_bottom_view_on_scroll_behavior\">com.google.android.material.behavior.HideBottomViewOnScrollBehavior</string>",
              "vulnerability_id": "234c7d3a-2058-45db-96eb-c4620dd041df",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/res/values/strings.xml",
              "file_line": [
                64
              ],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T20:56:27.389-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "8dcc4431-b702-4f22-af16-c141219623b5",
          "title": "Access External Storage",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>Challenge 3</b> application utilizes external storage for reading and writing data. Storing data externally poses a risk as it can be accessed and modified by malicious applications on the same device. This vulnerability can lead to information disclosure, data tampering, or other forms of malicious behavior.</p>\n<p>The code snippet below illustrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends not storing executable files, configuration files, or sensitive user data on the external storage if its possible otherwise it should be strongly encrypted to avoid sensitive information to be disclosed.</p>\n",
              "impact": "<p>An attacker or a malicious application could exploit this vulnerability to access or modify the data stored in the external storage. This unauthorized access or modification could lead to serious security issues, including data breaches, information disclosure, and compromising the integrity of the application&#39;s data.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación <b>Challenge 3</b> utiliza almacenamiento externo para leer y escribir datos. El almacenamiento de datos de forma externa representa un riesgo, ya que puede ser accedido y modificado por aplicaciones maliciosas en el mismo dispositivo. Esta vulnerabilidad puede llevar a la divulgación de información, manipulación de datos u otras formas de comportamiento malicioso.</p>\n<p>El fragmento de código a continuación ilustra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda evitar almacenar archivos ejecutables, archivos de configuración o datos sensibles de usuarios en el almacenamiento externo siempre que sea posible. Si es necesario utilizar almacenamiento externo, es crucial emplear encriptación fuerte para prevenir la divulgación de información sensible.</p>\n",
              "impact": "<p>Un atacante o una aplicación maliciosa podría aprovechar esta vulnerabilidad para acceder o modificar los datos almacenados en el almacenamiento externo. Este acceso o modificación no autorizados podrían conducir a graves problemas de seguridad, incluyendo violaciones de datos, divulgación de información y compromiso de la integridad de los datos de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "M2: Insecure Data Storage | OWASP Foundation",
              "url": "https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage"
            },
            {
              "label": "MSTG- Testing Data Storage",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#external-storage"
            },
            {
              "label": "CWE - CWE-921: Storage of Sensitive Data in a Mechanism without Access Control (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/921.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "7411d490-f215-49c9-8f77-e6779fd250ee",
              "value": "public static File[] getExternalCacheDirs(Context context) {\n         return Build.VERSION.SDK_INT >= 19 ? context.getExternalCacheDirs() : new File[]{context.getExternalCacheDir()};\n     }",
              "vulnerability_id": "8dcc4431-b702-4f22-af16-c141219623b5",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/ContextCompat.java",
              "file_line": [
                435
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:23.745-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "fa8beba6-9ef7-4e2e-92a1-80402b8e1c9f",
              "value": "public static File[] getExternalFilesDirs(Context context, String str) {\n         return Build.VERSION.SDK_INT >= 19 ? context.getExternalFilesDirs(str) : new File[]{context.getExternalFilesDir(str)};\n     }",
              "vulnerability_id": "8dcc4431-b702-4f22-af16-c141219623b5",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/ContextCompat.java",
              "file_line": [
                469
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:23.777-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c347cb9d-906c-45f1-b98a-e993ac9d7a81",
              "value": "public static String getStorageState(File file) {\n         if (Build.VERSION.SDK_INT >= 21) {\n             return Environment.getExternalStorageState(file);\n         }\n         if (Build.VERSION.SDK_INT >= 19) {\n             return Environment.getStorageState(file);\n         }\n         try {\n             return file.getCanonicalPath().startsWith(Environment.getExternalStorageDirectory().getCanonicalPath()) ? Environment.getExternalStorageState() : \"unknown\";\n         } catch (IOException e) {\n             Log.w(\"EnvironmentCompat\", \"Failed to resolve canonical path: \" + e);\n             return \"unknown\";\n         }\n     }",
              "vulnerability_id": "8dcc4431-b702-4f22-af16-c141219623b5",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/os/EnvironmentCompat.java",
              "file_line": [
                62
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:23.867-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "17031c54-d218-45f7-8ff9-6c43a8ee68ee",
          "title": "Application Allows Execution of Backups",
          "severity": "low",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>android:allowBackup</b> attribute is set to true in the Android Manifest file of the <b>Challenge 3</b> application. This setting determines if a user can back up and restore the application&#39;s data. When the backup flag is true, it permits an attacker to extract a backup of the application&#39;s data through adb/USB, even on unrooted devices.</p>\n",
              "remediation": "<p>To prevent unauthorized backup of the app data, set the <b>android:allowBackup</b> attribute to false. By default, the allowBackup setting is enabled if this attribute is not explicitly defined, necessitating manual deactivation. It&#39;s important to regularly review the <b>AndroidManifest.xml</b> file to ensure that the developer framework does not inadvertently include insecure default settings.</p>\n",
              "impact": "<p>Android includes an <b>allowBackup</b> attribute, used to enable the backup of all application data. This attribute is defined in the <b>AndroidManifest.xml</b> file. When its value is set to true, it permits users to back up the application data using the Android Debug Bridge (ADB). However, this setting can potentially expose sensitive data, as it allows for data backup without strong security controls, potentially leading to data leakage or unauthorized access if exploited.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que el atributo <b>android:allowBackup</b> está configurado como true en el archivo Android Manifest de la aplicación <b>Challenge 3</b>. Esta configuración determina si los datos de la aplicación pueden ser respaldados y restaurados por el usuario. Cuando el flag allowBackup está en true, permite a un atacante realizar un backup de los datos de la aplicación a través de adb/USB, incluso en dispositivos que no están rooteados.</p>\n",
              "remediation": "<p>Para prevenir el respaldo no autorizado de los datos de la aplicación, configure el atributo <b>android:allowBackup</b> en false. Por defecto, la configuración allowBackup está habilitada si este atributo no se define explícitamente, lo que requiere una desactivación manual. Es importante revisar regularmente el archivo <b>AndroidManifest.xml</b> para asegurarse de que el marco de desarrollo no incluya por error configuraciones predeterminadas inseguras.</p>\n",
              "impact": "<p>Android incluye un atributo llamado <b>allowBackup</b>, utilizado para habilitar el respaldo de todos los datos de una aplicación. Este atributo se define en el archivo <b>AndroidManifest.xml</b>. Cuando su valor está configurado en true, permite a los usuarios respaldar los datos de la aplicación utilizando el Android Debug Bridge (ADB). Sin embargo, esta configuración puede exponer datos sensibles, ya que permite realizar copias de seguridad de datos sin controles de seguridad estrictos, lo que podría llevar a la filtración de datos o acceso no autorizado si se explota.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "MSTG - Testing Backups",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-backups-for-sensitive-data-mstg-storage-8"
            },
            {
              "label": "Back up user data with Auto Backup  |  Android Developers",
              "url": "https://developer.android.com/guide/topics/data/autobackup"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-2",
            "maswe": "MASWE-0003"
          },
          "evidences": [
            {
              "id": "a859d592-b830-441c-9794-90a1178c143b",
              "value": "<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n    <uses-permission android:name=\"com.google.android.finsky.permission.BIND_GET_INSTALL_REFERRER_SERVICE\" />\n    <application android:theme=\"@style/Theme.Challenge3\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:extractNativeLibs=\"false\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:appComponentFactory=\"androidx.core.app.CoreComponentFactory\">\n        <activity android:name=\"com.just.mobile.sec.challenge3.SuccessfullySingUpActivity\" />",
              "vulnerability_id": "17031c54-d218-45f7-8ff9-6c43a8ee68ee",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/AndroidManifest.xml",
              "file_line": [],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T20:56:26.563-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "32a2dbf4-8c80-458d-9900-5453c7347376",
          "title": "Dynamic Receiver Registration",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team discovered a vulnerability in the <b>Challenge 3</b> application related to the dynamic registration of broadcast receivers. This issue arises due to the application&#39;s use of the registerReceiver() method, which can register broadcast receivers dynamically at runtime instead of declaring them statically in the Android manifest. While dynamic registration provides flexibility, it also introduces potential security risks if not properly managed.</p>\n<p>Specifically, dynamically registered broadcast receivers do not benefit from the Android system&#39;s manifest-based security checks, which can lead to unintended broadcast exposure. If the intent filters associated with these receivers are not carefully specified, it could allow external applications to send broadcasts to the receivers, potentially leading to information leakage or triggering unintended behavior within the app.</p>\n<p>The following code snippet shows the insecure implementation:</p>\n",
              "remediation": "<p>To mitigate the risks associated with dynamically registered broadcast receivers the assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Explicit Intent Filters: Ensure that all dynamically registered broadcast receivers use explicit intent filters that clearly define what actions the receiver is intended to respond to. This helps prevent malicious apps from sending broadcasts that could trigger unintended behavior.\n</li>\n<li>Validate Broadcast Origin: Implement checks within the broadcast receiver to validate the origin of the broadcast. This ensures that only broadcasts from trusted sources are processed, reducing the risk of unauthorized access or manipulation.\n</li>\n<li>Limit Receiver Exposure: Where possible, avoid dynamic registration of broadcast receivers and instead declare them statically in the Android manifest with the necessary permission settings. This leverages the platform's built-in security features to control who can send broadcasts to the receivers.\n</li>\n<li>Use Local Broadcast Manager: For intra-app communication, use Android's Local Broadcast Manager to handle broadcasts. This confines broadcast messages to the app itself, preventing external applications from sending messages to the receivers.\n</li>\n<li>Unregister Receivers: Always ensure that dynamically registered receivers are unregistered when not needed, especially when the app is not in the foreground. This prevents dormant receivers from being triggered unexpectedly.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit the dynamically registered broadcast receivers to send unauthorized broadcasts that trigger unintended actions or manipulate the application’s behavior. This vulnerability could lead to the leakage of sensitive information if broadcasts are intercepted, or could cause the application to perform unintended operations. Such exposures can compromise user data privacy and application functionality</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió una vulnerabilidad en la aplicación <b>Challenge 3</b> relacionada con el registro dinámico de receptores de transmisión. Este problema surge debido al uso por parte de la aplicación del método RegisterReceiver(), que puede registrar receptores de transmisión dinámicamente en tiempo de ejecución en lugar de declararlos estáticamente en el manifiesto de Android. Si bien el registro dinámico proporciona flexibilidad, también introduce riesgos potenciales de seguridad si no se gestiona adecuadamente.</p>\n<p>Específicamente, los receptores de transmisión registrados dinámicamente no se benefician de las comprobaciones de seguridad basadas en manifiestos del sistema Android, lo que puede provocar una exposición involuntaria de la transmisión. Si los filtros de intención asociados con estos receptores no se especifican cuidadosamente, podría permitir que aplicaciones externas envíen transmisiones a los receptores, lo que podría provocar una fuga de información o desencadenar un comportamiento no deseado dentro de la aplicación.</p>\n<p>El siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>Para mitigar los riesgos asociados con los receptores de transmisión registrados dinámicamente, el equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Filtros de intención explícitos: asegúrese de que todos los receptores de transmisión registrados dinámicamente utilicen filtros de intención explícitos que definan claramente a qué acciones debe responder el receptor. Esto ayuda a evitar que aplicaciones maliciosas envíen difusiones que podrían desencadenar un comportamiento no deseado.\n</li>\n<li>Validar origen de transmisión: implemente comprobaciones dentro del receptor de transmisión para validar el origen de la transmisión. Esto garantiza que solo se procesen transmisiones de fuentes confiables, lo que reduce el riesgo de acceso o manipulación no autorizados.\n</li>\n<li>Limitar la exposición del receptor: cuando sea posible, evite el registro dinámico de los receptores de transmisión y, en cambio, declárelos estáticamente en el manifiesto de Android con la configuración de permisos necesaria. Esto aprovecha las funciones de seguridad integradas de la plataforma para controlar quién puede enviar transmisiones a los receptores.\n</li>\n<li>Utilizar el Administrador de transmisiones locales: para la comunicación dentro de la aplicación, use el Administrador de transmisiones locales de Android para manejar las transmisiones. Esto limita los mensajes de difusión a la propia aplicación y evita que aplicaciones externas envíen mensajes a los receptores.\n</li>\n<li>Cancelar receptores: asegúrese siempre de cancelar el registro de los receptores registrados dinámicamente cuando no sean necesarios, especialmente cuando la aplicación no esté en primer plano. Esto evita que los receptores inactivos se activen inesperadamente.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar los receptores de transmisión registrados dinámicamente para enviar transmisiones no autorizadas que desencadenen acciones no deseadas o manipulen el comportamiento de la aplicación. Esta vulnerabilidad podría provocar la fuga de información confidencial si se interceptan las transmisiones o podría provocar que la aplicación realice operaciones no deseadas. Estas exposiciones pueden comprometer la privacidad de los datos del usuario y la funcionalidad de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Transmisiones persistentes | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sticky-broadcast?hl=es-419"
            },
            {
              "label": "Insecure Broadcast Receiver Configuration - Ostorlab: Mobile application security testing for android and ios",
              "url": "https://docs.ostorlab.co/kb/INSECURE_REGISTER_RECEIVER_FLAG/index.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0063"
          },
          "evidences": [
            {
              "id": "88b54604-1f70-418d-9567-334db45cfda5",
              "value": "void setup() {\n         cleanup();\n         IntentFilter createIntentFilterForBroadcastReceiver = createIntentFilterForBroadcastReceiver();\n         if (createIntentFilterForBroadcastReceiver == null || createIntentFilterForBroadcastReceiver.countActions() == 0) {\n             return;\n         }\n         if (((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver == null) {\n             ((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver = new AppCompatDelegateImpl.AutoNightModeManager.1(this);\n         }\n         ((AppCompatDelegateImpl.AutoNightModeManager) this).this$0.mContext.registerReceiver(((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver, createIntentFilterForBroadcastReceiver);\n     }",
              "vulnerability_id": "32a2dbf4-8c80-458d-9900-5453c7347376",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/app/AppCompatDelegateImpl$AutoNightModeManager.java",
              "file_line": [
                138
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.910-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1280d1b2-d732-46fe-afc3-dd0811e9237b",
              "value": "public final void zza() {\n         ((zzeq) this).zzb.zzs();\n         ((zzeq) this).zzb.zzau().zzg();\n         if (((zzeq) this).zzc) {\n             return;\n         }\n         ((zzeq) this).zzb.zzaw().registerReceiver(this, new IntentFilter(\"android.net.conn.CONNECTIVITY_CHANGE\"));\n         ((zzeq) this).zzd = ((zzeq) this).zzb.zzh().zzb();\n         ((zzeq) this).zzb.zzat().zzk().zzb(\"Registering connectivity change receiver. Network connected\", Boolean.valueOf(((zzeq) this).zzd));\n         ((zzeq) this).zzc = true;\n     }",
              "vulnerability_id": "32a2dbf4-8c80-458d-9900-5453c7347376",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzeq.java",
              "file_line": [
                181
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.053-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "a0ec923d-8ae6-470f-b803-c89c3c94cc09",
              "value": "public final zabq zaa(Context context, zabr zabrVar) {\n         IntentFilter intentFilter = new IntentFilter(\"android.intent.action.PACKAGE_ADDED\");\n         intentFilter.addDataScheme(\"package\");\n         zabq zabqVar = new zabq(zabrVar);\n         context.registerReceiver(zabqVar, intentFilter);\n         zabqVar.zac(context);\n         if (isUninstalledAppPossiblyUpdating(context, \"com.google.android.gms\")) {\n             return zabqVar;\n         }\n         zabrVar.zas();\n         zabqVar.unregister();\n         return null;\n     }",
              "vulnerability_id": "32a2dbf4-8c80-458d-9900-5453c7347376",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/common/GoogleApiAvailability.java",
              "file_line": [
                1029
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.948-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "095dec55-6409-4678-8774-c027193db629",
              "value": "public static int zzg(Context context) {\n         boolean isScreenOn;\n         if (context == null || context.getApplicationContext() == null) {\n             return -1;\n         }\n         Intent registerReceiver = context.getApplicationContext().registerReceiver(null, zza.filter);\n         int i = ((registerReceiver == null ? 0 : registerReceiver.getIntExtra(\"plugged\", 0)) & 7) != 0 ? 1 : 0;\n         PowerManager powerManager = (PowerManager) context.getSystemService(\"power\");\n         if (powerManager == null) {\n             return -1;\n         }\n         if (PlatformVersion.isAtLeastKitKatWatch()) {\n             isScreenOn = powerManager.isInteractive();\n         } else {\n             isScreenOn = powerManager.isScreenOn();\n         }\n         return (isScreenOn ? 2 : 0) | i;\n     }",
              "vulnerability_id": "32a2dbf4-8c80-458d-9900-5453c7347376",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/common/util/zza.java",
              "file_line": [
                60
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:25.987-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "fe958518-a576-453a-8c4a-1e1e0a5556f2",
              "value": "public static synchronized float zzh(Context context) {\n         synchronized (zza.class) {\n             if (SystemClock.elapsedRealtime() - zza.zzgv < 60000 && !Float.isNaN(zza.zzgw)) {\n                 return zza.zzgw;\n             }\n             Intent registerReceiver = context.getApplicationContext().registerReceiver(null, zza.filter);\n             if (registerReceiver != null) {\n                 zza.zzgw = registerReceiver.getIntExtra(\"level\", -1) / registerReceiver.getIntExtra(\"scale\", -1);\n             }\n             zza.zzgv = SystemClock.elapsedRealtime();\n             return zza.zzgw;\n         }\n     }",
              "vulnerability_id": "32a2dbf4-8c80-458d-9900-5453c7347376",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/common/util/zza.java",
              "file_line": [
                194
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.024-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d7cad5b1-6e6c-4279-b6e3-16888d3cd271",
              "value": "private static void ensureReceiverRegistered(Context context) {\n         if (FirebaseApp.UserUnlockReceiver.INSTANCE.get() == null) {\n             FirebaseApp.UserUnlockReceiver userUnlockReceiver = new FirebaseApp.UserUnlockReceiver(context);\n             if (FirebaseApp.UserUnlockReceiver.INSTANCE.compareAndSet(null, userUnlockReceiver)) {\n                 context.registerReceiver(userUnlockReceiver, new IntentFilter(\"android.intent.action.USER_UNLOCKED\"));\n             }\n         }\n     }",
              "vulnerability_id": "32a2dbf4-8c80-458d-9900-5453c7347376",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/firebase/FirebaseApp$UserUnlockReceiver.java",
              "file_line": [
                104
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:26.091-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
          "title": "Implicit Intent Detected",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Challenge 3</b> uses implicit intents, which allow the Android system to determine which component, potentially from another application, should handle an intent. While this enables flexible inter-application communication, insecure implementation can lead to unintended exposure of sensitive functionality.</p>\n",
              "remediation": "<p>The assessment team recommends using explicit intents whenever possible to ensure that only intended application components handle them. If implicit intents are required, developers should restrict exposed components by properly configuring intent filters and setting the exported attribute to false when external access is not necessary. Additionally, all incoming intents should be validated to prevent unauthorized access or data manipulation.</p>\n",
              "impact": "<p>Improper handling of implicit intents can result in intent hijacking, where malicious applications intercept and manipulate intents that were not explicitly directed to a specific component. This could lead to unauthorized access to sensitive data or unintended execution of actions triggered by an attacker.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Challenge 3</b> utiliza intenciones implícitas, que permiten al sistema Android determinar qué componente, potencialmente de otra aplicación, debe manejar una intención. Si bien esto permite una comunicación flexible entre aplicaciones, una implementación insegura puede provocar una exposición involuntaria de funciones confidenciales.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda utilizar intenciones explícitas siempre que sea posible para garantizar que solo los componentes de la aplicación previstos las manejen. Si se requieren intenciones implícitas, los desarrolladores deben restringir los componentes expuestos configurando correctamente los filtros de intención y estableciendo el atributo exportado en falso cuando no sea necesario el acceso externo. Además, todos los intents entrantes deben validarse para evitar el acceso no autorizado o la manipulación de datos.</p>\n",
              "impact": "<p>El manejo inadecuado de intenciones implícitas puede resultar en secuestro de intenciones, donde aplicaciones maliciosas interceptan y manipulan intenciones que no estaban dirigidas explícitamente a un componente específico. Esto podría dar lugar a un acceso no autorizado a datos confidenciales o a la ejecución involuntaria de acciones provocadas por un atacante.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Intents and Intent Filters | App architecture - Android Developers",
              "url": "https://developer.android.com/guide/components/intents-filters?hl=es-419"
            },
            {
              "label": "Implicit Intent Hijacking | Security - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/implicit-intent-hijacking?hl=es-419"
            },
            {
              "label": "Mitigate security risks in your app - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "a8a1da62-6b09-495f-8d3f-16b9df1eef75",
              "value": "public Cls1HVI6J8Z1E247PI(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         View.OnClickListener onClickListener = new SearchView.5(this);\n         ((SearchView) this).mOnClickListener = onClickListener;\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         SearchView.7 r2 = new SearchView.7(this);\n         ((SearchView) this).mOnEditorActionListener = r2;\n         SearchView.8 r3 = new SearchView.8(this);\n         ((SearchView) this).mOnItemClickListener = r3;\n         SearchView.9 r4 = new SearchView.9(this);\n         ((SearchView) this).mOnItemSelectedListener = r4;\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray obtainStyledAttributes = TintTypedArray.obtainStyledAttributes(context, attributeSet, R.styleable.SearchView, i, 0);\n         LayoutInflater.from(context).inflate(obtainStyledAttributes.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         View findViewById2 = findViewById(R.id.search_plate);\n         ((SearchView) this).mSearchPlate = findViewById2;\n         View findViewById3 = findViewById(R.id.submit_area);\n         ((SearchView) this).mSubmitArea = findViewById3;\n         ImageView imageView = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mSearchButton = imageView;\n         ImageView imageView2 = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mGoButton = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mCloseButton = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mVoiceButton = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(R.id.search_mag_icon);\n         ((SearchView) this).mCollapsedIcon = imageView5;\n         ViewCompat.setBackground(findViewById2, obtainStyledAttributes.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(findViewById3, obtainStyledAttributes.getDrawable(R.styleable.SearchView_submitBackground));\n         imageView.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         imageView2.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_goIcon));\n         imageView3.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_closeIcon));\n         imageView4.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_voiceIcon));\n         imageView5.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(imageView, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = obtainStyledAttributes.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = obtainStyledAttributes.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         imageView.setOnClickListener(onClickListener);\n         imageView3.setOnClickListener(onClickListener);\n         imageView2.setOnClickListener(onClickListener);\n         imageView4.setOnClickListener(onClickListener);\n         findViewById.setOnClickListener(onClickListener);\n         findViewById.addTextChangedListener(((SearchView) this).mTextWatcher);\n         findViewById.setOnEditorActionListener(r2);\n         findViewById.setOnItemClickListener(r3);\n         findViewById.setOnItemSelectedListener(r4);\n         findViewById.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         findViewById.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(obtainStyledAttributes.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int dimensionPixelSize = obtainStyledAttributes.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (dimensionPixelSize != -1) {\n             setMaxWidth(dimensionPixelSize);\n         }\n         ((SearchView) this).mDefaultQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_queryHint);\n         int i2 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (i2 != -1) {\n             setImeOptions(i2);\n         }\n         int i3 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (i3 != -1) {\n             setInputType(i3);\n         }\n         setFocusable(obtainStyledAttributes.getBoolean(R.styleable.SearchView_android_focusable, true));\n         obtainStyledAttributes.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).mDropDownAnchor = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                660
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:23.993-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "2a24580f-2882-42cf-974a-3008e8e79a5f",
              "value": "public ClsYJ95AEXUTYK98D8(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         View.OnClickListener onClickListener = new SearchView.5(this);\n         ((SearchView) this).mOnClickListener = onClickListener;\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         SearchView.7 r2 = new SearchView.7(this);\n         ((SearchView) this).mOnEditorActionListener = r2;\n         SearchView.8 r3 = new SearchView.8(this);\n         ((SearchView) this).mOnItemClickListener = r3;\n         SearchView.9 r4 = new SearchView.9(this);\n         ((SearchView) this).mOnItemSelectedListener = r4;\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray obtainStyledAttributes = TintTypedArray.obtainStyledAttributes(context, attributeSet, R.styleable.SearchView, i, 0);\n         LayoutInflater.from(context).inflate(obtainStyledAttributes.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         View findViewById2 = findViewById(R.id.search_plate);\n         ((SearchView) this).mSearchPlate = findViewById2;\n         View findViewById3 = findViewById(R.id.submit_area);\n         ((SearchView) this).mSubmitArea = findViewById3;\n         ImageView imageView = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mSearchButton = imageView;\n         ImageView imageView2 = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mGoButton = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mCloseButton = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mVoiceButton = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(R.id.search_mag_icon);\n         ((SearchView) this).mCollapsedIcon = imageView5;\n         ViewCompat.setBackground(findViewById2, obtainStyledAttributes.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(findViewById3, obtainStyledAttributes.getDrawable(R.styleable.SearchView_submitBackground));\n         imageView.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         imageView2.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_goIcon));\n         imageView3.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_closeIcon));\n         imageView4.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_voiceIcon));\n         imageView5.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(imageView, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = obtainStyledAttributes.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = obtainStyledAttributes.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         imageView.setOnClickListener(onClickListener);\n         imageView3.setOnClickListener(onClickListener);\n         imageView2.setOnClickListener(onClickListener);\n         imageView4.setOnClickListener(onClickListener);\n         findViewById.setOnClickListener(onClickListener);\n         findViewById.addTextChangedListener(((SearchView) this).mTextWatcher);\n         findViewById.setOnEditorActionListener(r2);\n         findViewById.setOnItemClickListener(r3);\n         findViewById.setOnItemSelectedListener(r4);\n         findViewById.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         findViewById.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(obtainStyledAttributes.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int dimensionPixelSize = obtainStyledAttributes.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (dimensionPixelSize != -1) {\n             setMaxWidth(dimensionPixelSize);\n         }\n         ((SearchView) this).mDefaultQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_queryHint);\n         int i2 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (i2 != -1) {\n             setImeOptions(i2);\n         }\n         int i3 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (i3 != -1) {\n             setInputType(i3);\n         }\n         setFocusable(obtainStyledAttributes.getBoolean(R.styleable.SearchView_android_focusable, true));\n         obtainStyledAttributes.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).mDropDownAnchor = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                681
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.057-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ba1b3983-9280-4a6c-a93a-f49aa80eff6a",
              "value": "private Intent createIntent(String str, Uri uri, String str2, String str3, int i, String str4) {\n         Intent intent = new Intent(str);\n         intent.addFlags(268435456);\n         if (uri != null) {\n             intent.setData(uri);\n         }\n         intent.putExtra(\"user_query\", ((SearchView) this).mUserQuery);\n         if (str3 != null) {\n             intent.putExtra(\"query\", str3);\n         }\n         if (str2 != null) {\n             intent.putExtra(\"intent_extra_data_key\", str2);\n         }\n         Bundle bundle = ((SearchView) this).mAppSearchData;\n         if (bundle != null) {\n             intent.putExtra(\"app_data\", bundle);\n         }\n         if (i != 0) {\n             intent.putExtra(\"action_key\", i);\n             intent.putExtra(\"action_msg\", str4);\n         }\n         intent.setComponent(((SearchView) this).mSearchable.getSearchActivity());\n         return intent;\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                726
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.115-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "9e17a669-4b42-411f-8d08-b8e98975ee4b",
              "value": "private Intent createVoiceAppSearchIntent(Intent intent, SearchableInfo searchableInfo) {\n         ComponentName searchActivity = searchableInfo.getSearchActivity();\n         Intent intent2 = new Intent(\"android.intent.action.SEARCH\");\n         intent2.setComponent(searchActivity);\n         PendingIntent activity = PendingIntent.getActivity(getContext(), 0, intent2, 1073741824);\n         Bundle bundle = new Bundle();\n         Bundle bundle2 = ((SearchView) this).mAppSearchData;\n         if (bundle2 != null) {\n             bundle.putParcelable(\"app_data\", bundle2);\n         }\n         Intent intent3 = new Intent(intent);\n         Resources resources = getResources();\n         String string = searchableInfo.getVoiceLanguageModeId() != 0 ? resources.getString(searchableInfo.getVoiceLanguageModeId()) : \"free_form\";\n         String string2 = searchableInfo.getVoicePromptTextId() != 0 ? resources.getString(searchableInfo.getVoicePromptTextId()) : null;\n         String string3 = searchableInfo.getVoiceLanguageId() != 0 ? resources.getString(searchableInfo.getVoiceLanguageId()) : null;\n         int voiceMaxResults = searchableInfo.getVoiceMaxResults() != 0 ? searchableInfo.getVoiceMaxResults() : 1;\n         intent3.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", string);\n         intent3.putExtra(\"android.speech.extra.PROMPT\", string2);\n         intent3.putExtra(\"android.speech.extra.LANGUAGE\", string3);\n         intent3.putExtra(\"android.speech.extra.MAX_RESULTS\", voiceMaxResults);\n         intent3.putExtra(\"calling_package\", searchActivity != null ? searchActivity.flattenToShortString() : null);\n         intent3.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT\", activity);\n         intent3.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT_BUNDLE\", bundle);\n         return intent3;\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                978
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.140-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "bb2b4b56-815a-4a63-85da-601f2d59cbbe",
              "value": "public final Intent zzb(Context context) {\n         if (((GmsClientSupervisor.zza) this).zzdr != null) {\n             return new Intent(((GmsClientSupervisor.zza) this).zzdr).setPackage(((GmsClientSupervisor.zza) this).zzds);\n         }\n         return new Intent().setComponent(((GmsClientSupervisor.zza) this).mComponentName);\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/common/internal/GmsClientSupervisor$zza.java",
              "file_line": [
                282
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.326-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1bbd09ab-97b3-46aa-9395-cbe193553008",
              "value": "public Cls3YJTRY7E7EF1269(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         View.OnClickListener onClickListener = new SearchView.5(this);\n         ((SearchView) this).mOnClickListener = onClickListener;\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         SearchView.7 r2 = new SearchView.7(this);\n         ((SearchView) this).mOnEditorActionListener = r2;\n         SearchView.8 r3 = new SearchView.8(this);\n         ((SearchView) this).mOnItemClickListener = r3;\n         SearchView.9 r4 = new SearchView.9(this);\n         ((SearchView) this).mOnItemSelectedListener = r4;\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray obtainStyledAttributes = TintTypedArray.obtainStyledAttributes(context, attributeSet, R.styleable.SearchView, i, 0);\n         LayoutInflater.from(context).inflate(obtainStyledAttributes.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         View findViewById2 = findViewById(R.id.search_plate);\n         ((SearchView) this).mSearchPlate = findViewById2;\n         View findViewById3 = findViewById(R.id.submit_area);\n         ((SearchView) this).mSubmitArea = findViewById3;\n         ImageView imageView = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mSearchButton = imageView;\n         ImageView imageView2 = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mGoButton = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mCloseButton = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mVoiceButton = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(R.id.search_mag_icon);\n         ((SearchView) this).mCollapsedIcon = imageView5;\n         ViewCompat.setBackground(findViewById2, obtainStyledAttributes.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(findViewById3, obtainStyledAttributes.getDrawable(R.styleable.SearchView_submitBackground));\n         imageView.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         imageView2.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_goIcon));\n         imageView3.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_closeIcon));\n         imageView4.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_voiceIcon));\n         imageView5.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(imageView, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = obtainStyledAttributes.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = obtainStyledAttributes.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         imageView.setOnClickListener(onClickListener);\n         imageView3.setOnClickListener(onClickListener);\n         imageView2.setOnClickListener(onClickListener);\n         imageView4.setOnClickListener(onClickListener);\n         findViewById.setOnClickListener(onClickListener);\n         findViewById.addTextChangedListener(((SearchView) this).mTextWatcher);\n         findViewById.setOnEditorActionListener(r2);\n         findViewById.setOnItemClickListener(r3);\n         findViewById.setOnItemSelectedListener(r4);\n         findViewById.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         findViewById.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(obtainStyledAttributes.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int dimensionPixelSize = obtainStyledAttributes.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (dimensionPixelSize != -1) {\n             setMaxWidth(dimensionPixelSize);\n         }\n         ((SearchView) this).mDefaultQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_queryHint);\n         int i2 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (i2 != -1) {\n             setImeOptions(i2);\n         }\n         int i3 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (i3 != -1) {\n             setInputType(i3);\n         }\n         setFocusable(obtainStyledAttributes.getBoolean(R.styleable.SearchView_android_focusable, true));\n         obtainStyledAttributes.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).mDropDownAnchor = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                660
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.513-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "121b8c18-c187-4e7b-b950-a8ad47a08ebf",
              "value": "private boolean ensureServiceBound(NotificationManagerCompat.SideChannelManager.ListenerRecord listenerRecord) {\n         if (listenerRecord.bound) {\n             return true;\n         }\n         listenerRecord.bound = ((NotificationManagerCompat.SideChannelManager) this).mContext.bindService(new Intent(\"android.support.BIND_NOTIFICATION_SIDE_CHANNEL\").setComponent(listenerRecord.componentName), this, 33);\n         if (listenerRecord.bound) {\n             listenerRecord.retryCount = 0;\n         } else {\n             Log.w(\"NotifManCompat\", \"Unable to bind to listener \" + listenerRecord.componentName);\n             ((NotificationManagerCompat.SideChannelManager) this).mContext.unbindService(this);\n         }\n         return listenerRecord.bound;\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/NotificationManagerCompat$SideChannelManager.java",
              "file_line": [
                134
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.166-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4fa64372-508f-49a4-a494-c05bbe842582",
              "value": "public static Intent zzs() {\n         Intent intent = new Intent(\"com.google.android.clockwork.home.UPDATE_ANDROID_WEAR_ACTION\");\n         intent.setPackage(\"com.google.android.wearable.app\");\n         return intent;\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/common/internal/zzg.java",
              "file_line": [
                147
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.413-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "167aadb3-3d31-474f-a2e7-3c9addf8d4be",
              "value": "public static Intent makeMainSelectorActivity(String str, String str2) {\n         if (Build.VERSION.SDK_INT >= 15) {\n             return Intent.makeMainSelectorActivity(str, str2);\n         }\n         Intent intent = new Intent(str);\n         intent.addCategory(str2);\n         return intent;\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/IntentCompat.java",
              "file_line": [
                45
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.201-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "12b179b5-6a24-42a2-9c49-89353aec821a",
              "value": "public static boolean isRequestPinShortcutSupported(Context context) {\n         if (Build.VERSION.SDK_INT >= 26) {\n             return ((ShortcutManager) context.getSystemService(ShortcutManager.class)).isRequestPinShortcutSupported();\n         }\n         if (ContextCompat.checkSelfPermission(context, \"com.android.launcher.permission.INSTALL_SHORTCUT\") != 0) {\n             return false;\n         }\n         for (ResolveInfo resolveInfo : context.getPackageManager().queryBroadcastReceivers(new Intent(\"com.android.launcher.action.INSTALL_SHORTCUT\"), 0)) {\n             String str = resolveInfo.activityInfo.permission;\n             if (TextUtils.isEmpty(str) || \"com.android.launcher.permission.INSTALL_SHORTCUT\".equals(str)) {\n                 return true;\n             }\n             while (r4.hasNext()) {\n             }\n         }\n         return false;\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/pm/ShortcutManagerCompat.java",
              "file_line": [
                448
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.232-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "90805d59-4cbd-4963-909e-fb1c9648ea3b",
              "value": "protected final void zza(String str) {\n         if (str == null || str.isEmpty()) {\n             ((zzfa) this).zza.zzat().zzf().zza(\"Install Referrer Reporter was called with invalid app package name\");\n             return;\n         }\n         ((zzfa) this).zza.zzau().zzg();\n         if (!zzb()) {\n             ((zzfa) this).zza.zzat().zzi().zza(\"Install Referrer Reporter is not available\");\n             return;\n         }\n         zzez zzezVar = new zzez(this, str);\n         ((zzfa) this).zza.zzau().zzg();\n         Intent intent = new Intent(\"com.google.android.finsky.BIND_GET_INSTALL_REFERRER_SERVICE\");\n         intent.setComponent(new ComponentName(\"com.android.vending\", \"com.google.android.finsky.externalreferrer.GetInstallReferrerService\"));\n         PackageManager packageManager = ((zzfa) this).zza.zzaw().getPackageManager();\n         if (packageManager == null) {\n             ((zzfa) this).zza.zzat().zzf().zza(\"Failed to obtain Package Manager to verify binding conditions for Install Referrer\");\n             return;\n         }\n         List<ResolveInfo> queryIntentServices = packageManager.queryIntentServices(intent, 0);\n         if (queryIntentServices == null || queryIntentServices.isEmpty()) {\n             ((zzfa) this).zza.zzat().zzi().zza(\"Play Service for fetching Install Referrer is unavailable on device\");\n             return;\n         }\n         ResolveInfo resolveInfo = queryIntentServices.get(0);\n         if (resolveInfo.serviceInfo != null) {\n             String str2 = resolveInfo.serviceInfo.packageName;\n             if (resolveInfo.serviceInfo.name == null || !\"com.android.vending\".equals(str2) || !zzb()) {\n                 ((zzfa) this).zza.zzat().zze().zza(\"Play Store version 8.3.73 or higher required for Install Referrer\");\n                 return;\n             }\n             try {\n                 ((zzfa) this).zza.zzat().zzk().zzb(\"Install Referrer Service is\", true != ConnectionTracker.getInstance().bindService(((zzfa) this).zza.zzaw(), new Intent(intent), zzezVar, 1) ? \"not available\" : \"available\");\n             } catch (Exception e) {\n                 ((zzfa) this).zza.zzat().zzb().zzb(\"Exception occurred while binding to Install Referrer Service\", e.getMessage());\n             }\n         }\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzfa.java",
              "file_line": [
                92
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.459-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d50c1497-4d45-48dd-936a-fd44ea777565",
              "value": "final void zzB() {\n         zzg();\n         zzb();\n         if (zzh()) {\n             return;\n         }\n         if (!zzD()) {\n             if (((zzge) this).zzx.zzc().zzy()) {\n                 return;\n             }\n             ((zzge) this).zzx.zzas();\n             List<ResolveInfo> queryIntentServices = ((zzge) this).zzx.zzaw().getPackageManager().queryIntentServices(new Intent().setClassName(((zzge) this).zzx.zzaw(), \"com.google.android.gms.measurement.AppMeasurementService\"), 65536);\n             if (queryIntentServices == null || queryIntentServices.size() <= 0) {\n                 ((zzge) this).zzx.zzat().zzb().zza(\"Unable to use remote or local measurement implementation. Please register the AppMeasurementService service in the app manifest\");\n                 return;\n             }\n             Intent intent = new Intent(\"com.google.android.gms.measurement.START\");\n             Context zzaw = ((zzge) this).zzx.zzaw();\n             ((zzge) this).zzx.zzas();\n             intent.setComponent(new ComponentName(zzaw, \"com.google.android.gms.measurement.AppMeasurementService\"));\n             ((zzjb) this).zza.zza(intent);\n             return;\n         }\n         ((zzjb) this).zza.zzc();\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/measurement/internal/zzjb.java",
              "file_line": [
                634
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.487-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1f408f72-efdb-4ee7-b115-c65ecad3476c",
              "value": "public ClsHLHXJ79MW83B4EY(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         View.OnClickListener onClickListener = new SearchView.5(this);\n         ((SearchView) this).mOnClickListener = onClickListener;\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         SearchView.7 r2 = new SearchView.7(this);\n         ((SearchView) this).mOnEditorActionListener = r2;\n         SearchView.8 r3 = new SearchView.8(this);\n         ((SearchView) this).mOnItemClickListener = r3;\n         SearchView.9 r4 = new SearchView.9(this);\n         ((SearchView) this).mOnItemSelectedListener = r4;\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray obtainStyledAttributes = TintTypedArray.obtainStyledAttributes(context, attributeSet, R.styleable.SearchView, i, 0);\n         LayoutInflater.from(context).inflate(obtainStyledAttributes.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         View findViewById2 = findViewById(R.id.search_plate);\n         ((SearchView) this).mSearchPlate = findViewById2;\n         View findViewById3 = findViewById(R.id.submit_area);\n         ((SearchView) this).mSubmitArea = findViewById3;\n         ImageView imageView = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mSearchButton = imageView;\n         ImageView imageView2 = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mGoButton = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mCloseButton = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mVoiceButton = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(R.id.search_mag_icon);\n         ((SearchView) this).mCollapsedIcon = imageView5;\n         ViewCompat.setBackground(findViewById2, obtainStyledAttributes.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(findViewById3, obtainStyledAttributes.getDrawable(R.styleable.SearchView_submitBackground));\n         imageView.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         imageView2.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_goIcon));\n         imageView3.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_closeIcon));\n         imageView4.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_voiceIcon));\n         imageView5.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(imageView, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = obtainStyledAttributes.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = obtainStyledAttributes.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         imageView.setOnClickListener(onClickListener);\n         imageView3.setOnClickListener(onClickListener);\n         imageView2.setOnClickListener(onClickListener);\n         imageView4.setOnClickListener(onClickListener);\n         findViewById.setOnClickListener(onClickListener);\n         findViewById.addTextChangedListener(((SearchView) this).mTextWatcher);\n         findViewById.setOnEditorActionListener(r2);\n         findViewById.setOnItemClickListener(r3);\n         findViewById.setOnItemSelectedListener(r4);\n         findViewById.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         findViewById.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(obtainStyledAttributes.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int dimensionPixelSize = obtainStyledAttributes.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (dimensionPixelSize != -1) {\n             setMaxWidth(dimensionPixelSize);\n         }\n         ((SearchView) this).mDefaultQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_queryHint);\n         int i2 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (i2 != -1) {\n             setImeOptions(i2);\n         }\n         int i3 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (i3 != -1) {\n             setInputType(i3);\n         }\n         setFocusable(obtainStyledAttributes.getBoolean(R.styleable.SearchView_android_focusable, true));\n         obtainStyledAttributes.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).mDropDownAnchor = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                681
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.577-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3f05adc7-6cc6-4b24-91c5-df817822ad01",
              "value": "public static boolean requestPinShortcut(Context context, ShortcutInfoCompat shortcutInfoCompat, IntentSender intentSender) {\n         if (Build.VERSION.SDK_INT >= 26) {\n             return ((ShortcutManager) context.getSystemService(ShortcutManager.class)).requestPinShortcut(shortcutInfoCompat.toShortcutInfo(), intentSender);\n         }\n         if (ShortcutManagerCompat.isRequestPinShortcutSupported(context)) {\n             Intent addToIntent = shortcutInfoCompat.addToIntent(new Intent(\"com.android.launcher.action.INSTALL_SHORTCUT\"));\n             if (intentSender == null) {\n                 context.sendBroadcast(addToIntent);\n                 return true;\n             }\n             context.sendOrderedBroadcast(addToIntent, null, new ShortcutManagerCompat.1(intentSender), null, -1, null, null);\n             return true;\n         }\n         return false;\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/pm/ShortcutManagerCompat.java",
              "file_line": [
                620
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.258-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3dda84ec-cfa4-4f60-8967-2c942f7e87cf",
              "value": "public final void zace() {\n         Intent intent = new Intent(\"com.google.android.gms.common.images.LOAD_IMAGE\");\n         intent.putExtra(\"com.google.android.gms.extras.uri\", ((ImageManager.ImageReceiver) this).mUri);\n         intent.putExtra(\"com.google.android.gms.extras.resultReceiver\", (Parcelable) this);\n         intent.putExtra(\"com.google.android.gms.extras.priority\", 3);\n         ImageManager.zab(((ImageManager.ImageReceiver) this).zamr).sendBroadcast(intent);\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/common/images/ImageManager$ImageReceiver.java",
              "file_line": [
                146
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.301-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ec745856-5641-4359-9863-7c184811040f",
              "value": "public static Intent zza(String str, String str2) {\n         Intent intent = new Intent(\"android.intent.action.VIEW\");\n         Uri.Builder appendQueryParameter = Uri.parse(\"market:\n         if (!TextUtils.isEmpty(str2)) {\n             appendQueryParameter.appendQueryParameter(\"pcampaignid\", str2);\n         }\n         intent.setData(appendQueryParameter.build());\n         intent.setPackage(\"com.android.vending\");\n         intent.addFlags(524288);\n         return intent;\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/common/internal/zzg.java",
              "file_line": [
                59
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.352-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5168b6eb-b7f8-4d9a-938e-c68eaf9dee3e",
              "value": "public static Intent zzg(String str) {\n         Uri fromParts = Uri.fromParts(\"package\", str, null);\n         Intent intent = new Intent(\"android.settings.APPLICATION_DETAILS_SETTINGS\");\n         intent.setData(fromParts);\n         return intent;\n     }",
              "vulnerability_id": "efbdd981-1e52-4306-9f3f-f776a2bc34d0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/google/android/gms/common/internal/zzg.java",
              "file_line": [
                131
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:24.390-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "f801b557-bf08-48e4-90a3-5252938049c0",
          "title": "Firebase Database Detect",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team discovered a potential security concern in the Firebase Database implementation within the <b>Challenge 3</b> application. Firebase Database, a real-time NoSQL cloud database offered by Google, enables developers to store and sync data across users and devices. However, if Firebase Database is not securely implemented, it could expose the application to various security vulnerabilities.</p>\n<p>The code snippet below demonstrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends securing the Firebase Database implementation with several key measures:</p>\n<p>Strong Authentication: Implement strong authentication mechanisms to control access to the database effectively.</p>\n<p>Input Validation: Rigorously validate all inputs to prevent injection attacks or unauthorized data manipulation.</p>\n<p>Access Controls: Establish strict access controls to regulate who can access or modify the database.</p>\n<p>Data Encryption: Employ data encryption to protect sensitive information both in transit and at rest.</p>\n<p>Robust Error Handling: Implement robust error handling to prevent leakage of sensitive information through error messages.</p>\n<p>Regular Security Audits: Conduct regular security audits of the database to identify and address potential vulnerabilities.</p>\n<p>Update Firebase SDK Regularly: Keep the Firebase SDK updated to ensure you have the latest security patches and enhancements.</p>\n<p>Implementing these measures will enhance the security of the Firebase Database, safeguard user data, and maintain the integrity of the application.</p>\n",
              "impact": "<p>If the Firebase Database implementation is not adequately secured, it can become vulnerable to exploitation by attackers. They may perform unauthorized data access, manipulation, or deletion. As a result, sensitive user information or critical application data could be exposed, potentially leading to significant data breaches or unauthorized actions. Such vulnerabilities pose a substantial threat to user privacy and the integrity of the application.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió una posible preocupación de seguridad en la implementación de Firebase Database dentro de la aplicación <b>Challenge 3</b>. Firebase Database, una base de datos en la nube NoSQL en tiempo real ofrecida por Google, permite a los desarrolladores almacenar y sincronizar datos entre usuarios y dispositivos. Sin embargo, si Firebase Database no se implementa de manera segura, podría exponer la aplicación a varias vulnerabilidades de seguridad.</p>\n<p>El fragmento de código a continuación muestra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda asegurar la implementación de Firebase Database con varias medidas clave:</p>\n<p>Autenticación Robusta: Implementar mecanismos de autenticación fuertes para controlar el acceso a la base de datos de manera efectiva.</p>\n<p>Validación de Entradas: Validar rigurosamente todas las entradas para prevenir ataques de inyección o manipulación no autorizada de datos.</p>\n<p>Controles de Acceso: Establecer controles de acceso estrictos para regular quién puede acceder o modificar la base de datos.</p>\n<p>Encriptación de Datos: Emplear encriptación de datos para proteger la información sensible tanto en tránsito como en reposo.</p>\n<p>Manejo de Errores Robusto: Implementar un manejo de errores robusto para evitar la filtración de información sensible a través de mensajes de error.</p>\n<p>Auditorías de Seguridad Regulares: Realizar auditorías de seguridad regulares de la base de datos para identificar y abordar posibles vulnerabilidades.</p>\n<p>Actualizar Regularmente el SDK de Firebase: Mantener actualizado el SDK de Firebase para asegurar las últimas mejoras y parches de seguridad.</p>\n<p>La implementación de estas medidas mejorará la seguridad de Firebase Database, protegerá los datos de los usuarios y mantendrá la integridad de la aplicación.</p>\n",
              "impact": "<p>Si la implementación de Firebase Database no está adecuadamente asegurada, puede volverse vulnerable a la explotación por parte de atacantes. Ellos podrían realizar acceso, manipulación o eliminación de datos no autorizados. Como resultado, la información sensible de los usuarios o datos críticos de la aplicación podrían quedar expuestos, lo que podría conducir a violaciones de datos significativas o acciones no autorizadas. Tales vulnerabilidades representan una amenaza sustancial para la privacidad del usuario y la integridad de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Best practices for Cloud Firestore  |  Firebase",
              "url": "https://firebase.google.com/docs/firestore/best-practices"
            },
            {
              "label": "Firebase security checklist",
              "url": "https://firebase.google.com/support/guides/security-checklist"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-AUTH-1",
            "maswe": "MASWE-0005"
          },
          "evidences": [
            {
              "id": "1feb7c49-87e7-40e3-80c8-ab1cf8a73d18",
              "value": "throw new DatabaseException(\"Failed to get FirebaseDatabase instance: Can't determine Firebase Database URL. Be sure to include a Project ID in your configuration.\");\n            }\n            databaseUrl = \"https://\" + firebaseApp.getOptions().getProjectId() + \"-default-rtdb.firebaseio.com\";\n        }\n        return getInstance(firebaseApp, databaseUrl);",
              "vulnerability_id": "f801b557-bf08-48e4-90a3-5252938049c0",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/sources/com/google/firebase/database/FirebaseDatabase.java",
              "file_line": [
                52
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:56:27.493-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        }
      ],
      "severityDistribution": {
        "high": 53.33,
        "info": 20,
        "medium": 20,
        "low": 6.67
      },
      "severityCount": {
        "high": 8,
        "info": 3,
        "medium": 3,
        "low": 1
      },
      "properties": {
        "MIN_SDK": 23,
        "MD5": "b0aa2bf020fc5a444afa42456fd85b86",
        "SHA1": "f9f87429e9444821a2e46609d6312bf21b8c21a0",
        "SHA256": "6d74a5c899ec80e2d448ed5a8bd5c2004812487ab9c69276547143c90886b1ac",
        "VERSION": "1.0.0",
        "MAIN_ACTIVITY": "com.just.mobile.sec.challenge3.SplashActivity",
        "ANDROID_VERSION_CODE": "1.0.0",
        "FRAMEWORK": "Native (Java / Kotlin)",
        "BINARY_PROTECTIONS": null
      },
      "permissions": [
        "android.permission.INTERNET",
        "android.permission.ACCESS_NETWORK_STATE",
        "android.permission.WAKE_LOCK",
        "com.google.android.finsky.permission.BIND_GET_INSTALL_REFERRER_SERVICE"
      ],
      "components": [
        {
          "name": "com.just.mobile.sec.challenge3.SuccessfullySingUpActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.just.mobile.sec.challenge3.SplashActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": true
        },
        {
          "name": "com.just.mobile.sec.challenge3.MainActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.gms.common.api.GoogleApiActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.gms.measurement.AppMeasurementReceiver",
          "type": "R",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.firebase.components.ComponentDiscoveryService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.gms.measurement.AppMeasurementService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.android.gms.measurement.AppMeasurementJobService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.google.firebase.provider.FirebaseInitProvider",
          "type": "P",
          "is_browseable": false,
          "is_exported": false
        }
      ],
      "protections": [
        {
          "type": "anti_vm",
          "name": "Emulation Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": [
            {
              "name": "Build.FINGERPRINT",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "Build.HARDWARE",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "Build.MANUFACTURER",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "Build.MODEL",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "Build.PRODUCT",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "Build.TAGS",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "possible ro.secure",
              "files": [
                "classes.dex"
              ]
            }
          ]
        },
        {
          "type": "anti_root",
          "name": "Root Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": [
            {
              "name": "Custom Rom",
              "files": [
                "classes.dex"
              ]
            }
          ]
        },
        {
          "type": "has_xposed_detection",
          "name": "Xposed Detection",
          "category": [
            "MASVS-RESILIENCE-4"
          ],
          "protectors": [
            {
              "name": "Xposed Binary",
              "files": [
                "classes.dex"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": 2,
      "status": "COMPLETED",
      "start_at": "2025-06-14T00:00:00.000-03:00",
      "end_at": "2025-06-15T23:59:59.999-03:00",
      "created_at": "2025-06-14T20:54:01.024-03:00",
      "updated_at": "2025-06-14T20:55:44.266-03:00",
      "platform": "ANDROID",
      "services": {
        "id": 0,
        "name": "Mobile Penetration Testing"
      },
      "assessment": {
        "status": "COMPLETED",
        "id": "eddcee17-ef1a-4fa3-9816-336bfa96e75b",
        "name": null,
        "company_id": 1,
        "company": {
          "id": 1,
          "name": "Just Mobile Security"
        }
      },
      "scans": [
        {
          "id": "164f12c1-b2fc-41cf-853e-f79e9bdf7539",
          "aat_version": "0.1.0-beta-2",
          "scan_status": "FINISHED",
          "created_at": "2025-06-14T20:54:01.285-03:00",
          "updated_at": "2025-06-14T20:55:44.248-03:00",
          "type": "SAST",
          "app_id": "df78dd52-cd1f-4942-8c6a-7e183ff770b3",
          "assessment_service_id": 2,
          "app": {
            "id": "df78dd52-cd1f-4942-8c6a-7e183ff770b3",
            "name": "Challenge 2",
            "description": "com.just.mobile.sec.challenge2",
            "created_at": "2025-06-14T20:54:01.281-03:00",
            "updated_at": "2025-06-14T20:54:16.406-03:00",
            "version": null,
            "icon": {
              "url": "http://storage.fakedomain.com/bucket-storage/assessments/eddcee17-ef1a-4fa3-9816-336bfa96e75b/service/2/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T012947Z&X-Amz-Expires=600&X-Amz-Signature=36c81de3c7e80c7b118a794169eeb831e3c336c9ad5c27d2a6caf0f96830ca02&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
              "name": "assessments/eddcee17-ef1a-4fa3-9816-336bfa96e75b/service/2/icon.png",
              "extname": "png",
              "size": 5814,
              "mimeType": "image/png"
            }
          }
        }
      ],
      "summary": {
        "appId": "df78dd52-cd1f-4942-8c6a-7e183ff770b3",
        "name": "Challenge 2",
        "description": "com.just.mobile.sec.challenge2",
        "platform": "ANDROID",
        "version": "",
        "createdAt": "2025-06-14T20:54:01.285-03:00",
        "finishedAt": "2025-06-14T20:55:44.248-03:00",
        "statusId": 5,
        "status": "Incomplete",
        "duration": {
          "days": 0,
          "hours": 0,
          "minutes": 1,
          "seconds": 42,
          "milliseconds": 963,
          "human": "2 minutes"
        },
        "file": {
          "name": "assessments/eddcee17-ef1a-4fa3-9816-336bfa96e75b/service/2/Challenge_2.apk",
          "size": "2.48 MB"
        },
        "icon": "http://storage.fakedomain.com/bucket-storage/assessments/eddcee17-ef1a-4fa3-9816-336bfa96e75b/service/2/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T033833Z&X-Amz-Expires=600&X-Amz-Signature=56c5ae7fcb1fa1d7d10781141d4738a1d497b0ea0f3e8454b478dc09d9479c94&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
        "start_date": "2025-06-14T00:00:00.000-03:00",
        "end_date": "2025-06-15T23:59:59.999-03:00"
      },
      "vulnerabilities": [
        {
          "vulnerabilityId": "49701b46-1040-454c-bea5-dc7fe9883036",
          "title": "External Result Receiver",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The vulnerability known as &quot;External Result Receiver&quot; in Android involves a significant security risk where exported components improperly handle ResultReceiver objects passed via intents. This issue allows external entities to send intents with ResultReceiver objects to the <b>Challenge 2</b> application, which could then be manipulated to execute unintended actions or retrieve sensitive information. The core vulnerability arises from the application&#39;s exported components, which do not adequately validate or restrict the incoming ResultReceiver objects, potentially leading to unauthorized access or control over the application&#39;s internal states and functionalities. This vulnerability underscores the need for strict validation and limitation of exported components in handling intent-based communications. \nThe following code snippet shows the insecure implementation</p>\n",
              "remediation": "<p>The assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Restrict Component Exportation: Modify the application's manifest to ensure that components intended to receive ResultReceiver objects are not exported unless absolutely necessary. Use the android:exported=false attribute to prevent unintended external access.\n</li>\n<li>Implement Intent Validation: Enhance the validation process for incoming intents within the application. Verify any ResultReceiver received through intents to ensure it originates from a trusted source, and confirm that its usage aligns with secure and intended operational parameters.</li>\n</ul>\n",
              "impact": "<p>An attacker can exploit the &quot;External Result Receiver&quot; vulnerability to execute unintended actions within the application or access sensitive information by manipulating ResultReceiver objects sent via intents. This could lead to unauthorized actions being performed, such as altering application data or behavior, which might compromise the app’s functionality and user data security. The ability to intercept and modify these communications also raises concerns about the integrity and confidentiality of the data processed by the application, potentially leading to further security breaches within the system.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>La vulnerabilidad conocida como &quot;External Result Receiver&quot; en Android implica un riesgo de seguridad significativo, ya que los componentes importados controlan inadecuadamente los objetos ResultReceiver que se envían a través de las intenciones. Este problema permite que entidades externas envíen intenciones con objetos ResultReceiver a la aplicación <b>Challenge 2</b>, que luego podrían manipularse para llevar a cabo acciones no deseadas o recuperar información sensible. La vulnerabilidad surge de los componentes exportados de la aplicación, que no validan o limitan adecuadamente los objetos ResultReceiver entrantes. Esto podría facilitar el acceso no autorizado y la pérdida de control de los estados y funcionamientos internos de la aplicación. Esta vulnerabilidad resalta la necesidad de una validación y limitación estrictas de los componentes exportados en la comunicación basada en intenciones.\nEl siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Restringir la exportación de componentes: modifique el manifiesto de la aplicación para garantizar que los componentes destinados a recibir objetos ResultReceiver no se exporten a menos que sea absolutamente necesario. Utilice el atributo android:exported=false para evitar el acceso externo no deseado.\n</li>\n<li>Implementar la validación de intenciones: mejore el proceso de validación de intenciones entrantes dentro de la aplicación. Verifique cualquier ResultReceiver recibido a través de intenciones para asegurarse de que provenga de una fuente confiable y confirmar que su uso se alinea con los parámetros operativos seguros previstos.</li>\n</ul>\n",
              "impact": "<p>Un atacante puede aprovechar la vulnerabilidad &quot;External Result Receiver&quot; para llevar a cabo acciones no deseadas dentro de la aplicación o acceder a información sensible manipulando objetos ResultReceiver enviados mediante intenciones. Esto podría dar lugar a que se realicen acciones no autorizadas, como alterar los datos o el comportamiento de la aplicación, y podría comprometer la funcionalidad de la aplicación y la seguridad de los datos de los usuarios. La capacidad de interceptar y modificar estas comunicaciones pone en riesgo la integridad y confidencialidad de los datos procesados por la aplicación y puede generar más violaciones de seguridad dentro del sistema.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "ResultReceiver | Android Developers",
              "url": "https://developer.android.com/reference/android/os/ResultReceiver#send(int,%20android.os.Bundle)"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0084"
          },
          "evidences": [
            {
              "id": "1efd4c2d-b106-4092-bb57-ba8fd32faaf7",
              "value": "public ShareCompat.IntentBuilder addStream(Uri uri) {\n         Uri uri2 = (Uri) ((ShareCompat.IntentBuilder) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n         ArrayList arrayList = ((ShareCompat.IntentBuilder) this).mStreams;\n         if (arrayList == null && uri2 == null) {\n             return setStream(uri);\n         }\n         if (arrayList == null) {\n             ((ShareCompat.IntentBuilder) this).mStreams = new ArrayList();\n         }\n         if (uri2 != null) {\n             ((ShareCompat.IntentBuilder) this).mIntent.removeExtra(\"android.intent.extra.STREAM\");\n             ((ShareCompat.IntentBuilder) this).mStreams.add(uri2);\n         }\n         ((ShareCompat.IntentBuilder) this).mStreams.add(uri);\n         return this;\n     }",
              "vulnerability_id": "49701b46-1040-454c-bea5-dc7fe9883036",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat$IntentBuilder.java",
              "file_line": [
                389
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.829-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "34b36606-d99e-412b-891b-6a3b152da99b",
              "value": "public static NetworkInfo getNetworkInfoFromBroadcast(ConnectivityManager connectivityManager, Intent intent) {\n         NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(\"networkInfo\");\n         if (networkInfo != null) {\n             return connectivityManager.getNetworkInfo(networkInfo.getType());\n         }\n         return null;\n     }",
              "vulnerability_id": "49701b46-1040-454c-bea5-dc7fe9883036",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/net/ConnectivityManagerCompat.java",
              "file_line": [
                38
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.924-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4b97296d-d8d1-488b-a27d-1271ab4a2d60",
              "value": "public static Uri getReferrer(Activity activity) {\n         if (Build.VERSION.SDK_INT >= 22) {\n             return activity.getReferrer();\n         }\n         Intent intent = activity.getIntent();\n         Uri uri = (Uri) intent.getParcelableExtra(\"android.intent.extra.REFERRER\");\n         if (uri != null) {\n             return uri;\n         }\n         String stringExtra = intent.getStringExtra(\"android.intent.extra.REFERRER_NAME\");\n         if (stringExtra != null) {\n             return Uri.parse(stringExtra);\n         }\n         return null;\n     }",
              "vulnerability_id": "49701b46-1040-454c-bea5-dc7fe9883036",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ActivityCompat.java",
              "file_line": [
                112
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.799-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "e74b6553-4bd1-496a-9058-17edf0cf91ce",
              "value": "public Uri getStream() {\n         return (Uri) ((ShareCompat.IntentReader) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n     }",
              "vulnerability_id": "49701b46-1040-454c-bea5-dc7fe9883036",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat$IntentReader.java",
              "file_line": [
                519
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.855-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6531ec25-69e3-4198-8cf6-070d2e7196f3",
              "value": "public Uri getStream(int i) {\n         if (((ShareCompat.IntentReader) this).mStreams == null && isMultipleShare()) {\n             ((ShareCompat.IntentReader) this).mStreams = ((ShareCompat.IntentReader) this).mIntent.getParcelableArrayListExtra(\"android.intent.extra.STREAM\");\n         }\n         ArrayList arrayList = ((ShareCompat.IntentReader) this).mStreams;\n         if (arrayList != null) {\n             return (Uri) arrayList.get(i);\n         }\n         if (i == 0) {\n             return (Uri) ((ShareCompat.IntentReader) this).mIntent.getParcelableExtra(\"android.intent.extra.STREAM\");\n         }\n         throw new IndexOutOfBoundsException(\"Stream items available: \" + getStreamCount() + \" index requested: \" + i);\n     }",
              "vulnerability_id": "49701b46-1040-454c-bea5-dc7fe9883036",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat$IntentReader.java",
              "file_line": [
                574
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.873-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "c41a355f-a986-4b65-a37e-be676408726e",
              "value": "static ComponentName getCallingActivity(Intent intent) {\n         ComponentName componentName = (ComponentName) intent.getParcelableExtra(\"androidx.core.app.EXTRA_CALLING_ACTIVITY\");\n         return componentName == null ? (ComponentName) intent.getParcelableExtra(\"android.support.v4.app.EXTRA_CALLING_ACTIVITY\") : componentName;\n     }",
              "vulnerability_id": "49701b46-1040-454c-bea5-dc7fe9883036",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat.java",
              "file_line": [
                204
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.889-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "0bdc0609-7af7-42b6-9d80-a884b453c49d",
              "value": "static boolean handlePerformPrivateCommand(String str, Bundle bundle, InputConnectionCompat.OnCommitContentListener onCommitContentListener) {\n         boolean z;\n         ResultReceiver resultReceiver;\n         ?? r0 = 0;\n         r0 = 0;\n         if (bundle == null) {\n             return false;\n         }\n         if (TextUtils.equals(\"androidx.core.view.inputmethod.InputConnectionCompat.COMMIT_CONTENT\", str)) {\n             z = false;\n         } else if (!TextUtils.equals(\"android.support.v13.view.inputmethod.InputConnectionCompat.COMMIT_CONTENT\", str)) {\n             return false;\n         } else {\n             z = true;\n         }\n         try {\n             resultReceiver = (ResultReceiver) bundle.getParcelable(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_RESULT_RECEIVER\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_RESULT_RECEIVER\");\n             try {\n                 Uri uri = (Uri) bundle.getParcelable(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_URI\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_URI\");\n                 ClipDescription clipDescription = (ClipDescription) bundle.getParcelable(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_DESCRIPTION\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_DESCRIPTION\");\n                 Uri uri2 = (Uri) bundle.getParcelable(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_LINK_URI\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_LINK_URI\");\n                 int i = bundle.getInt(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_FLAGS\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_FLAGS\");\n                 Bundle bundle2 = (Bundle) bundle.getParcelable(z ? \"android.support.v13.view.inputmethod.InputConnectionCompat.CONTENT_OPTS\" : \"androidx.core.view.inputmethod.InputConnectionCompat.CONTENT_OPTS\");\n                 if (uri != null && clipDescription != null) {\n                     r0 = onCommitContentListener.onCommitContent(new InputContentInfoCompat(uri, clipDescription, uri2), i, bundle2);\n                 }\n                 if (resultReceiver != 0) {\n                     resultReceiver.send(r0, null);\n                 }\n                 return r0;\n             } catch (Throwable th) {\n                 th = th;\n                 if (resultReceiver != 0) {\n                     resultReceiver.send(0, null);\n                 }\n                 throw th;\n             }\n         } catch (Throwable th2) {\n             th = th2;\n             resultReceiver = 0;\n         }\n     }",
              "vulnerability_id": "49701b46-1040-454c-bea5-dc7fe9883036",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/view/inputmethod/InputConnectionCompat.java",
              "file_line": [
                496
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.943-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "fca78dde-f0bf-4ac3-8f75-3361b96a76ed",
          "title": "Android Start Internal Components",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Challenge 2</b> may improperly start internal components (activities or services) via implicit intents, potentially exposing sensitive functionality to unauthorized applications.</p>\n<p>Android applications often use methods like startActivity(), startActivityForResult(), and startService() to launch internal components. If these methods handle unvalidated intents, an attacker could craft a malicious intent to trigger unintended behaviors, interact with private components, or manipulate application logic.</p>\n<p>Additionally, if getParcelableExtra() is used without strict validation, an attacker could inject a malformed or unauthorized Parcelable object, potentially leading to unintended data processing or security risks.</p>\n",
              "remediation": "<p>The assessment team recommends the following mitigations to reduce the risks associated with insecure component invocation:</p>\n<ul>\n<li>Use explicit intents whenever possible: Restrict inter-component communication to explicitly defined targets to prevent unintended access by other applications.</li>\n<li>Validate all incoming intents: Ensure that every received intent is checked for its origin, expected parameters, and content integrity before processing.</li>\n<li>Restrict exported components: In the AndroidManifest.xml file, set android:exported=\"false\" for components that do not need to be accessed by external applications.</li>\n<li>Apply permission-based access control: If an internal component must be accessible externally, enforce strict access control via custom permissions (android:permission) to limit who can interact with it.</li>\n<li>Sanitize getParcelableExtra() inputs: Ensure that only expected Parcelable objects are processed, rejecting unexpected or malformed inputs.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit this issue to:</p>\n<ul>\n<li>Trigger unintended application behavior: If an internal component (such as an activity or service) is started improperly, it might perform unintended actions, such as navigating to a restricted screen or executing a function that was meant to be internal.</li>\n<li>Access sensitive data through exposed components: If an internal activity or service is unintentionally accessible, an attacker may extract sensitive information by interacting with it in ways not originally intended by the developers.</li>\n<li>Manipulate inter-component communication: If the application relies on intents to exchange data between components, an attacker might craft a malicious intent to manipulate this communication, leading to incorrect processing of user data or system functions.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Challenge 2</b> puede iniciar incorrectamente componentes internos (actividades o servicios) a través de intenciones implícitas, exponiendo potencialmente funcionalidades confidenciales a aplicaciones no autorizadas.</p>\n<p>Las aplicaciones de Android suelen utilizar métodos como startActivity(), startActivityForResult() y startService() para iniciar componentes internos. Si estos métodos manejan intenciones no validadas, un atacante podría crear una intención maliciosa para desencadenar comportamientos no deseados, interactuar con componentes privados o manipular la lógica de la aplicación.</p>\n<p>Además, si se utiliza getParcelableExtra() sin una validación estricta, un atacante podría inyectar un objeto Parcelable con formato incorrecto o no autorizado, lo que podría provocar un procesamiento de datos no deseado o riesgos de seguridad.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda las siguientes mitigaciones para reducir los riesgos asociados con la invocación de componentes inseguros:</p>\n<ul>\n<li>Utilice intenciones explícitas siempre que sea posible: restrinja la comunicación entre componentes a objetivos definidos explícitamente para evitar el acceso no deseado de otras aplicaciones.</li>\n<li>Validar todos los intents entrantes: asegúrese de que se verifique el origen, los parámetros esperados y la integridad del contenido de cada intent recibido antes de procesarlo.</li>\n<li>Restringir los componentes exportados: en el archivo AndroidManifest.xml, configure android:exported=\"false\" para los componentes a los que no es necesario acceder mediante aplicaciones externas.</li>\n<li>Aplique control de acceso basado en permisos: si un componente interno debe ser accesible externamente, aplique un control de acceso estricto a través de permisos personalizados (android:permiso) para limitar quién puede interactuar con él.</li>\n<li>Desinfectar las entradas getParcelableExtra(): asegúrese de que solo se procesen los objetos Parcelable esperados, rechazando las entradas inesperadas o con formato incorrecto.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar este problema para:</p>\n<ul>\n<li>Desencadenar un comportamiento no deseado de la aplicación: si un componente interno (como una actividad o servicio) se inicia incorrectamente, podría realizar acciones no deseadas, como navegar a una pantalla restringida o ejecutar una función que estaba destinada a ser interna.</li>\n<li>Acceder a datos confidenciales a través de componentes expuestos: si se puede acceder involuntariamente a una actividad o servicio interno, un atacante puede extraer información confidencial interactuando con ella de maneras no previstas originalmente por los desarrolladores.</li>\n<li>Manipular la comunicación entre componentes: si la aplicación se basa en intentos de intercambiar datos entre componentes, un atacante podría idear una intención maliciosa para manipular esta comunicación, lo que llevaría a un procesamiento incorrecto de los datos del usuario o de las funciones del sistema.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#intents"
            },
            {
              "label": "Intent Redirection | Security | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/intent-redirection?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "84280e05-8732-40c0-b8d2-3da753349aa2",
              "value": "public static void startActivityForResult(Activity activity, Intent intent, int i, Bundle bundle) {\n         if (Build.VERSION.SDK_INT >= 16) {\n             activity.startActivityForResult(intent, i, bundle);\n         } else {\n             activity.startActivityForResult(intent, i);\n         }\n     }",
              "vulnerability_id": "fca78dde-f0bf-4ac3-8f75-3361b96a76ed",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ActivityCompat.java",
              "file_line": [
                437
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.728-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "737b684e-8146-48b4-b22d-b74abd22e4ca",
              "value": "public void startChooser() {\n         ((ShareCompat.IntentBuilder) this).mContext.startActivity(createChooserIntent());\n     }",
              "vulnerability_id": "fca78dde-f0bf-4ac3-8f75-3361b96a76ed",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/ShareCompat$IntentBuilder.java",
              "file_line": [
                834
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.746-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "e77094cd-2c51-43f6-8fed-bc3af56cf062",
          "title": "Use of External Storage with Media Types",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Challenge 2</b> processes media files using external storage. External storage in Android is publicly accessible, meaning any application with the necessary permissions can read or modify files stored there. If sensitive data is stored or handled insecurely in external storage, the application may be exposed to security risks.</p>\n",
              "remediation": "<p>The assessment team recommends storing sensitive media files in internal storage whenever possible to prevent unauthorized access. Applications targeting Android 10 (API level 29) and above should implement scoped storage to restrict access to external storage. Additionally, it is essential to validate and sanitize files read from external storage to prevent injection attacks and to limit the use of permissions such as READ_EXTERNAL_STORAGE and WRITE_EXTERNAL_STORAGE to only essential cases.</p>\n",
              "impact": "<p>Improper use of external storage can lead to:</p>\n<ul>\n<li>Data Tampering: Malicious applications can modify media files stored in external storage, potentially altering their content.</li>\n<li>Data Leakage: Sensitive information stored in external storage may be accessed by unauthorized applications.</li>\n<li>Code Injection: If the application processes media files from external storage without validation, an attacker could introduce malicious payloads.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Challenge 2</b> procesa archivos multimedia utilizando almacenamiento externo. El almacenamiento externo en Android es de acceso público, lo que significa que cualquier aplicación con los permisos necesarios puede leer o modificar los archivos almacenados allí. Si los datos confidenciales se almacenan o manejan de manera insegura en un almacenamiento externo, la aplicación puede quedar expuesta a riesgos de seguridad.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda almacenar archivos multimedia confidenciales en un almacenamiento interno siempre que sea posible para evitar el acceso no autorizado. Las aplicaciones destinadas a Android 10 (nivel de API 29) y superiores deben implementar almacenamiento con alcance para restringir el acceso al almacenamiento externo. Además, es esencial validar y desinfectar los archivos leídos desde el almacenamiento externo para evitar ataques de inyección y limitar el uso de permisos como READ_EXTERNAL_STORAGE y WRITE_EXTERNAL_STORAGE solo a casos esenciales.</p>\n",
              "impact": "<p>El uso inadecuado del almacenamiento externo puede provocar:</p>\n<ul>\n<li>Manipulación de datos: las aplicaciones maliciosas pueden modificar archivos multimedia almacenados en un almacenamiento externo, alterando potencialmente su contenido.</li>\n<li>Fuga de datos: aplicaciones no autorizadas pueden acceder a la información confidencial almacenada en un almacenamiento externo.</li>\n<li>Inyección de código: si la aplicación procesa archivos multimedia desde un almacenamiento externo sin validación, un atacante podría introducir cargas útiles maliciosas.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#external-storage"
            },
            {
              "label": "Sensitive Data Stored in External Storage | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sensitive-data-external-storage"
            },
            {
              "label": "MASTG-TEST-0201: Runtime Use of APIs to Access External Storage | OWASP Mobile Application Security",
              "url": "https://mas.owasp.org/MASTG/tests-beta/android/MASVS-STORAGE/MASTG-TEST-0201/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "6df665a3-3def-48c5-9cca-b2c0677b5205",
              "value": "Cursor getSearchManagerSuggestions(SearchableInfo searchableInfo, String str, int i) {\n         String suggestAuthority;\n         String[] strArr = null;\n         if (searchableInfo == null || (suggestAuthority = searchableInfo.getSuggestAuthority()) == null) {\n             return null;\n         }\n         Uri.Builder fragment = new Uri.Builder().scheme(\"content\").authority(suggestAuthority).query(\"\").fragment(\"\");\n         String suggestPath = searchableInfo.getSuggestPath();\n         if (suggestPath != null) {\n             fragment.appendEncodedPath(suggestPath);\n         }\n         fragment.appendPath(\"search_suggest_query\");\n         String suggestSelection = searchableInfo.getSuggestSelection();\n         if (suggestSelection != null) {\n             strArr = new String[]{str};\n         } else {\n             fragment.appendPath(str);\n         }\n         String[] strArr2 = strArr;\n         if (i > 0) {\n             fragment.appendQueryParameter(\"limit\", String.valueOf(i));\n         }\n         return ((SuggestionsAdapter) this).mContext.getContentResolver().query(fragment.build(), null, suggestSelection, strArr2, null);\n     }",
              "vulnerability_id": "e77094cd-2c51-43f6-8fed-bc3af56cf062",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SuggestionsAdapter.java",
              "file_line": [
                1838
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:44.146-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "fdf4a70c-8e2e-44d1-9fb1-1fe17e1152c6",
              "value": "static FontsContractCompat.FontInfo[] getFontFromProvider(Context context, FontRequest fontRequest, String str, CancellationSignal cancellationSignal) {\n         Uri withAppendedId;\n         ArrayList arrayList = new ArrayList();\n         Uri build = new Uri.Builder().scheme(\"content\").authority(str).build();\n         Uri build2 = new Uri.Builder().scheme(\"content\").authority(str).appendPath(\"file\").build();\n         Cursor cursor = null;\n         try {\n             if (Build.VERSION.SDK_INT > 16) {\n                 cursor = context.getContentResolver().query(build, new String[]{\"_id\", \"file_id\", \"font_ttc_index\", \"font_variation_settings\", \"font_weight\", \"font_italic\", \"result_code\"}, \"query = ?\", new String[]{fontRequest.getQuery()}, null, cancellationSignal);\n             } else {\n                 cursor = context.getContentResolver().query(build, new String[]{\"_id\", \"file_id\", \"font_ttc_index\", \"font_variation_settings\", \"font_weight\", \"font_italic\", \"result_code\"}, \"query = ?\", new String[]{fontRequest.getQuery()}, null);\n             }\n             if (cursor != null && cursor.getCount() > 0) {\n                 int columnIndex = cursor.getColumnIndex(\"result_code\");\n                 ArrayList arrayList2 = new ArrayList();\n                 int columnIndex2 = cursor.getColumnIndex(\"_id\");\n                 int columnIndex3 = cursor.getColumnIndex(\"file_id\");\n                 int columnIndex4 = cursor.getColumnIndex(\"font_ttc_index\");\n                 int columnIndex5 = cursor.getColumnIndex(\"font_weight\");\n                 int columnIndex6 = cursor.getColumnIndex(\"font_italic\");\n                 while (cursor.moveToNext()) {\n                     int i = columnIndex != -1 ? cursor.getInt(columnIndex) : 0;\n                     int i2 = columnIndex4 != -1 ? cursor.getInt(columnIndex4) : 0;\n                     if (columnIndex3 == -1) {\n                         withAppendedId = ContentUris.withAppendedId(build, cursor.getLong(columnIndex2));\n                     } else {\n                         withAppendedId = ContentUris.withAppendedId(build2, cursor.getLong(columnIndex3));\n                     }\n                     arrayList2.add(new FontsContractCompat.FontInfo(withAppendedId, i2, columnIndex5 != -1 ? cursor.getInt(columnIndex5) : 400, columnIndex6 != -1 && cursor.getInt(columnIndex6) == 1, i));\n                 }\n                 arrayList = arrayList2;\n             }\n             return (FontsContractCompat.FontInfo[]) arrayList.toArray(new FontsContractCompat.FontInfo[0]);\n         } finally {\n             if (cursor != null) {\n                 cursor.close();\n             }\n         }\n     }",
              "vulnerability_id": "e77094cd-2c51-43f6-8fed-bc3af56cf062",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/provider/FontsContractCompat.java",
              "file_line": [
                502
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:44.179-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "ce3787da-b162-4bdc-a85e-b7c97995f4ab",
              "value": "public static Cursor query(ContentResolver contentResolver, Uri uri, String[] strArr, String str, String[] strArr2, String str2, CancellationSignal cancellationSignal) {\n         android.os.CancellationSignal cancellationSignal2;\n         if (Build.VERSION.SDK_INT >= 16) {\n             if (cancellationSignal != null) {\n                 try {\n                     cancellationSignal2 = cancellationSignal.getCancellationSignalObject();\n                 } catch (Exception e) {\n                     if (e instanceof OperationCanceledException) {\n                         throw new androidx.core.os.OperationCanceledException();\n                     }\n                     throw e;\n                 }\n             } else {\n                 cancellationSignal2 = null;\n             }\n             return contentResolver.query(uri, strArr, str, strArr2, str2, cancellationSignal2);\n         }\n         if (cancellationSignal != null) {\n             cancellationSignal.throwIfCanceled();\n         }\n         return contentResolver.query(uri, strArr, str, strArr2, str2);\n     }",
              "vulnerability_id": "e77094cd-2c51-43f6-8fed-bc3af56cf062",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/ContentResolverCompat.java",
              "file_line": [
                96
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:44.162-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "73e61693-56aa-4649-9017-b4fe03820e68",
          "title": "Access External Storage",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>Challenge 2</b> application utilizes external storage for reading and writing data. Storing data externally poses a risk as it can be accessed and modified by malicious applications on the same device. This vulnerability can lead to information disclosure, data tampering, or other forms of malicious behavior.</p>\n<p>The code snippet below illustrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends not storing executable files, configuration files, or sensitive user data on the external storage if its possible otherwise it should be strongly encrypted to avoid sensitive information to be disclosed.</p>\n",
              "impact": "<p>An attacker or a malicious application could exploit this vulnerability to access or modify the data stored in the external storage. This unauthorized access or modification could lead to serious security issues, including data breaches, information disclosure, and compromising the integrity of the application&#39;s data.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación <b>Challenge 2</b> utiliza almacenamiento externo para leer y escribir datos. El almacenamiento de datos de forma externa representa un riesgo, ya que puede ser accedido y modificado por aplicaciones maliciosas en el mismo dispositivo. Esta vulnerabilidad puede llevar a la divulgación de información, manipulación de datos u otras formas de comportamiento malicioso.</p>\n<p>El fragmento de código a continuación ilustra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda evitar almacenar archivos ejecutables, archivos de configuración o datos sensibles de usuarios en el almacenamiento externo siempre que sea posible. Si es necesario utilizar almacenamiento externo, es crucial emplear encriptación fuerte para prevenir la divulgación de información sensible.</p>\n",
              "impact": "<p>Un atacante o una aplicación maliciosa podría aprovechar esta vulnerabilidad para acceder o modificar los datos almacenados en el almacenamiento externo. Este acceso o modificación no autorizados podrían conducir a graves problemas de seguridad, incluyendo violaciones de datos, divulgación de información y compromiso de la integridad de los datos de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "M2: Insecure Data Storage | OWASP Foundation",
              "url": "https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage"
            },
            {
              "label": "MSTG- Testing Data Storage",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#external-storage"
            },
            {
              "label": "CWE - CWE-921: Storage of Sensitive Data in a Mechanism without Access Control (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/921.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "55f4c721-3a6a-4756-8e8c-abf750f5084e",
              "value": "public static File[] getExternalCacheDirs(Context context) {\n         return Build.VERSION.SDK_INT >= 19 ? context.getExternalCacheDirs() : new File[]{context.getExternalCacheDir()};\n     }",
              "vulnerability_id": "73e61693-56aa-4649-9017-b4fe03820e68",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/ContextCompat.java",
              "file_line": [
                435
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.990-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "6c0676a4-dd70-4cb4-b485-80d9c496db31",
              "value": "public static File[] getExternalFilesDirs(Context context, String str) {\n         return Build.VERSION.SDK_INT >= 19 ? context.getExternalFilesDirs(str) : new File[]{context.getExternalFilesDir(str)};\n     }",
              "vulnerability_id": "73e61693-56aa-4649-9017-b4fe03820e68",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/ContextCompat.java",
              "file_line": [
                469
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:44.017-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "eeb3297c-552b-45be-87ae-31fe801900f7",
              "value": "public static String getStorageState(File file) {\n         if (Build.VERSION.SDK_INT >= 21) {\n             return Environment.getExternalStorageState(file);\n         }\n         if (Build.VERSION.SDK_INT >= 19) {\n             return Environment.getStorageState(file);\n         }\n         try {\n             return file.getCanonicalPath().startsWith(Environment.getExternalStorageDirectory().getCanonicalPath()) ? Environment.getExternalStorageState() : \"unknown\";\n         } catch (IOException e) {\n             Log.w(\"EnvironmentCompat\", \"Failed to resolve canonical path: \" + e);\n             return \"unknown\";\n         }\n     }",
              "vulnerability_id": "73e61693-56aa-4649-9017-b4fe03820e68",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/os/EnvironmentCompat.java",
              "file_line": [
                62
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:44.034-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "9deed2be-35c9-4a6a-b21d-696f7ffd9302",
          "title": "Application Allows Execution of Backups",
          "severity": "low",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>android:allowBackup</b> attribute is set to true in the Android Manifest file of the <b>Challenge 2</b> application. This setting determines if a user can back up and restore the application&#39;s data. When the backup flag is true, it permits an attacker to extract a backup of the application&#39;s data through adb/USB, even on unrooted devices.</p>\n",
              "remediation": "<p>To prevent unauthorized backup of the app data, set the <b>android:allowBackup</b> attribute to false. By default, the allowBackup setting is enabled if this attribute is not explicitly defined, necessitating manual deactivation. It&#39;s important to regularly review the <b>AndroidManifest.xml</b> file to ensure that the developer framework does not inadvertently include insecure default settings.</p>\n",
              "impact": "<p>Android includes an <b>allowBackup</b> attribute, used to enable the backup of all application data. This attribute is defined in the <b>AndroidManifest.xml</b> file. When its value is set to true, it permits users to back up the application data using the Android Debug Bridge (ADB). However, this setting can potentially expose sensitive data, as it allows for data backup without strong security controls, potentially leading to data leakage or unauthorized access if exploited.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que el atributo <b>android:allowBackup</b> está configurado como true en el archivo Android Manifest de la aplicación <b>Challenge 2</b>. Esta configuración determina si los datos de la aplicación pueden ser respaldados y restaurados por el usuario. Cuando el flag allowBackup está en true, permite a un atacante realizar un backup de los datos de la aplicación a través de adb/USB, incluso en dispositivos que no están rooteados.</p>\n",
              "remediation": "<p>Para prevenir el respaldo no autorizado de los datos de la aplicación, configure el atributo <b>android:allowBackup</b> en false. Por defecto, la configuración allowBackup está habilitada si este atributo no se define explícitamente, lo que requiere una desactivación manual. Es importante revisar regularmente el archivo <b>AndroidManifest.xml</b> para asegurarse de que el marco de desarrollo no incluya por error configuraciones predeterminadas inseguras.</p>\n",
              "impact": "<p>Android incluye un atributo llamado <b>allowBackup</b>, utilizado para habilitar el respaldo de todos los datos de una aplicación. Este atributo se define en el archivo <b>AndroidManifest.xml</b>. Cuando su valor está configurado en true, permite a los usuarios respaldar los datos de la aplicación utilizando el Android Debug Bridge (ADB). Sin embargo, esta configuración puede exponer datos sensibles, ya que permite realizar copias de seguridad de datos sin controles de seguridad estrictos, lo que podría llevar a la filtración de datos o acceso no autorizado si se explota.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "MSTG - Testing Backups",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-backups-for-sensitive-data-mstg-storage-8"
            },
            {
              "label": "Back up user data with Auto Backup  |  Android Developers",
              "url": "https://developer.android.com/guide/topics/data/autobackup"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-2",
            "maswe": "MASWE-0003"
          },
          "evidences": [
            {
              "id": "2d07d039-41aa-47d7-a418-e6b68e5c6c74",
              "value": "xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <uses-sdk android:minSdkVersion=\"23\" android:targetSdkVersion=\"30\" />\n    <application android:theme=\"@style/Theme.Challenge2\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:extractNativeLibs=\"false\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:appComponentFactory=\"androidx.core.app.CoreComponentFactory\">\n        <activity android:name=\"com.just.mobile.sec.challenge2.HiddenActivity\" android:exported=\"true\" />",
              "vulnerability_id": "9deed2be-35c9-4a6a-b21d-696f7ffd9302",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/AndroidManifest.xml",
              "file_line": [],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T20:55:44.235-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "56c5229d-9ec1-480c-b0f6-c148496c58bf",
          "title": "Dynamic Receiver Registration",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team discovered a vulnerability in the <b>Challenge 2</b> application related to the dynamic registration of broadcast receivers. This issue arises due to the application&#39;s use of the registerReceiver() method, which can register broadcast receivers dynamically at runtime instead of declaring them statically in the Android manifest. While dynamic registration provides flexibility, it also introduces potential security risks if not properly managed.</p>\n<p>Specifically, dynamically registered broadcast receivers do not benefit from the Android system&#39;s manifest-based security checks, which can lead to unintended broadcast exposure. If the intent filters associated with these receivers are not carefully specified, it could allow external applications to send broadcasts to the receivers, potentially leading to information leakage or triggering unintended behavior within the app.</p>\n<p>The following code snippet shows the insecure implementation:</p>\n",
              "remediation": "<p>To mitigate the risks associated with dynamically registered broadcast receivers the assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Explicit Intent Filters: Ensure that all dynamically registered broadcast receivers use explicit intent filters that clearly define what actions the receiver is intended to respond to. This helps prevent malicious apps from sending broadcasts that could trigger unintended behavior.\n</li>\n<li>Validate Broadcast Origin: Implement checks within the broadcast receiver to validate the origin of the broadcast. This ensures that only broadcasts from trusted sources are processed, reducing the risk of unauthorized access or manipulation.\n</li>\n<li>Limit Receiver Exposure: Where possible, avoid dynamic registration of broadcast receivers and instead declare them statically in the Android manifest with the necessary permission settings. This leverages the platform's built-in security features to control who can send broadcasts to the receivers.\n</li>\n<li>Use Local Broadcast Manager: For intra-app communication, use Android's Local Broadcast Manager to handle broadcasts. This confines broadcast messages to the app itself, preventing external applications from sending messages to the receivers.\n</li>\n<li>Unregister Receivers: Always ensure that dynamically registered receivers are unregistered when not needed, especially when the app is not in the foreground. This prevents dormant receivers from being triggered unexpectedly.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit the dynamically registered broadcast receivers to send unauthorized broadcasts that trigger unintended actions or manipulate the application’s behavior. This vulnerability could lead to the leakage of sensitive information if broadcasts are intercepted, or could cause the application to perform unintended operations. Such exposures can compromise user data privacy and application functionality</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió una vulnerabilidad en la aplicación <b>Challenge 2</b> relacionada con el registro dinámico de receptores de transmisión. Este problema surge debido al uso por parte de la aplicación del método RegisterReceiver(), que puede registrar receptores de transmisión dinámicamente en tiempo de ejecución en lugar de declararlos estáticamente en el manifiesto de Android. Si bien el registro dinámico proporciona flexibilidad, también introduce riesgos potenciales de seguridad si no se gestiona adecuadamente.</p>\n<p>Específicamente, los receptores de transmisión registrados dinámicamente no se benefician de las comprobaciones de seguridad basadas en manifiestos del sistema Android, lo que puede provocar una exposición involuntaria de la transmisión. Si los filtros de intención asociados con estos receptores no se especifican cuidadosamente, podría permitir que aplicaciones externas envíen transmisiones a los receptores, lo que podría provocar una fuga de información o desencadenar un comportamiento no deseado dentro de la aplicación.</p>\n<p>El siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>Para mitigar los riesgos asociados con los receptores de transmisión registrados dinámicamente, el equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Filtros de intención explícitos: asegúrese de que todos los receptores de transmisión registrados dinámicamente utilicen filtros de intención explícitos que definan claramente a qué acciones debe responder el receptor. Esto ayuda a evitar que aplicaciones maliciosas envíen difusiones que podrían desencadenar un comportamiento no deseado.\n</li>\n<li>Validar origen de transmisión: implemente comprobaciones dentro del receptor de transmisión para validar el origen de la transmisión. Esto garantiza que solo se procesen transmisiones de fuentes confiables, lo que reduce el riesgo de acceso o manipulación no autorizados.\n</li>\n<li>Limitar la exposición del receptor: cuando sea posible, evite el registro dinámico de los receptores de transmisión y, en cambio, declárelos estáticamente en el manifiesto de Android con la configuración de permisos necesaria. Esto aprovecha las funciones de seguridad integradas de la plataforma para controlar quién puede enviar transmisiones a los receptores.\n</li>\n<li>Utilizar el Administrador de transmisiones locales: para la comunicación dentro de la aplicación, use el Administrador de transmisiones locales de Android para manejar las transmisiones. Esto limita los mensajes de difusión a la propia aplicación y evita que aplicaciones externas envíen mensajes a los receptores.\n</li>\n<li>Cancelar receptores: asegúrese siempre de cancelar el registro de los receptores registrados dinámicamente cuando no sean necesarios, especialmente cuando la aplicación no esté en primer plano. Esto evita que los receptores inactivos se activen inesperadamente.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar los receptores de transmisión registrados dinámicamente para enviar transmisiones no autorizadas que desencadenen acciones no deseadas o manipulen el comportamiento de la aplicación. Esta vulnerabilidad podría provocar la fuga de información confidencial si se interceptan las transmisiones o podría provocar que la aplicación realice operaciones no deseadas. Estas exposiciones pueden comprometer la privacidad de los datos del usuario y la funcionalidad de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Transmisiones persistentes | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sticky-broadcast?hl=es-419"
            },
            {
              "label": "Insecure Broadcast Receiver Configuration - Ostorlab: Mobile application security testing for android and ios",
              "url": "https://docs.ostorlab.co/kb/INSECURE_REGISTER_RECEIVER_FLAG/index.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0063"
          },
          "evidences": [
            {
              "id": "9da7ad44-6e3c-4ddc-a8dd-736fdde01de3",
              "value": "void setup() {\n         cleanup();\n         IntentFilter createIntentFilterForBroadcastReceiver = createIntentFilterForBroadcastReceiver();\n         if (createIntentFilterForBroadcastReceiver == null || createIntentFilterForBroadcastReceiver.countActions() == 0) {\n             return;\n         }\n         if (((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver == null) {\n             ((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver = new AppCompatDelegateImpl.AutoNightModeManager.1(this);\n         }\n         ((AppCompatDelegateImpl.AutoNightModeManager) this).this$0.mContext.registerReceiver(((AppCompatDelegateImpl.AutoNightModeManager) this).mReceiver, createIntentFilterForBroadcastReceiver);\n     }",
              "vulnerability_id": "56c5229d-9ec1-480c-b0f6-c148496c58bf",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/app/AppCompatDelegateImpl$AutoNightModeManager.java",
              "file_line": [
                138
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:44.081-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
          "title": "Implicit Intent Detected",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Challenge 2</b> uses implicit intents, which allow the Android system to determine which component, potentially from another application, should handle an intent. While this enables flexible inter-application communication, insecure implementation can lead to unintended exposure of sensitive functionality.</p>\n",
              "remediation": "<p>The assessment team recommends using explicit intents whenever possible to ensure that only intended application components handle them. If implicit intents are required, developers should restrict exposed components by properly configuring intent filters and setting the exported attribute to false when external access is not necessary. Additionally, all incoming intents should be validated to prevent unauthorized access or data manipulation.</p>\n",
              "impact": "<p>Improper handling of implicit intents can result in intent hijacking, where malicious applications intercept and manipulate intents that were not explicitly directed to a specific component. This could lead to unauthorized access to sensitive data or unintended execution of actions triggered by an attacker.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Challenge 2</b> utiliza intenciones implícitas, que permiten al sistema Android determinar qué componente, potencialmente de otra aplicación, debe manejar una intención. Si bien esto permite una comunicación flexible entre aplicaciones, una implementación insegura puede provocar una exposición involuntaria de funciones confidenciales.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda utilizar intenciones explícitas siempre que sea posible para garantizar que solo los componentes de la aplicación previstos las manejen. Si se requieren intenciones implícitas, los desarrolladores deben restringir los componentes expuestos configurando correctamente los filtros de intención y estableciendo el atributo exportado en falso cuando no sea necesario el acceso externo. Además, todos los intents entrantes deben validarse para evitar el acceso no autorizado o la manipulación de datos.</p>\n",
              "impact": "<p>El manejo inadecuado de intenciones implícitas puede resultar en secuestro de intenciones, donde aplicaciones maliciosas interceptan y manipulan intenciones que no estaban dirigidas explícitamente a un componente específico. Esto podría dar lugar a un acceso no autorizado a datos confidenciales o a la ejecución involuntaria de acciones provocadas por un atacante.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Intents and Intent Filters | App architecture - Android Developers",
              "url": "https://developer.android.com/guide/components/intents-filters?hl=es-419"
            },
            {
              "label": "Implicit Intent Hijacking | Security - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/implicit-intent-hijacking?hl=es-419"
            },
            {
              "label": "Mitigate security risks in your app - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "3ccf416b-b167-45be-a41d-4b816c0134cb",
              "value": "public ClsEC08F4C6T9NFCSK(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         View.OnClickListener onClickListener = new SearchView.5(this);\n         ((SearchView) this).mOnClickListener = onClickListener;\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         SearchView.7 r2 = new SearchView.7(this);\n         ((SearchView) this).mOnEditorActionListener = r2;\n         SearchView.8 r3 = new SearchView.8(this);\n         ((SearchView) this).mOnItemClickListener = r3;\n         SearchView.9 r4 = new SearchView.9(this);\n         ((SearchView) this).mOnItemSelectedListener = r4;\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray obtainStyledAttributes = TintTypedArray.obtainStyledAttributes(context, attributeSet, R.styleable.SearchView, i, 0);\n         LayoutInflater.from(context).inflate(obtainStyledAttributes.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         View findViewById2 = findViewById(R.id.search_plate);\n         ((SearchView) this).mSearchPlate = findViewById2;\n         View findViewById3 = findViewById(R.id.submit_area);\n         ((SearchView) this).mSubmitArea = findViewById3;\n         ImageView imageView = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mSearchButton = imageView;\n         ImageView imageView2 = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mGoButton = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mCloseButton = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mVoiceButton = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(R.id.search_mag_icon);\n         ((SearchView) this).mCollapsedIcon = imageView5;\n         ViewCompat.setBackground(findViewById2, obtainStyledAttributes.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(findViewById3, obtainStyledAttributes.getDrawable(R.styleable.SearchView_submitBackground));\n         imageView.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         imageView2.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_goIcon));\n         imageView3.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_closeIcon));\n         imageView4.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_voiceIcon));\n         imageView5.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(imageView, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = obtainStyledAttributes.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = obtainStyledAttributes.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         imageView.setOnClickListener(onClickListener);\n         imageView3.setOnClickListener(onClickListener);\n         imageView2.setOnClickListener(onClickListener);\n         imageView4.setOnClickListener(onClickListener);\n         findViewById.setOnClickListener(onClickListener);\n         findViewById.addTextChangedListener(((SearchView) this).mTextWatcher);\n         findViewById.setOnEditorActionListener(r2);\n         findViewById.setOnItemClickListener(r3);\n         findViewById.setOnItemSelectedListener(r4);\n         findViewById.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         findViewById.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(obtainStyledAttributes.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int dimensionPixelSize = obtainStyledAttributes.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (dimensionPixelSize != -1) {\n             setMaxWidth(dimensionPixelSize);\n         }\n         ((SearchView) this).mDefaultQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_queryHint);\n         int i2 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (i2 != -1) {\n             setImeOptions(i2);\n         }\n         int i3 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (i3 != -1) {\n             setInputType(i3);\n         }\n         setFocusable(obtainStyledAttributes.getBoolean(R.styleable.SearchView_android_focusable, true));\n         obtainStyledAttributes.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).mDropDownAnchor = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                660
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.427-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b33fb03b-482d-4fdd-9d34-8e052b4e7cdb",
              "value": "public Cls2LYJJZBFOI8XNQY(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         View.OnClickListener onClickListener = new SearchView.5(this);\n         ((SearchView) this).mOnClickListener = onClickListener;\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         SearchView.7 r2 = new SearchView.7(this);\n         ((SearchView) this).mOnEditorActionListener = r2;\n         SearchView.8 r3 = new SearchView.8(this);\n         ((SearchView) this).mOnItemClickListener = r3;\n         SearchView.9 r4 = new SearchView.9(this);\n         ((SearchView) this).mOnItemSelectedListener = r4;\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray obtainStyledAttributes = TintTypedArray.obtainStyledAttributes(context, attributeSet, R.styleable.SearchView, i, 0);\n         LayoutInflater.from(context).inflate(obtainStyledAttributes.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         View findViewById2 = findViewById(R.id.search_plate);\n         ((SearchView) this).mSearchPlate = findViewById2;\n         View findViewById3 = findViewById(R.id.submit_area);\n         ((SearchView) this).mSubmitArea = findViewById3;\n         ImageView imageView = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mSearchButton = imageView;\n         ImageView imageView2 = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mGoButton = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mCloseButton = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mVoiceButton = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(R.id.search_mag_icon);\n         ((SearchView) this).mCollapsedIcon = imageView5;\n         ViewCompat.setBackground(findViewById2, obtainStyledAttributes.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(findViewById3, obtainStyledAttributes.getDrawable(R.styleable.SearchView_submitBackground));\n         imageView.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         imageView2.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_goIcon));\n         imageView3.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_closeIcon));\n         imageView4.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_voiceIcon));\n         imageView5.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(imageView, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = obtainStyledAttributes.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = obtainStyledAttributes.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         imageView.setOnClickListener(onClickListener);\n         imageView3.setOnClickListener(onClickListener);\n         imageView2.setOnClickListener(onClickListener);\n         imageView4.setOnClickListener(onClickListener);\n         findViewById.setOnClickListener(onClickListener);\n         findViewById.addTextChangedListener(((SearchView) this).mTextWatcher);\n         findViewById.setOnEditorActionListener(r2);\n         findViewById.setOnItemClickListener(r3);\n         findViewById.setOnItemSelectedListener(r4);\n         findViewById.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         findViewById.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(obtainStyledAttributes.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int dimensionPixelSize = obtainStyledAttributes.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (dimensionPixelSize != -1) {\n             setMaxWidth(dimensionPixelSize);\n         }\n         ((SearchView) this).mDefaultQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_queryHint);\n         int i2 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (i2 != -1) {\n             setImeOptions(i2);\n         }\n         int i3 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (i3 != -1) {\n             setInputType(i3);\n         }\n         setFocusable(obtainStyledAttributes.getBoolean(R.styleable.SearchView_android_focusable, true));\n         obtainStyledAttributes.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).mDropDownAnchor = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                681
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.462-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "7f9875a5-c78f-4aed-821a-55e68502cb88",
              "value": "private Intent createIntent(String str, Uri uri, String str2, String str3, int i, String str4) {\n         Intent intent = new Intent(str);\n         intent.addFlags(268435456);\n         if (uri != null) {\n             intent.setData(uri);\n         }\n         intent.putExtra(\"user_query\", ((SearchView) this).mUserQuery);\n         if (str3 != null) {\n             intent.putExtra(\"query\", str3);\n         }\n         if (str2 != null) {\n             intent.putExtra(\"intent_extra_data_key\", str2);\n         }\n         Bundle bundle = ((SearchView) this).mAppSearchData;\n         if (bundle != null) {\n             intent.putExtra(\"app_data\", bundle);\n         }\n         if (i != 0) {\n             intent.putExtra(\"action_key\", i);\n             intent.putExtra(\"action_msg\", str4);\n         }\n         intent.setComponent(((SearchView) this).mSearchable.getSearchActivity());\n         return intent;\n     }",
              "vulnerability_id": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                726
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.497-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "044a1103-9f8a-49ae-bd43-23f8f4d0dedc",
              "value": "private Intent createVoiceAppSearchIntent(Intent intent, SearchableInfo searchableInfo) {\n         ComponentName searchActivity = searchableInfo.getSearchActivity();\n         Intent intent2 = new Intent(\"android.intent.action.SEARCH\");\n         intent2.setComponent(searchActivity);\n         PendingIntent activity = PendingIntent.getActivity(getContext(), 0, intent2, 1073741824);\n         Bundle bundle = new Bundle();\n         Bundle bundle2 = ((SearchView) this).mAppSearchData;\n         if (bundle2 != null) {\n             bundle.putParcelable(\"app_data\", bundle2);\n         }\n         Intent intent3 = new Intent(intent);\n         Resources resources = getResources();\n         String string = searchableInfo.getVoiceLanguageModeId() != 0 ? resources.getString(searchableInfo.getVoiceLanguageModeId()) : \"free_form\";\n         String string2 = searchableInfo.getVoicePromptTextId() != 0 ? resources.getString(searchableInfo.getVoicePromptTextId()) : null;\n         String string3 = searchableInfo.getVoiceLanguageId() != 0 ? resources.getString(searchableInfo.getVoiceLanguageId()) : null;\n         int voiceMaxResults = searchableInfo.getVoiceMaxResults() != 0 ? searchableInfo.getVoiceMaxResults() : 1;\n         intent3.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", string);\n         intent3.putExtra(\"android.speech.extra.PROMPT\", string2);\n         intent3.putExtra(\"android.speech.extra.LANGUAGE\", string3);\n         intent3.putExtra(\"android.speech.extra.MAX_RESULTS\", voiceMaxResults);\n         intent3.putExtra(\"calling_package\", searchActivity != null ? searchActivity.flattenToShortString() : null);\n         intent3.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT\", activity);\n         intent3.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT_BUNDLE\", bundle);\n         return intent3;\n     }",
              "vulnerability_id": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                978
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.516-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5345a167-9fc9-4b0d-8158-ba1dbfb938bd",
              "value": "private boolean ensureServiceBound(NotificationManagerCompat.SideChannelManager.ListenerRecord listenerRecord) {\n         if (listenerRecord.bound) {\n             return true;\n         }\n         listenerRecord.bound = ((NotificationManagerCompat.SideChannelManager) this).mContext.bindService(new Intent(\"android.support.BIND_NOTIFICATION_SIDE_CHANNEL\").setComponent(listenerRecord.componentName), this, 33);\n         if (listenerRecord.bound) {\n             listenerRecord.retryCount = 0;\n         } else {\n             Log.w(\"NotifManCompat\", \"Unable to bind to listener \" + listenerRecord.componentName);\n             ((NotificationManagerCompat.SideChannelManager) this).mContext.unbindService(this);\n         }\n         return listenerRecord.bound;\n     }",
              "vulnerability_id": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/app/NotificationManagerCompat$SideChannelManager.java",
              "file_line": [
                134
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.533-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "1c1e1dd3-3baa-4c5b-8644-63d52cfa1440",
              "value": "public static Intent makeMainSelectorActivity(String str, String str2) {\n         if (Build.VERSION.SDK_INT >= 15) {\n             return Intent.makeMainSelectorActivity(str, str2);\n         }\n         Intent intent = new Intent(str);\n         intent.addCategory(str2);\n         return intent;\n     }",
              "vulnerability_id": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/IntentCompat.java",
              "file_line": [
                45
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.569-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "a51e9df3-c2cd-4225-afdc-702bf2ade658",
              "value": "public static boolean isRequestPinShortcutSupported(Context context) {\n         if (Build.VERSION.SDK_INT >= 26) {\n             return ((ShortcutManager) context.getSystemService(ShortcutManager.class)).isRequestPinShortcutSupported();\n         }\n         if (ContextCompat.checkSelfPermission(context, \"com.android.launcher.permission.INSTALL_SHORTCUT\") != 0) {\n             return false;\n         }\n         for (ResolveInfo resolveInfo : context.getPackageManager().queryBroadcastReceivers(new Intent(\"com.android.launcher.action.INSTALL_SHORTCUT\"), 0)) {\n             String str = resolveInfo.activityInfo.permission;\n             if (TextUtils.isEmpty(str) || \"com.android.launcher.permission.INSTALL_SHORTCUT\".equals(str)) {\n                 return true;\n             }\n             while (r4.hasNext()) {\n             }\n         }\n         return false;\n     }",
              "vulnerability_id": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/pm/ShortcutManagerCompat.java",
              "file_line": [
                448
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.588-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "d2b71c37-7582-43de-a6e4-af886c2cf1ba",
              "value": "public static boolean requestPinShortcut(Context context, ShortcutInfoCompat shortcutInfoCompat, IntentSender intentSender) {\n         if (Build.VERSION.SDK_INT >= 26) {\n             return ((ShortcutManager) context.getSystemService(ShortcutManager.class)).requestPinShortcut(shortcutInfoCompat.toShortcutInfo(), intentSender);\n         }\n         if (ShortcutManagerCompat.isRequestPinShortcutSupported(context)) {\n             Intent addToIntent = shortcutInfoCompat.addToIntent(new Intent(\"com.android.launcher.action.INSTALL_SHORTCUT\"));\n             if (intentSender == null) {\n                 context.sendBroadcast(addToIntent);\n                 return true;\n             }\n             context.sendOrderedBroadcast(addToIntent, null, new ShortcutManagerCompat.1(intentSender), null, -1, null, null);\n             return true;\n         }\n         return false;\n     }",
              "vulnerability_id": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/core/content/pm/ShortcutManagerCompat.java",
              "file_line": [
                620
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.606-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "917de9ac-58f4-4b35-a53c-dfdf8beca1b9",
              "value": "public ClsTF3SXXX4996Q2DU(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         View.OnClickListener onClickListener = new SearchView.5(this);\n         ((SearchView) this).mOnClickListener = onClickListener;\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         SearchView.7 r2 = new SearchView.7(this);\n         ((SearchView) this).mOnEditorActionListener = r2;\n         SearchView.8 r3 = new SearchView.8(this);\n         ((SearchView) this).mOnItemClickListener = r3;\n         SearchView.9 r4 = new SearchView.9(this);\n         ((SearchView) this).mOnItemSelectedListener = r4;\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray obtainStyledAttributes = TintTypedArray.obtainStyledAttributes(context, attributeSet, R.styleable.SearchView, i, 0);\n         LayoutInflater.from(context).inflate(obtainStyledAttributes.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         View findViewById2 = findViewById(R.id.search_plate);\n         ((SearchView) this).mSearchPlate = findViewById2;\n         View findViewById3 = findViewById(R.id.submit_area);\n         ((SearchView) this).mSubmitArea = findViewById3;\n         ImageView imageView = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mSearchButton = imageView;\n         ImageView imageView2 = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mGoButton = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mCloseButton = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mVoiceButton = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(R.id.search_mag_icon);\n         ((SearchView) this).mCollapsedIcon = imageView5;\n         ViewCompat.setBackground(findViewById2, obtainStyledAttributes.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(findViewById3, obtainStyledAttributes.getDrawable(R.styleable.SearchView_submitBackground));\n         imageView.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         imageView2.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_goIcon));\n         imageView3.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_closeIcon));\n         imageView4.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_voiceIcon));\n         imageView5.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(imageView, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = obtainStyledAttributes.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = obtainStyledAttributes.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         imageView.setOnClickListener(onClickListener);\n         imageView3.setOnClickListener(onClickListener);\n         imageView2.setOnClickListener(onClickListener);\n         imageView4.setOnClickListener(onClickListener);\n         findViewById.setOnClickListener(onClickListener);\n         findViewById.addTextChangedListener(((SearchView) this).mTextWatcher);\n         findViewById.setOnEditorActionListener(r2);\n         findViewById.setOnItemClickListener(r3);\n         findViewById.setOnItemSelectedListener(r4);\n         findViewById.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         findViewById.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(obtainStyledAttributes.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int dimensionPixelSize = obtainStyledAttributes.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (dimensionPixelSize != -1) {\n             setMaxWidth(dimensionPixelSize);\n         }\n         ((SearchView) this).mDefaultQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_queryHint);\n         int i2 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (i2 != -1) {\n             setImeOptions(i2);\n         }\n         int i3 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (i3 != -1) {\n             setInputType(i3);\n         }\n         setFocusable(obtainStyledAttributes.getBoolean(R.styleable.SearchView_android_focusable, true));\n         obtainStyledAttributes.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).mDropDownAnchor = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                660
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.645-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5dd1fa95-e452-49ac-b773-c988ab7dee42",
              "value": "public Cls4SC77382HBJWZIN(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).mSearchSrcTextViewBounds = new Rect();\n         ((SearchView) this).mSearchSrtTextViewBoundsExpanded = new Rect();\n         ((SearchView) this).mTemp = new int[2];\n         ((SearchView) this).mTemp2 = new int[2];\n         ((SearchView) this).mUpdateDrawableStateRunnable = new SearchView.1(this);\n         ((SearchView) this).mReleaseCursorRunnable = new SearchView.2(this);\n         ((SearchView) this).mOutsideDrawablesCache = new WeakHashMap();\n         View.OnClickListener onClickListener = new SearchView.5(this);\n         ((SearchView) this).mOnClickListener = onClickListener;\n         ((SearchView) this).mTextKeyListener = new SearchView.6(this);\n         SearchView.7 r2 = new SearchView.7(this);\n         ((SearchView) this).mOnEditorActionListener = r2;\n         SearchView.8 r3 = new SearchView.8(this);\n         ((SearchView) this).mOnItemClickListener = r3;\n         SearchView.9 r4 = new SearchView.9(this);\n         ((SearchView) this).mOnItemSelectedListener = r4;\n         ((SearchView) this).mTextWatcher = new SearchView.10(this);\n         TintTypedArray obtainStyledAttributes = TintTypedArray.obtainStyledAttributes(context, attributeSet, R.styleable.SearchView, i, 0);\n         LayoutInflater.from(context).inflate(obtainStyledAttributes.getResourceId(R.styleable.SearchView_layout, R.layout.abc_search_view), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(R.id.search_src_text);\n         ((SearchView) this).mSearchSrcTextView = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).mSearchEditFrame = findViewById(R.id.search_edit_frame);\n         View findViewById2 = findViewById(R.id.search_plate);\n         ((SearchView) this).mSearchPlate = findViewById2;\n         View findViewById3 = findViewById(R.id.submit_area);\n         ((SearchView) this).mSubmitArea = findViewById3;\n         ImageView imageView = (ImageView) findViewById(R.id.search_button);\n         ((SearchView) this).mSearchButton = imageView;\n         ImageView imageView2 = (ImageView) findViewById(R.id.search_go_btn);\n         ((SearchView) this).mGoButton = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(R.id.search_close_btn);\n         ((SearchView) this).mCloseButton = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(R.id.search_voice_btn);\n         ((SearchView) this).mVoiceButton = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(R.id.search_mag_icon);\n         ((SearchView) this).mCollapsedIcon = imageView5;\n         ViewCompat.setBackground(findViewById2, obtainStyledAttributes.getDrawable(R.styleable.SearchView_queryBackground));\n         ViewCompat.setBackground(findViewById3, obtainStyledAttributes.getDrawable(R.styleable.SearchView_submitBackground));\n         imageView.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         imageView2.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_goIcon));\n         imageView3.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_closeIcon));\n         imageView4.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_voiceIcon));\n         imageView5.setImageDrawable(obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchIcon));\n         ((SearchView) this).mSearchHintIcon = obtainStyledAttributes.getDrawable(R.styleable.SearchView_searchHintIcon);\n         TooltipCompat.setTooltipText(imageView, getResources().getString(R.string.abc_searchview_description_search));\n         ((SearchView) this).mSuggestionRowLayout = obtainStyledAttributes.getResourceId(R.styleable.SearchView_suggestionRowLayout, R.layout.abc_search_dropdown_item_icons_2line);\n         ((SearchView) this).mSuggestionCommitIconResId = obtainStyledAttributes.getResourceId(R.styleable.SearchView_commitIcon, 0);\n         imageView.setOnClickListener(onClickListener);\n         imageView3.setOnClickListener(onClickListener);\n         imageView2.setOnClickListener(onClickListener);\n         imageView4.setOnClickListener(onClickListener);\n         findViewById.setOnClickListener(onClickListener);\n         findViewById.addTextChangedListener(((SearchView) this).mTextWatcher);\n         findViewById.setOnEditorActionListener(r2);\n         findViewById.setOnItemClickListener(r3);\n         findViewById.setOnItemSelectedListener(r4);\n         findViewById.setOnKeyListener(((SearchView) this).mTextKeyListener);\n         findViewById.setOnFocusChangeListener(new SearchView.3(this));\n         setIconifiedByDefault(obtainStyledAttributes.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));\n         int dimensionPixelSize = obtainStyledAttributes.getDimensionPixelSize(R.styleable.SearchView_android_maxWidth, -1);\n         if (dimensionPixelSize != -1) {\n             setMaxWidth(dimensionPixelSize);\n         }\n         ((SearchView) this).mDefaultQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_defaultQueryHint);\n         ((SearchView) this).mQueryHint = obtainStyledAttributes.getText(R.styleable.SearchView_queryHint);\n         int i2 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_imeOptions, -1);\n         if (i2 != -1) {\n             setImeOptions(i2);\n         }\n         int i3 = obtainStyledAttributes.getInt(R.styleable.SearchView_android_inputType, -1);\n         if (i3 != -1) {\n             setInputType(i3);\n         }\n         setFocusable(obtainStyledAttributes.getBoolean(R.styleable.SearchView_android_focusable, true));\n         obtainStyledAttributes.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).mVoiceWebSearchIntent = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).mVoiceAppSearchIntent = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).mDropDownAnchor = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.4(this));\n         }\n         updateViewsVisibility(((SearchView) this).mIconifiedByDefault);\n         updateQueryHint();\n     }",
              "vulnerability_id": "e053b2da-54a0-40c7-807d-11d2f7de7ffc",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                681
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:55:43.667-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        }
      ],
      "severityDistribution": {
        "high": 28.57,
        "info": 28.57,
        "medium": 28.57,
        "low": 14.29
      },
      "severityCount": {
        "high": 2,
        "info": 2,
        "medium": 2,
        "low": 1
      },
      "properties": {
        "MIN_SDK": 23,
        "MD5": "0b75a9f3c1f2a247e3544688e226f091",
        "SHA1": "601f252899d1b7ad984d811f2d32997dbdb65a34",
        "SHA256": "9ba6c3c08874bb7bcf810baa9a4c33da180ca2991f500783ed78daec84eb8a15",
        "VERSION": "1.0.0",
        "MAIN_ACTIVITY": "com.just.mobile.sec.challenge2.SplashActivity",
        "ANDROID_VERSION_CODE": "1.0.0",
        "FRAMEWORK": "Native (Java / Kotlin)",
        "BINARY_PROTECTIONS": null
      },
      "permissions": [],
      "components": [
        {
          "name": "com.just.mobile.sec.challenge2.HiddenActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": true
        },
        {
          "name": "com.just.mobile.sec.challenge2.SplashActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": true
        },
        {
          "name": "com.just.mobile.sec.challenge2.MainActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        }
      ],
      "protections": [
        {
          "type": "anti_vm",
          "name": "Emulation Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": [
            {
              "name": "Build.FINGERPRINT",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "Build.MANUFACTURER",
              "files": [
                "classes.dex"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": 1,
      "status": "COMPLETED",
      "start_at": "2025-06-14T00:00:00.000-03:00",
      "end_at": "2025-06-15T23:59:59.999-03:00",
      "created_at": "2025-06-14T20:53:55.530-03:00",
      "updated_at": "2025-06-14T20:54:57.356-03:00",
      "platform": "ANDROID",
      "services": {
        "id": 0,
        "name": "Mobile Penetration Testing"
      },
      "assessment": {
        "status": "COMPLETED",
        "id": "ae4bab00-968e-4de3-9202-30735d0f005e",
        "name": null,
        "company_id": 1,
        "company": {
          "id": 1,
          "name": "Just Mobile Security"
        }
      },
      "scans": [
        {
          "id": "1b20f1fa-8f4c-4e96-ae94-5d767f0a9e7d",
          "aat_version": "0.1.0-beta-2",
          "scan_status_id": 3,
          "created_at": "2025-06-14T20:53:56.624-03:00",
          "updated_at": "2025-06-14T20:54:57.278-03:00",
          "type": "SAST",
          "app_id": "a789a5ce-5721-42fc-9b24-25a57efbecbb",
          "assessment_service_id": 1,
          "app": {
            "id": "a789a5ce-5721-42fc-9b24-25a57efbecbb",
            "name": "Challenge 1",
            "description": "com.just.mobile.sec.challenge_1",
            "created_at": "2025-06-14T20:53:56.621-03:00",
            "updated_at": "2025-06-14T20:54:08.775-03:00",
            "version": null,
            "icon": {
              "url": "http://storage.fakedomain.com/bucket-storage/assessments/ae4bab00-968e-4de3-9202-30735d0f005e/service/1/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T012947Z&X-Amz-Expires=600&X-Amz-Signature=b8f3510f906a601dd26ee5db6e4b54b50f7ec128b0abb5bfbe26e5afcddf62d7&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
              "name": "assessments/ae4bab00-968e-4de3-9202-30735d0f005e/service/1/icon.png",
              "extname": "png",
              "size": 5870,
              "mimeType": "image/png"
            }
          }
        }
      ],
      "summary": {
        "appId": "a789a5ce-5721-42fc-9b24-25a57efbecbb",
        "name": "Challenge 1",
        "description": "com.just.mobile.sec.challenge_1",
        "platform": "ANDROID",
        "version": "",
        "createdAt": "2025-06-14T20:53:56.624-03:00",
        "finishedAt": "2025-06-14T20:54:57.278-03:00",
        "statusId": 3,
        "status": "Completed",
        "duration": {
          "days": 0,
          "hours": 0,
          "minutes": 1,
          "seconds": 0,
          "milliseconds": 654,
          "human": "1 minute"
        },
        "file": {
          "name": "assessments/ae4bab00-968e-4de3-9202-30735d0f005e/service/1/Challenge_1.apk",
          "size": "1.53 MB"
        },
        "icon": "http://storage.fakedomain.com/bucket-storage/assessments/ae4bab00-968e-4de3-9202-30735d0f005e/service/1/icon.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=admin%2F20250615%2Fnyc3%2Fs3%2Faws4_request&X-Amz-Date=20250615T033435Z&X-Amz-Expires=600&X-Amz-Signature=7aa54e926a56ef3f9b250c66f0a5d4347d3a33fb27d449684b645c39d72740b6&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject",
        "start_date": "2025-06-14T00:00:00.000-03:00",
        "end_date": "2025-06-15T23:59:59.999-03:00"
      },
      "vulnerabilities": [
        {
          "vulnerabilityId": "53a4fd51-a13c-4757-ab6e-0e6ace404189",
          "title": "SQL Injection",
          "severity": "high",
          "translations": [
            {
              "description": "<p>The assessment team discovered potential SQL Injection (SQLi) vulnerabilities in the decompiled source code of the <b>Challenge 1</b> Android application, specifically in how the application handles SQL database operations. The critical findings include the use of methods such as insert, delete, query, execSQL, and rawQuery without proper input validation or parameterization. This opens up possible attack vectors if these database operations interact with external inputs. For example, if these methods are triggered via deeplinks, interceptable network communications, or manipulated within insecure WebViews, they could potentially be exploited remotely. Such vulnerabilities are particularly concerning as they could allow an attacker to inject malicious SQL queries to manipulate or exfiltrate data from the application’s local databases, posing significant risks to data integrity and security.</p>\n<p>The following code snippet shows the insecure implementation.</p>\n",
              "remediation": "<p>The assessment team recommends the following:</p>\n<ul>\n<li>Implement Parameterized Queries: Replace all raw SQL query constructions with parameterized queries to prevent SQL injection. This practice ensures that input values are treated as data, not executable code.\n</li>\n<li>Validate and Sanitize Inputs: Rigorously validate and sanitize all inputs, especially those obtained from external sources such as deeplinks, network communications, or WebViews. Ensure that inputs conform to expected formats and do not contain malicious SQL code.\n</li>\n<li>Secure WebViews: If the application uses WebViews, ensure they are configured securely. Disable JavaScript execution if not needed, and restrict interaction between the WebView and the application to minimize exposure to injection attacks.\n</li>\n<li>Review and Restrict Database Permissions: Restrict the database permissions to the minimum necessary for the application to function. This minimizes the potential damage from an SQL injection attack by limiting what an attacker can do within the database.</li>\n</ul>\n",
              "impact": "<p>An attacker could potentially execute unauthorized SQL commands, leading to data manipulation or exfiltration. This could result in the compromise of sensitive user data stored within the application&#39;s databases, such as personal details, credentials, financial information or disrupt application functionality. The ability to exploit these vulnerabilities remotely via methods like deeplinks or insecure WebViews significantly increases the severity of the threat, expanding the potential for widespread impact on users.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación halló una posible vulnerabilidad de inyección de SQL (SQLi) en el código fuente sin compilar de la aplicación Android <b>Challenge 1</b>, específicamente, en la manera en la que la aplicación maneja las operaciones de bases de datos de SQL. Estos hallazgos críticos incluyen el uso de métodos (como insert, delete, query, execSQL y rawQuery) sin una validación o parametrización apropiada de las entradas. Esto habilita posibles vectores de ataque si estas operaciones de base de datos interactúan con entradas externas. Por ejemplo, si estos métodos son activadios a través enlaces profundos o comunicaciones de red interceptables, o si se manipulan en vistas web inseguras, podrían explotarse de manera remota. Estas vulnerabilidades son particularmente preocupantes, ya que podrían permitirle a un atacante inyectar consultas SQL malintencionadas para manipular o extraer información de las bases de datos locales de la aplicación, lo cual implica un gran riesgo para la seguridad y la integridad de la información.</p>\n<p>El siguiente fragmento de código muestra la implementación segura.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda lo siguiente:</p>\n<ul>\n<li>Implementar consultas parametrizadas: reemplace todas las construcciones de consultas SQL sin formato con consultas parametrizadas para evitar la inyección de SQL. Esta práctica garantiza que los valores de entrada se traten como datos, y no como código ejecutable.\n</li>\n<li>Validar y desinfectar entradas: valide y desinfecte rigurosamente todas las entradas, especialmente aquellas obtenidas de fuentes externas, como enlaces profundos, comunicaciones de red o vistas web. Asegúrese de que las entradas se ajusten a los formatos esperados y no contengan código SQL malintencionado.\n</li>\n<li>Vistas web seguras: si la aplicación utiliza vistas web, asegúrese de que estén configurados de manera segura. Deshabilite la ejecución de JavaScript si no es necesario y restrinja la interacción entre las vistas web y la aplicación para minimizar la exposición a ataques de inyección.\n</li>\n<li>Revisar y restringir los permisos de la base de datos: mantenga los permisos de la base de datos al mínimo necesario para que la aplicación funcione. Esto minimiza el daño potencial de un ataque de inyección SQL al limitar lo que un atacante puede hacer dentro de la base de datos</li>\n</ul>\n",
              "impact": "<p>Un atacante podría ejecutar comandos SQL no autorizados, lo que llevaría a la manipulación o extracción de datos. Esto podría poner en peligro la información sensible de los usuarios almacenada en las bases de datos de la aplicación (como detalles personales, credenciales, información financiera) o interrumpir la funcionalidad de la aplicación. La capacidad de explotar estas vulnerabilidades de manera remota mediante enlaces profundos o vistas web inseguras aumenta significativamente la gravedad de la amenaza y amplía el potencial de un impacto generalizado en los usuarios.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "SQL injection | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sql-injection"
            },
            {
              "label": "V10: Code Quality Requirements - OWASP MASVS",
              "url": "https://mas.owasp.org/MASVS/10-MASVS-CODE/"
            },
            {
              "label": "MASVS-CODE-2.5: Security Control Verification Requirements | OWASP MASTG",
              "url": "https://mas.owasp.org/MASTG/tests/android/MASVS-CODE/MASTG-TEST-0025/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-CODE-4",
            "maswe": "MASWE-0086"
          },
          "evidences": [
            {
              "id": "0dff19e2-1f00-41d0-9905-a7138353fd5b",
              "value": "public final void b(b bVar, int i) {\n         String[] strArr;\n         a aVar = (a) bVar;\n         aVar.b.execSQL(\"INSERT OR IGNORE INTO room_table_modification_log VALUES(\" + i + \", 0)\");\n         String str = ((f) this).b[i];\n         StringBuilder sb = new StringBuilder();\n         for (String str2 : f.k) {\n             sb.setLength(0);\n             sb.append(\"CREATE TEMP TRIGGER IF NOT EXISTS \");\n             sb.append(\"`\");\n             sb.append(\"room_table_modification_trigger_\");\n             sb.append(str);\n             sb.append(\"_\");\n             sb.append(str2);\n             sb.append(\"`\");\n             sb.append(\" AFTER \");\n             sb.append(str2);\n             sb.append(\" ON `\");\n             sb.append(str);\n             sb.append(\"` BEGIN UPDATE \");\n             sb.append(\"room_table_modification_log\");\n             sb.append(\" SET \");\n             sb.append(\"invalidated\");\n             sb.append(\" = 1\");\n             sb.append(\" WHERE \");\n             sb.append(\"table_id\");\n             sb.append(\" = \");\n             sb.append(i);\n             sb.append(\" AND \");\n             sb.append(\"invalidated\");\n             sb.append(\" = 0\");\n             sb.append(\"; END\");\n             aVar.b.execSQL(sb.toString());\n         }\n     }",
              "vulnerability_id": "53a4fd51-a13c-4757-ab6e-0e6ace404189",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/a/p/f.java",
              "file_line": [
                362
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.582-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "8281cb44-4cf3-42b7-85d0-6cb2ccb8d7b1",
              "value": "public final void c(b bVar, int i) {\n         String[] strArr;\n         String str = ((f) this).b[i];\n         StringBuilder sb = new StringBuilder();\n         for (String str2 : f.k) {\n             sb.setLength(0);\n             sb.append(\"DROP TRIGGER IF EXISTS \");\n             sb.append(\"`\");\n             sb.append(\"room_table_modification_trigger_\");\n             sb.append(str);\n             sb.append(\"_\");\n             sb.append(str2);\n             sb.append(\"`\");\n             ((a) bVar).b.execSQL(sb.toString());\n         }\n     }",
              "vulnerability_id": "53a4fd51-a13c-4757-ab6e-0e6ace404189",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/a/p/f.java",
              "file_line": [
                550
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.610-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4c296aa1-25d8-43a3-915e-69d241f146bd",
              "value": "public final f b() {\n         String c = c();\n         g gVar = ((k) this).b;\n         gVar.a();\n         gVar.b();\n         return new f(gVar.c.b().b.compileStatement(c));\n     }",
              "vulnerability_id": "53a4fd51-a13c-4757-ab6e-0e6ace404189",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/a/p/k.java",
              "file_line": [
                108
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.689-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "4cf00bba-70af-4600-8e35-78d1a2ab23f7",
              "value": "public void b(b bVar, int i, int i2) {\n         List<a> list;\n         TreeMap treeMap;\n         boolean z;\n         boolean z2;\n         a.p.a aVar = ((h) this).b;\n         boolean z3 = true;\n         if (aVar != null) {\n             g.c cVar = aVar.d;\n             Objects.requireNonNull(cVar);\n             if (i == i2) {\n                 list = Collections.emptyList();\n             } else {\n                 boolean z4 = i2 > i;\n                 ArrayList arrayList = new ArrayList();\n                 int i3 = i;\n                 do {\n                     if (z4) {\n                         if (i3 >= i2) {\n                             list = arrayList;\n                             break;\n                         }\n                         treeMap = (TreeMap) cVar.a.get(Integer.valueOf(i3));\n                         if (treeMap == null) {\n                             break;\n                         }\n                         Iterator it = (z4 ? treeMap.descendingKeySet() : treeMap.keySet()).iterator();\n                         while (true) {\n                             if (!it.hasNext()) {\n                                 z = false;\n                                 continue;\n                                 break;\n                             }\n                             int intValue = ((Integer) it.next()).intValue();\n                             if (!z4 ? intValue < i2 || intValue >= i3 : intValue > i2 || intValue <= i3) {\n                                 z2 = false;\n                                 continue;\n                             } else {\n                                 z2 = true;\n                                 continue;\n                             }\n                             if (z2) {\n                                 arrayList.add(treeMap.get(Integer.valueOf(intValue)));\n                                 z = true;\n                                 i3 = intValue;\n                                 continue;\n                                 break;\n                             }\n                         }\n                     } else {\n                         if (i3 <= i2) {\n                             list = arrayList;\n                             break;\n                         }\n                         treeMap = (TreeMap) cVar.a.get(Integer.valueOf(i3));\n                         if (treeMap == null) {\n                         }\n                     }\n                 } while (z);\n                 list = null;\n             }\n             if (list != null) {\n                 Objects.requireNonNull(((h) this).c);\n                 ArrayList arrayList2 = new ArrayList();\n                 a.r.a.f.a aVar2 = (a.r.a.f.a) bVar;\n                 Cursor c = aVar2.c(new a.r.a.a(\"SELECT name FROM sqlite_master WHERE type = 'trigger'\"));\n                 while (c.moveToNext()) {\n                     try {\n                         arrayList2.add(c.getString(0));\n                     } catch (Throwable th) {\n                         c.close();\n                         throw th;\n                     }\n                 }\n                 c.close();\n                 Iterator it2 = arrayList2.iterator();\n                 while (it2.hasNext()) {\n                     String str = (String) it2.next();\n                     if (str.startsWith(\"room_fts_content_sync_\")) {\n                         aVar2.b.execSQL(b.a.a.a.a.c(\"DROP TRIGGER IF EXISTS \", str));\n                     }\n                 }\n                 for (a aVar3 : list) {\n                     aVar3.a(bVar);\n                 }\n                 h.b b = ((h) this).c.b(bVar);\n                 if (!b.a) {\n                     StringBuilder f = b.a.a.a.a.f(\"Migration didn't properly handle: \");\n                     f.append(b.b);\n                     throw new IllegalStateException(f.toString());\n                 }\n                 Objects.requireNonNull(((h) this).c);\n                 c(bVar);\n                 if (z3) {\n                     a.p.a aVar4 = ((h) this).b;\n                     if (aVar4 == null || aVar4.a(i, i2)) {\n                         throw new IllegalStateException(\"A migration from \" + i + \" to \" + i2 + \" was required but not found. Please provide the necessary Migration path via RoomDatabase.Builder.addMigration(Migration ...) or allow for destructive migrations via one of the RoomDatabase.Builder.fallbackToDestructiveMigration* methods.\");\n                     }\n                     AppDataBase_Impl.a aVar5 = ((h) this).c;\n                     Objects.requireNonNull(aVar5);\n                     ((a.r.a.f.a) bVar).b.execSQL(\"DROP TABLE IF EXISTS `Flags`\");\n                     List list2 = ((g) aVar5.b).g;\n                     if (list2 != null) {\n                         int size = list2.size();\n                         for (int i4 = 0; i4 < size; i4++) {\n                             Objects.requireNonNull((g.a) ((g) aVar5.b).g.get(i4));\n                         }\n                     }\n                     ((h) this).c.a(bVar);\n                     return;\n                 }\n                 return;\n             }\n         }\n         z3 = false;\n         if (z3) {\n         }\n     }",
              "vulnerability_id": "53a4fd51-a13c-4757-ab6e-0e6ace404189",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/a/p/h.java",
              "file_line": [
                287
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.634-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "b0839d25-3932-471f-83d1-4235baa8acca",
              "value": "public final void c(b bVar) {\n         a aVar = (a) bVar;\n         aVar.b.execSQL(\"CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)\");\n         aVar.b.execSQL(\"INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, '170920f133c8d239858a1deb2f117ab9')\");\n     }",
              "vulnerability_id": "53a4fd51-a13c-4757-ab6e-0e6ace404189",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/a/p/h.java",
              "file_line": [
                491
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.665-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "68b067c7-203c-4f41-8ea9-8c02da670072",
              "value": "public void a(b bVar) {\n         ((a) bVar).b.execSQL(\"CREATE TABLE IF NOT EXISTS `Flags` (`uid` INTEGER NOT NULL, `flag` TEXT, PRIMARY KEY(`uid`))\");\n         a aVar = (a) bVar;\n         aVar.b.execSQL(\"CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)\");\n         aVar.b.execSQL(\"INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, '170920f133c8d239858a1deb2f117ab9')\");\n     }",
              "vulnerability_id": "53a4fd51-a13c-4757-ab6e-0e6ace404189",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/just/mobile/sec/challenge1/AppDataBase_Impl$a.java",
              "file_line": [
                46
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.776-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "99af2715-c2f3-49d3-b35a-5c91c9e11b56",
              "value": "public Cursor c(e eVar) {\n         return ((a) this).b.rawQueryWithFactory(new a.a(this, eVar), eVar.a(), a.c, null);\n     }",
              "vulnerability_id": "53a4fd51-a13c-4757-ab6e-0e6ace404189",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/a/r/a/f/a.java",
              "file_line": [
                83
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.707-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "40a9ad21-72c8-470a-aaf5-af0aa9a209be",
              "value": "public void onOpen(SQLiteDatabase sQLiteDatabase) {\n         boolean z;\n         f fVar;\n         if (((c.a) this).d) {\n             return;\n         }\n         h hVar = ((c.a) this).c;\n         a b = c.a.b(((c.a) this).b, sQLiteDatabase);\n         h hVar2 = hVar;\n         Objects.requireNonNull(hVar2);\n         Cursor c = b.c(new a.r.a.a(\"SELECT 1 FROM sqlite_master WHERE type = 'table' AND name='room_master_table'\"));\n         try {\n             if (c.moveToFirst()) {\n                 if (c.getInt(0) != 0) {\n                     z = true;\n                     c.close();\n                     if (z) {\n                         h.b b2 = hVar2.c.b(b);\n                         if (b2.a) {\n                             Objects.requireNonNull(hVar2.c);\n                             hVar2.c(b);\n                         } else {\n                             StringBuilder f = b.a.a.a.a.f(\"Pre-packaged database has an invalid schema: \");\n                             f.append(b2.b);\n                             throw new IllegalStateException(f.toString());\n                         }\n                     } else {\n                         c = b.c(new a.r.a.a(\"SELECT identity_hash FROM room_master_table WHERE id = 42 LIMIT 1\"));\n                         try {\n                             String string = c.moveToFirst() ? c.getString(0) : null;\n                             c.close();\n                             if (!\"170920f133c8d239858a1deb2f117ab9\".equals(string) && !\"c7b32a180408310855c477a0c70f0284\".equals(string)) {\n                                 throw new IllegalStateException(\"Room cannot verify the data integrity. Looks like you've changed schema but forgot to update the version number. You can simply fix this by increasing the version number.\");\n                             }\n                         } finally {\n                         }\n                     }\n                     AppDataBase_Impl.a aVar = hVar2.c;\n                     ((g) aVar.b).a = b;\n                     fVar = ((g) aVar.b).d;\n                     synchronized (fVar) {\n                         if (fVar.f) {\n                             Log.e(\"ROOM\", \"Invalidation tracker is initialized twice :/.\");\n                         } else {\n                             b.b.execSQL(\"PRAGMA temp_store = MEMORY;\");\n                             b.b.execSQL(\"PRAGMA recursive_triggers='ON';\");\n                             b.b.execSQL(\"CREATE TEMP TABLE room_table_modification_log(table_id INTEGER PRIMARY KEY, invalidated INTEGER NOT NULL DEFAULT 0)\");\n                             fVar.d(b);\n                             fVar.g = new a.r.a.f.f(b.b.compileStatement(\"UPDATE room_table_modification_log SET invalidated = 0 WHERE invalidated = 1 \"));\n                             fVar.f = true;\n                         }\n                     }\n                     List list = ((g) aVar.b).g;\n                     if (list != null) {\n                         int size = list.size();\n                         for (int i = 0; i < size; i++) {\n                             Objects.requireNonNull((g.a) ((g) aVar.b).g.get(i));\n                         }\n                     }\n                     hVar2.b = null;\n                     return;\n                 }\n             }\n             z = false;\n             c.close();\n             if (z) {\n             }\n             AppDataBase_Impl.a aVar2 = hVar2.c;\n             ((g) aVar2.b).a = b;\n             fVar = ((g) aVar2.b).d;\n             synchronized (fVar) {\n             }\n         } finally {\n         }\n     }",
              "vulnerability_id": "53a4fd51-a13c-4757-ab6e-0e6ace404189",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/a/r/a/f/c$a.java",
              "file_line": [
                575
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.726-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "5efc689d-5718-45fd-a73b-02de078c4493",
              "value": "public void d() {\n         a();\n         a b = ((g) this).c.b();\n         try {\n             c();\n             b.b.execSQL(\"DELETE FROM `Flags`\");\n             k();\n             g();\n             a aVar = b;\n             aVar.c(new a.r.a.a(\"PRAGMA wal_checkpoint(FULL)\")).close();\n             if (aVar.b()) {\n                 return;\n             }\n             aVar.b.execSQL(\"VACUUM\");\n         } catch (Throwable th) {\n             g();\n             b.c(new a.r.a.a(\"PRAGMA wal_checkpoint(FULL)\")).close();\n             a aVar2 = b;\n             if (!aVar2.b()) {\n                 aVar2.b.execSQL(\"VACUUM\");\n             }\n             throw th;\n         }\n     }",
              "vulnerability_id": "53a4fd51-a13c-4757-ab6e-0e6ace404189",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/just/mobile/sec/challenge1/AppDataBase_Impl.java",
              "file_line": [
                50
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.829-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "3503aeb2-455a-4213-a8d5-6ad879b52482",
          "title": "Use of External Storage with Media Types",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Challenge 1</b> processes media files using external storage. External storage in Android is publicly accessible, meaning any application with the necessary permissions can read or modify files stored there. If sensitive data is stored or handled insecurely in external storage, the application may be exposed to security risks.</p>\n",
              "remediation": "<p>The assessment team recommends storing sensitive media files in internal storage whenever possible to prevent unauthorized access. Applications targeting Android 10 (API level 29) and above should implement scoped storage to restrict access to external storage. Additionally, it is essential to validate and sanitize files read from external storage to prevent injection attacks and to limit the use of permissions such as READ_EXTERNAL_STORAGE and WRITE_EXTERNAL_STORAGE to only essential cases.</p>\n",
              "impact": "<p>Improper use of external storage can lead to:</p>\n<ul>\n<li>Data Tampering: Malicious applications can modify media files stored in external storage, potentially altering their content.</li>\n<li>Data Leakage: Sensitive information stored in external storage may be accessed by unauthorized applications.</li>\n<li>Code Injection: If the application processes media files from external storage without validation, an attacker could introduce malicious payloads.</li>\n</ul>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Challenge 1</b> procesa archivos multimedia utilizando almacenamiento externo. El almacenamiento externo en Android es de acceso público, lo que significa que cualquier aplicación con los permisos necesarios puede leer o modificar los archivos almacenados allí. Si los datos confidenciales se almacenan o manejan de manera insegura en un almacenamiento externo, la aplicación puede quedar expuesta a riesgos de seguridad.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda almacenar archivos multimedia confidenciales en un almacenamiento interno siempre que sea posible para evitar el acceso no autorizado. Las aplicaciones destinadas a Android 10 (nivel de API 29) y superiores deben implementar almacenamiento con alcance para restringir el acceso al almacenamiento externo. Además, es esencial validar y desinfectar los archivos leídos desde el almacenamiento externo para evitar ataques de inyección y limitar el uso de permisos como READ_EXTERNAL_STORAGE y WRITE_EXTERNAL_STORAGE solo a casos esenciales.</p>\n",
              "impact": "<p>El uso inadecuado del almacenamiento externo puede provocar:</p>\n<ul>\n<li>Manipulación de datos: las aplicaciones maliciosas pueden modificar archivos multimedia almacenados en un almacenamiento externo, alterando potencialmente su contenido.</li>\n<li>Fuga de datos: aplicaciones no autorizadas pueden acceder a la información confidencial almacenada en un almacenamiento externo.</li>\n<li>Inyección de código: si la aplicación procesa archivos multimedia desde un almacenamiento externo sin validación, un atacante podría introducir cargas útiles maliciosas.</li>\n</ul>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Security Tips | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/security-tips?hl=es-419#external-storage"
            },
            {
              "label": "Sensitive Data Stored in External Storage | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sensitive-data-external-storage"
            },
            {
              "label": "MASTG-TEST-0201: Runtime Use of APIs to Access External Storage | OWASP Mobile Application Security",
              "url": "https://mas.owasp.org/MASTG/tests-beta/android/MASVS-STORAGE/MASTG-TEST-0201/"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "c813891c-d891-4413-943e-f69868db4b9a",
              "value": "public Cursor g(SearchableInfo searchableInfo, String str, int i) {\n         String suggestAuthority;\n         String[] strArr = null;\n         if (searchableInfo == null || (suggestAuthority = searchableInfo.getSuggestAuthority()) == null) {\n             return null;\n         }\n         Uri.Builder fragment = new Uri.Builder().scheme(\"content\").authority(suggestAuthority).query(\"\").fragment(\"\");\n         String suggestPath = searchableInfo.getSuggestPath();\n         if (suggestPath != null) {\n             fragment.appendEncodedPath(suggestPath);\n         }\n         fragment.appendPath(\"search_suggest_query\");\n         String suggestSelection = searchableInfo.getSuggestSelection();\n         if (suggestSelection != null) {\n             strArr = new String[]{str};\n         } else {\n             fragment.appendPath(str);\n         }\n         String[] strArr2 = strArr;\n         if (i > 0) {\n             fragment.appendQueryParameter(\"limit\", String.valueOf(i));\n         }\n         return ((a) this).e.getContentResolver().query(fragment.build(), null, suggestSelection, strArr2, null);\n     }",
              "vulnerability_id": "3503aeb2-455a-4213-a8d5-6ad879b52482",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/a/b/h/r0.java",
              "file_line": [
                1552
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.526-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "303fff94-94d4-4bf9-8cd6-8b3e89c3a41e",
          "title": "Access External Storage",
          "severity": "medium",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>Challenge 1</b> application utilizes external storage for reading and writing data. Storing data externally poses a risk as it can be accessed and modified by malicious applications on the same device. This vulnerability can lead to information disclosure, data tampering, or other forms of malicious behavior.</p>\n<p>The code snippet below illustrates the vulnerable implementation:</p>\n",
              "remediation": "<p>The assessment team recommends not storing executable files, configuration files, or sensitive user data on the external storage if its possible otherwise it should be strongly encrypted to avoid sensitive information to be disclosed.</p>\n",
              "impact": "<p>An attacker or a malicious application could exploit this vulnerability to access or modify the data stored in the external storage. This unauthorized access or modification could lead to serious security issues, including data breaches, information disclosure, and compromising the integrity of the application&#39;s data.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que la aplicación <b>Challenge 1</b> utiliza almacenamiento externo para leer y escribir datos. El almacenamiento de datos de forma externa representa un riesgo, ya que puede ser accedido y modificado por aplicaciones maliciosas en el mismo dispositivo. Esta vulnerabilidad puede llevar a la divulgación de información, manipulación de datos u otras formas de comportamiento malicioso.</p>\n<p>El fragmento de código a continuación ilustra la implementación vulnerable:</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda evitar almacenar archivos ejecutables, archivos de configuración o datos sensibles de usuarios en el almacenamiento externo siempre que sea posible. Si es necesario utilizar almacenamiento externo, es crucial emplear encriptación fuerte para prevenir la divulgación de información sensible.</p>\n",
              "impact": "<p>Un atacante o una aplicación maliciosa podría aprovechar esta vulnerabilidad para acceder o modificar los datos almacenados en el almacenamiento externo. Este acceso o modificación no autorizados podrían conducir a graves problemas de seguridad, incluyendo violaciones de datos, divulgación de información y compromiso de la integridad de los datos de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "M2: Insecure Data Storage | OWASP Foundation",
              "url": "https://owasp.org/www-project-mobile-top-10/2016-risks/m2-insecure-data-storage"
            },
            {
              "label": "MSTG- Testing Data Storage",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#external-storage"
            },
            {
              "label": "CWE - CWE-921: Storage of Sensitive Data in a Mechanism without Access Control (4.13)",
              "url": "https://cwe.mitre.org/data/definitions/921.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-1",
            "maswe": "MASWE-0007"
          },
          "evidences": [
            {
              "id": "9637126b-71af-44b6-ba9d-c186e7e9953d",
              "value": "public void onCreate(Bundle bundle) {\n         super.onCreate(bundle);\n         setContentView(2131427356);\n         if (!\"mounted\".equals(Environment.getExternalStorageState()) || \"mounted_ro\".equals(Environment.getExternalStorageState())) {\n             return;\n         }\n         try {\n             FileOutputStream fileOutputStream = new FileOutputStream(new File(getExternalFilesDir(\"InsecureStorage\"), \"VulnerableFile\"));\n             fileOutputStream.write(\"Flag_3={1b69d9bb2e036af1bdb4a0}\".getBytes());\n             fileOutputStream.close();\n         } catch (IOException e) {\n             e.printStackTrace();\n         }\n     }",
              "vulnerability_id": "303fff94-94d4-4bf9-8cd6-8b3e89c3a41e",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/com/just/mobile/sec/challenge1/ExternalStorageActivity.java",
              "file_line": [
                57
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.900-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "076fd978-8dbe-4b41-86f6-2a72e03e5e0c",
          "title": "Application Allows Execution of Backups",
          "severity": "low",
          "translations": [
            {
              "description": "<p>The assessment team discovered that the <b>android:allowBackup</b> attribute is set to true in the Android Manifest file of the <b>Challenge 1</b> application. This setting determines if a user can back up and restore the application&#39;s data. When the backup flag is true, it permits an attacker to extract a backup of the application&#39;s data through adb/USB, even on unrooted devices.</p>\n",
              "remediation": "<p>To prevent unauthorized backup of the app data, set the <b>android:allowBackup</b> attribute to false. By default, the allowBackup setting is enabled if this attribute is not explicitly defined, necessitating manual deactivation. It&#39;s important to regularly review the <b>AndroidManifest.xml</b> file to ensure that the developer framework does not inadvertently include insecure default settings.</p>\n",
              "impact": "<p>Android includes an <b>allowBackup</b> attribute, used to enable the backup of all application data. This attribute is defined in the <b>AndroidManifest.xml</b> file. When its value is set to true, it permits users to back up the application data using the Android Debug Bridge (ADB). However, this setting can potentially expose sensitive data, as it allows for data backup without strong security controls, potentially leading to data leakage or unauthorized access if exploited.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió que el atributo <b>android:allowBackup</b> está configurado como true en el archivo Android Manifest de la aplicación <b>Challenge 1</b>. Esta configuración determina si los datos de la aplicación pueden ser respaldados y restaurados por el usuario. Cuando el flag allowBackup está en true, permite a un atacante realizar un backup de los datos de la aplicación a través de adb/USB, incluso en dispositivos que no están rooteados.</p>\n",
              "remediation": "<p>Para prevenir el respaldo no autorizado de los datos de la aplicación, configure el atributo <b>android:allowBackup</b> en false. Por defecto, la configuración allowBackup está habilitada si este atributo no se define explícitamente, lo que requiere una desactivación manual. Es importante revisar regularmente el archivo <b>AndroidManifest.xml</b> para asegurarse de que el marco de desarrollo no incluya por error configuraciones predeterminadas inseguras.</p>\n",
              "impact": "<p>Android incluye un atributo llamado <b>allowBackup</b>, utilizado para habilitar el respaldo de todos los datos de una aplicación. Este atributo se define en el archivo <b>AndroidManifest.xml</b>. Cuando su valor está configurado en true, permite a los usuarios respaldar los datos de la aplicación utilizando el Android Debug Bridge (ADB). Sin embargo, esta configuración puede exponer datos sensibles, ya que permite realizar copias de seguridad de datos sin controles de seguridad estrictos, lo que podría llevar a la filtración de datos o acceso no autorizado si se explota.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "MSTG - Testing Backups",
              "url": "https://github.com/OWASP/owasp-mastg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-backups-for-sensitive-data-mstg-storage-8"
            },
            {
              "label": "Back up user data with Auto Backup  |  Android Developers",
              "url": "https://developer.android.com/guide/topics/data/autobackup"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-STORAGE-2",
            "maswe": "MASWE-0003"
          },
          "evidences": [
            {
              "id": "85838135-41c6-4f21-8b32-c150aad187ab",
              "value": "<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n    <application android:theme=\"@style/Theme.Challenge_1\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:extractNativeLibs=\"false\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:appComponentFactory=\"androidx.core.app.CoreComponentFactory\">\n        <activity android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\" android:name=\"com.just.mobile.sec.challenge1.SplashActivity\" android:noHistory=\"true\">",
              "vulnerability_id": "076fd978-8dbe-4b41-86f6-2a72e03e5e0c",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/AndroidManifest.xml",
              "file_line": [],
              "extra": "xml",
              "file": null,
              "created_at": "2025-06-14T20:54:56.464-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "0d108170-689d-41f9-88e1-9f2290d77be3",
          "title": "Dynamic Receiver Registration",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team discovered a vulnerability in the <b>Challenge 1</b> application related to the dynamic registration of broadcast receivers. This issue arises due to the application&#39;s use of the registerReceiver() method, which can register broadcast receivers dynamically at runtime instead of declaring them statically in the Android manifest. While dynamic registration provides flexibility, it also introduces potential security risks if not properly managed.</p>\n<p>Specifically, dynamically registered broadcast receivers do not benefit from the Android system&#39;s manifest-based security checks, which can lead to unintended broadcast exposure. If the intent filters associated with these receivers are not carefully specified, it could allow external applications to send broadcasts to the receivers, potentially leading to information leakage or triggering unintended behavior within the app.</p>\n<p>The following code snippet shows the insecure implementation:</p>\n",
              "remediation": "<p>To mitigate the risks associated with dynamically registered broadcast receivers the assessment team recommends the following remediation strategies:</p>\n<ul>\n<li>Explicit Intent Filters: Ensure that all dynamically registered broadcast receivers use explicit intent filters that clearly define what actions the receiver is intended to respond to. This helps prevent malicious apps from sending broadcasts that could trigger unintended behavior.\n</li>\n<li>Validate Broadcast Origin: Implement checks within the broadcast receiver to validate the origin of the broadcast. This ensures that only broadcasts from trusted sources are processed, reducing the risk of unauthorized access or manipulation.\n</li>\n<li>Limit Receiver Exposure: Where possible, avoid dynamic registration of broadcast receivers and instead declare them statically in the Android manifest with the necessary permission settings. This leverages the platform's built-in security features to control who can send broadcasts to the receivers.\n</li>\n<li>Use Local Broadcast Manager: For intra-app communication, use Android's Local Broadcast Manager to handle broadcasts. This confines broadcast messages to the app itself, preventing external applications from sending messages to the receivers.\n</li>\n<li>Unregister Receivers: Always ensure that dynamically registered receivers are unregistered when not needed, especially when the app is not in the foreground. This prevents dormant receivers from being triggered unexpectedly.</li>\n</ul>\n",
              "impact": "<p>An attacker could exploit the dynamically registered broadcast receivers to send unauthorized broadcasts that trigger unintended actions or manipulate the application’s behavior. This vulnerability could lead to the leakage of sensitive information if broadcasts are intercepted, or could cause the application to perform unintended operations. Such exposures can compromise user data privacy and application functionality</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación descubrió una vulnerabilidad en la aplicación <b>Challenge 1</b> relacionada con el registro dinámico de receptores de transmisión. Este problema surge debido al uso por parte de la aplicación del método RegisterReceiver(), que puede registrar receptores de transmisión dinámicamente en tiempo de ejecución en lugar de declararlos estáticamente en el manifiesto de Android. Si bien el registro dinámico proporciona flexibilidad, también introduce riesgos potenciales de seguridad si no se gestiona adecuadamente.</p>\n<p>Específicamente, los receptores de transmisión registrados dinámicamente no se benefician de las comprobaciones de seguridad basadas en manifiestos del sistema Android, lo que puede provocar una exposición involuntaria de la transmisión. Si los filtros de intención asociados con estos receptores no se especifican cuidadosamente, podría permitir que aplicaciones externas envíen transmisiones a los receptores, lo que podría provocar una fuga de información o desencadenar un comportamiento no deseado dentro de la aplicación.</p>\n<p>El siguiente fragmento de código muestra la implementación insegura:</p>\n",
              "remediation": "<p>Para mitigar los riesgos asociados con los receptores de transmisión registrados dinámicamente, el equipo de evaluación recomienda las siguientes estrategias de remediación:</p>\n<ul>\n<li>Filtros de intención explícitos: asegúrese de que todos los receptores de transmisión registrados dinámicamente utilicen filtros de intención explícitos que definan claramente a qué acciones debe responder el receptor. Esto ayuda a evitar que aplicaciones maliciosas envíen difusiones que podrían desencadenar un comportamiento no deseado.\n</li>\n<li>Validar origen de transmisión: implemente comprobaciones dentro del receptor de transmisión para validar el origen de la transmisión. Esto garantiza que solo se procesen transmisiones de fuentes confiables, lo que reduce el riesgo de acceso o manipulación no autorizados.\n</li>\n<li>Limitar la exposición del receptor: cuando sea posible, evite el registro dinámico de los receptores de transmisión y, en cambio, declárelos estáticamente en el manifiesto de Android con la configuración de permisos necesaria. Esto aprovecha las funciones de seguridad integradas de la plataforma para controlar quién puede enviar transmisiones a los receptores.\n</li>\n<li>Utilizar el Administrador de transmisiones locales: para la comunicación dentro de la aplicación, use el Administrador de transmisiones locales de Android para manejar las transmisiones. Esto limita los mensajes de difusión a la propia aplicación y evita que aplicaciones externas envíen mensajes a los receptores.\n</li>\n<li>Cancelar receptores: asegúrese siempre de cancelar el registro de los receptores registrados dinámicamente cuando no sean necesarios, especialmente cuando la aplicación no esté en primer plano. Esto evita que los receptores inactivos se activen inesperadamente.</li>\n</ul>\n",
              "impact": "<p>Un atacante podría aprovechar los receptores de transmisión registrados dinámicamente para enviar transmisiones no autorizadas que desencadenen acciones no deseadas o manipulen el comportamiento de la aplicación. Esta vulnerabilidad podría provocar la fuga de información confidencial si se interceptan las transmisiones o podría provocar que la aplicación realice operaciones no deseadas. Estas exposiciones pueden comprometer la privacidad de los datos del usuario y la funcionalidad de la aplicación.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Transmisiones persistentes | App quality | Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/sticky-broadcast?hl=es-419"
            },
            {
              "label": "Insecure Broadcast Receiver Configuration - Ostorlab: Mobile application security testing for android and ios",
              "url": "https://docs.ostorlab.co/kb/INSECURE_REGISTER_RECEIVER_FLAG/index.html"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0063"
          },
          "evidences": [
            {
              "id": "9b133a94-fc33-4f4c-b1a4-0c76dcd4e1ad",
              "value": "public void e() {\n         a();\n         IntentFilter b = b();\n         if (b == null || b.countActions() == 0) {\n             return;\n         }\n         if (((h.f) this).a == null) {\n             ((h.f) this).a = new h.f.a(this);\n         }\n         ((h.f) this).b.e.registerReceiver(((h.f) this).a, b);\n     }",
              "vulnerability_id": "0d108170-689d-41f9-88e1-9f2290d77be3",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/a/b/c/h$f.java",
              "file_line": [
                107
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:56.966-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        },
        {
          "vulnerabilityId": "5540a4d2-db3a-417c-a329-a74043a52e85",
          "title": "Implicit Intent Detected",
          "severity": "info",
          "translations": [
            {
              "description": "<p>The assessment team identified that <b>Challenge 1</b> uses implicit intents, which allow the Android system to determine which component, potentially from another application, should handle an intent. While this enables flexible inter-application communication, insecure implementation can lead to unintended exposure of sensitive functionality.</p>\n",
              "remediation": "<p>The assessment team recommends using explicit intents whenever possible to ensure that only intended application components handle them. If implicit intents are required, developers should restrict exposed components by properly configuring intent filters and setting the exported attribute to false when external access is not necessary. Additionally, all incoming intents should be validated to prevent unauthorized access or data manipulation.</p>\n",
              "impact": "<p>Improper handling of implicit intents can result in intent hijacking, where malicious applications intercept and manipulate intents that were not explicitly directed to a specific component. This could lead to unauthorized access to sensitive data or unintended execution of actions triggered by an attacker.</p>\n",
              "language": "en"
            },
            {
              "description": "<p>El equipo de evaluación identificó que <b>Challenge 1</b> utiliza intenciones implícitas, que permiten al sistema Android determinar qué componente, potencialmente de otra aplicación, debe manejar una intención. Si bien esto permite una comunicación flexible entre aplicaciones, una implementación insegura puede provocar una exposición involuntaria de funciones confidenciales.</p>\n",
              "remediation": "<p>El equipo de evaluación recomienda utilizar intenciones explícitas siempre que sea posible para garantizar que solo los componentes de la aplicación previstos las manejen. Si se requieren intenciones implícitas, los desarrolladores deben restringir los componentes expuestos configurando correctamente los filtros de intención y estableciendo el atributo exportado en falso cuando no sea necesario el acceso externo. Además, todos los intents entrantes deben validarse para evitar el acceso no autorizado o la manipulación de datos.</p>\n",
              "impact": "<p>El manejo inadecuado de intenciones implícitas puede resultar en secuestro de intenciones, donde aplicaciones maliciosas interceptan y manipulan intenciones que no estaban dirigidas explícitamente a un componente específico. Esto podría dar lugar a un acceso no autorizado a datos confidenciales o a la ejecución involuntaria de acciones provocadas por un atacante.</p>\n",
              "language": "es"
            }
          ],
          "refs": [
            {
              "label": "Intents and Intent Filters | App architecture - Android Developers",
              "url": "https://developer.android.com/guide/components/intents-filters?hl=es-419"
            },
            {
              "label": "Implicit Intent Hijacking | Security - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks/implicit-intent-hijacking?hl=es-419"
            },
            {
              "label": "Mitigate security risks in your app - Android Developers",
              "url": "https://developer.android.com/privacy-and-security/risks?hl=es-419"
            }
          ],
          "owaspRef": {
            "masvs": "MASVS-PLATFORM-1",
            "maswe": "MASWE-0066"
          },
          "evidences": [
            {
              "id": "c7dbf220-aa90-4563-acb3-f4f90c99b5b4",
              "value": "public final Intent r(Intent intent, SearchableInfo searchableInfo) {\n         ComponentName searchActivity = searchableInfo.getSearchActivity();\n         Intent intent2 = new Intent(\"android.intent.action.SEARCH\");\n         intent2.setComponent(searchActivity);\n         PendingIntent activity = PendingIntent.getActivity(getContext(), 0, intent2, 1073741824);\n         Bundle bundle = new Bundle();\n         Bundle bundle2 = ((SearchView) this).h0;\n         if (bundle2 != null) {\n             bundle.putParcelable(\"app_data\", bundle2);\n         }\n         Intent intent3 = new Intent(intent);\n         Resources resources = getResources();\n         String string = searchableInfo.getVoiceLanguageModeId() != 0 ? resources.getString(searchableInfo.getVoiceLanguageModeId()) : \"free_form\";\n         String string2 = searchableInfo.getVoicePromptTextId() != 0 ? resources.getString(searchableInfo.getVoicePromptTextId()) : null;\n         String string3 = searchableInfo.getVoiceLanguageId() != 0 ? resources.getString(searchableInfo.getVoiceLanguageId()) : null;\n         int voiceMaxResults = searchableInfo.getVoiceMaxResults() != 0 ? searchableInfo.getVoiceMaxResults() : 1;\n         intent3.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", string);\n         intent3.putExtra(\"android.speech.extra.PROMPT\", string2);\n         intent3.putExtra(\"android.speech.extra.LANGUAGE\", string3);\n         intent3.putExtra(\"android.speech.extra.MAX_RESULTS\", voiceMaxResults);\n         intent3.putExtra(\"calling_package\", searchActivity != null ? searchActivity.flattenToShortString() : null);\n         intent3.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT\", activity);\n         intent3.putExtra(\"android.speech.extra.RESULTS_PENDINGINTENT_BUNDLE\", bundle);\n         return intent3;\n     }",
              "vulnerability_id": "5540a4d2-db3a-417c-a329-a74043a52e85",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                1863
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:57.181-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f8f342f0-ef77-44a9-81ea-d407a3e864ba",
              "value": "public ClsSTMN5EE0O0QPA65(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).A = new Rect();\n         ((SearchView) this).B = new Rect();\n         ((SearchView) this).C = new int[2];\n         ((SearchView) this).D = new int[2];\n         ((SearchView) this).i0 = new SearchView.b(this);\n         ((SearchView) this).j0 = new SearchView.c(this);\n         ((SearchView) this).k0 = new WeakHashMap();\n         View.OnClickListener fVar = new SearchView.f(this);\n         ((SearchView) this).l0 = fVar;\n         ((SearchView) this).m0 = new SearchView.g(this);\n         TextView.OnEditorActionListener hVar = new SearchView.h(this);\n         ((SearchView) this).n0 = hVar;\n         AdapterView.OnItemClickListener iVar = new SearchView.i(this);\n         ((SearchView) this).o0 = iVar;\n         AdapterView.OnItemSelectedListener jVar = new SearchView.j(this);\n         ((SearchView) this).p0 = jVar;\n         ((SearchView) this).q0 = new SearchView.a(this);\n         x0 x0Var = new x0(context, context.obtainStyledAttributes(attributeSet, b.u, i, 0));\n         LayoutInflater.from(context).inflate(x0Var.l(9, 2131427353), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(2131231002);\n         ((SearchView) this).q = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).r = findViewById(2131230998);\n         View findViewById2 = findViewById(2131231001);\n         ((SearchView) this).s = findViewById2;\n         View findViewById3 = findViewById(2131231036);\n         ((SearchView) this).t = findViewById3;\n         ImageView imageView = (ImageView) findViewById(2131230996);\n         ((SearchView) this).u = imageView;\n         ImageView imageView2 = (ImageView) findViewById(2131230999);\n         ((SearchView) this).v = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(2131230997);\n         ((SearchView) this).w = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(2131231003);\n         ((SearchView) this).x = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(2131231000);\n         ((SearchView) this).E = imageView5;\n         Drawable g = x0Var.g(10);\n         WeakHashMap weakHashMap = l.a;\n         findViewById2.setBackground(g);\n         findViewById3.setBackground(x0Var.g(14));\n         imageView.setImageDrawable(x0Var.g(13));\n         imageView2.setImageDrawable(x0Var.g(7));\n         imageView3.setImageDrawable(x0Var.g(4));\n         imageView4.setImageDrawable(x0Var.g(16));\n         imageView5.setImageDrawable(x0Var.g(13));\n         ((SearchView) this).F = x0Var.g(12);\n         a.f(imageView, getResources().getString(2131623957));\n         ((SearchView) this).G = x0Var.l(15, 2131427352);\n         ((SearchView) this).H = x0Var.l(5, 0);\n         imageView.setOnClickListener(fVar);\n         imageView3.setOnClickListener(fVar);\n         imageView2.setOnClickListener(fVar);\n         imageView4.setOnClickListener(fVar);\n         findViewById.setOnClickListener(fVar);\n         findViewById.addTextChangedListener(((SearchView) this).q0);\n         findViewById.setOnEditorActionListener(hVar);\n         findViewById.setOnItemClickListener(iVar);\n         findViewById.setOnItemSelectedListener(jVar);\n         findViewById.setOnKeyListener(((SearchView) this).m0);\n         findViewById.setOnFocusChangeListener(new SearchView.d(this));\n         setIconifiedByDefault(x0Var.a(8, true));\n         int f = x0Var.f(1, -1);\n         if (f != -1) {\n             setMaxWidth(f);\n         }\n         ((SearchView) this).K = x0Var.n(6);\n         ((SearchView) this).U = x0Var.n(11);\n         int j = x0Var.j(3, -1);\n         if (j != -1) {\n             setImeOptions(j);\n         }\n         int j2 = x0Var.j(2, -1);\n         if (j2 != -1) {\n             setInputType(j2);\n         }\n         setFocusable(x0Var.a(0, true));\n         x0Var.b.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).I = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).J = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).y = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.e(this));\n         }\n         G(((SearchView) this).Q);\n         D();\n     }",
              "vulnerability_id": "5540a4d2-db3a-417c-a329-a74043a52e85",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                593
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:57.054-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "04d18eae-9331-4c5a-b2ca-74e145d84455",
              "value": "public Cls9WQH4XY1HC3NZ7H(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).A = new Rect();\n         ((SearchView) this).B = new Rect();\n         ((SearchView) this).C = new int[2];\n         ((SearchView) this).D = new int[2];\n         ((SearchView) this).i0 = new SearchView.b(this);\n         ((SearchView) this).j0 = new SearchView.c(this);\n         ((SearchView) this).k0 = new WeakHashMap();\n         View.OnClickListener fVar = new SearchView.f(this);\n         ((SearchView) this).l0 = fVar;\n         ((SearchView) this).m0 = new SearchView.g(this);\n         TextView.OnEditorActionListener hVar = new SearchView.h(this);\n         ((SearchView) this).n0 = hVar;\n         AdapterView.OnItemClickListener iVar = new SearchView.i(this);\n         ((SearchView) this).o0 = iVar;\n         AdapterView.OnItemSelectedListener jVar = new SearchView.j(this);\n         ((SearchView) this).p0 = jVar;\n         ((SearchView) this).q0 = new SearchView.a(this);\n         x0 x0Var = new x0(context, context.obtainStyledAttributes(attributeSet, b.u, i, 0));\n         LayoutInflater.from(context).inflate(x0Var.l(9, 2131427353), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(2131231002);\n         ((SearchView) this).q = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).r = findViewById(2131230998);\n         View findViewById2 = findViewById(2131231001);\n         ((SearchView) this).s = findViewById2;\n         View findViewById3 = findViewById(2131231036);\n         ((SearchView) this).t = findViewById3;\n         ImageView imageView = (ImageView) findViewById(2131230996);\n         ((SearchView) this).u = imageView;\n         ImageView imageView2 = (ImageView) findViewById(2131230999);\n         ((SearchView) this).v = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(2131230997);\n         ((SearchView) this).w = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(2131231003);\n         ((SearchView) this).x = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(2131231000);\n         ((SearchView) this).E = imageView5;\n         Drawable g = x0Var.g(10);\n         WeakHashMap weakHashMap = l.a;\n         findViewById2.setBackground(g);\n         findViewById3.setBackground(x0Var.g(14));\n         imageView.setImageDrawable(x0Var.g(13));\n         imageView2.setImageDrawable(x0Var.g(7));\n         imageView3.setImageDrawable(x0Var.g(4));\n         imageView4.setImageDrawable(x0Var.g(16));\n         imageView5.setImageDrawable(x0Var.g(13));\n         ((SearchView) this).F = x0Var.g(12);\n         a.f(imageView, getResources().getString(2131623957));\n         ((SearchView) this).G = x0Var.l(15, 2131427352);\n         ((SearchView) this).H = x0Var.l(5, 0);\n         imageView.setOnClickListener(fVar);\n         imageView3.setOnClickListener(fVar);\n         imageView2.setOnClickListener(fVar);\n         imageView4.setOnClickListener(fVar);\n         findViewById.setOnClickListener(fVar);\n         findViewById.addTextChangedListener(((SearchView) this).q0);\n         findViewById.setOnEditorActionListener(hVar);\n         findViewById.setOnItemClickListener(iVar);\n         findViewById.setOnItemSelectedListener(jVar);\n         findViewById.setOnKeyListener(((SearchView) this).m0);\n         findViewById.setOnFocusChangeListener(new SearchView.d(this));\n         setIconifiedByDefault(x0Var.a(8, true));\n         int f = x0Var.f(1, -1);\n         if (f != -1) {\n             setMaxWidth(f);\n         }\n         ((SearchView) this).K = x0Var.n(6);\n         ((SearchView) this).U = x0Var.n(11);\n         int j = x0Var.j(3, -1);\n         if (j != -1) {\n             setImeOptions(j);\n         }\n         int j2 = x0Var.j(2, -1);\n         if (j2 != -1) {\n             setInputType(j2);\n         }\n         setFocusable(x0Var.a(0, true));\n         x0Var.b.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).I = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).J = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).y = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.e(this));\n         }\n         G(((SearchView) this).Q);\n         D();\n     }",
              "vulnerability_id": "5540a4d2-db3a-417c-a329-a74043a52e85",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                593
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:57.201-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3ecf8d8f-812d-4c2e-8bbc-0deef91a67b0",
              "value": "public ClsTSIRLU5TGA60V3Z(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).A = new Rect();\n         ((SearchView) this).B = new Rect();\n         ((SearchView) this).C = new int[2];\n         ((SearchView) this).D = new int[2];\n         ((SearchView) this).i0 = new SearchView.b(this);\n         ((SearchView) this).j0 = new SearchView.c(this);\n         ((SearchView) this).k0 = new WeakHashMap();\n         View.OnClickListener fVar = new SearchView.f(this);\n         ((SearchView) this).l0 = fVar;\n         ((SearchView) this).m0 = new SearchView.g(this);\n         TextView.OnEditorActionListener hVar = new SearchView.h(this);\n         ((SearchView) this).n0 = hVar;\n         AdapterView.OnItemClickListener iVar = new SearchView.i(this);\n         ((SearchView) this).o0 = iVar;\n         AdapterView.OnItemSelectedListener jVar = new SearchView.j(this);\n         ((SearchView) this).p0 = jVar;\n         ((SearchView) this).q0 = new SearchView.a(this);\n         x0 x0Var = new x0(context, context.obtainStyledAttributes(attributeSet, b.u, i, 0));\n         LayoutInflater.from(context).inflate(x0Var.l(9, 2131427353), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(2131231002);\n         ((SearchView) this).q = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).r = findViewById(2131230998);\n         View findViewById2 = findViewById(2131231001);\n         ((SearchView) this).s = findViewById2;\n         View findViewById3 = findViewById(2131231036);\n         ((SearchView) this).t = findViewById3;\n         ImageView imageView = (ImageView) findViewById(2131230996);\n         ((SearchView) this).u = imageView;\n         ImageView imageView2 = (ImageView) findViewById(2131230999);\n         ((SearchView) this).v = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(2131230997);\n         ((SearchView) this).w = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(2131231003);\n         ((SearchView) this).x = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(2131231000);\n         ((SearchView) this).E = imageView5;\n         Drawable g = x0Var.g(10);\n         WeakHashMap weakHashMap = l.a;\n         findViewById2.setBackground(g);\n         findViewById3.setBackground(x0Var.g(14));\n         imageView.setImageDrawable(x0Var.g(13));\n         imageView2.setImageDrawable(x0Var.g(7));\n         imageView3.setImageDrawable(x0Var.g(4));\n         imageView4.setImageDrawable(x0Var.g(16));\n         imageView5.setImageDrawable(x0Var.g(13));\n         ((SearchView) this).F = x0Var.g(12);\n         a.f(imageView, getResources().getString(2131623957));\n         ((SearchView) this).G = x0Var.l(15, 2131427352);\n         ((SearchView) this).H = x0Var.l(5, 0);\n         imageView.setOnClickListener(fVar);\n         imageView3.setOnClickListener(fVar);\n         imageView2.setOnClickListener(fVar);\n         imageView4.setOnClickListener(fVar);\n         findViewById.setOnClickListener(fVar);\n         findViewById.addTextChangedListener(((SearchView) this).q0);\n         findViewById.setOnEditorActionListener(hVar);\n         findViewById.setOnItemClickListener(iVar);\n         findViewById.setOnItemSelectedListener(jVar);\n         findViewById.setOnKeyListener(((SearchView) this).m0);\n         findViewById.setOnFocusChangeListener(new SearchView.d(this));\n         setIconifiedByDefault(x0Var.a(8, true));\n         int f = x0Var.f(1, -1);\n         if (f != -1) {\n             setMaxWidth(f);\n         }\n         ((SearchView) this).K = x0Var.n(6);\n         ((SearchView) this).U = x0Var.n(11);\n         int j = x0Var.j(3, -1);\n         if (j != -1) {\n             setImeOptions(j);\n         }\n         int j2 = x0Var.j(2, -1);\n         if (j2 != -1) {\n             setInputType(j2);\n         }\n         setFocusable(x0Var.a(0, true));\n         x0Var.b.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).I = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).J = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).y = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.e(this));\n         }\n         G(((SearchView) this).Q);\n         D();\n     }",
              "vulnerability_id": "5540a4d2-db3a-417c-a329-a74043a52e85",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                611
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:57.234-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "f5a08695-80d1-486b-a7ab-4ca9af1f728b",
              "value": "public ClsDBF01JYSPVCJD4V(Context context, AttributeSet attributeSet, int i) {\n         super(context, attributeSet, i);\n         ((SearchView) this).A = new Rect();\n         ((SearchView) this).B = new Rect();\n         ((SearchView) this).C = new int[2];\n         ((SearchView) this).D = new int[2];\n         ((SearchView) this).i0 = new SearchView.b(this);\n         ((SearchView) this).j0 = new SearchView.c(this);\n         ((SearchView) this).k0 = new WeakHashMap();\n         View.OnClickListener fVar = new SearchView.f(this);\n         ((SearchView) this).l0 = fVar;\n         ((SearchView) this).m0 = new SearchView.g(this);\n         TextView.OnEditorActionListener hVar = new SearchView.h(this);\n         ((SearchView) this).n0 = hVar;\n         AdapterView.OnItemClickListener iVar = new SearchView.i(this);\n         ((SearchView) this).o0 = iVar;\n         AdapterView.OnItemSelectedListener jVar = new SearchView.j(this);\n         ((SearchView) this).p0 = jVar;\n         ((SearchView) this).q0 = new SearchView.a(this);\n         x0 x0Var = new x0(context, context.obtainStyledAttributes(attributeSet, b.u, i, 0));\n         LayoutInflater.from(context).inflate(x0Var.l(9, 2131427353), (ViewGroup) this, true);\n         SearchView.SearchAutoComplete findViewById = findViewById(2131231002);\n         ((SearchView) this).q = findViewById;\n         findViewById.setSearchView(this);\n         ((SearchView) this).r = findViewById(2131230998);\n         View findViewById2 = findViewById(2131231001);\n         ((SearchView) this).s = findViewById2;\n         View findViewById3 = findViewById(2131231036);\n         ((SearchView) this).t = findViewById3;\n         ImageView imageView = (ImageView) findViewById(2131230996);\n         ((SearchView) this).u = imageView;\n         ImageView imageView2 = (ImageView) findViewById(2131230999);\n         ((SearchView) this).v = imageView2;\n         ImageView imageView3 = (ImageView) findViewById(2131230997);\n         ((SearchView) this).w = imageView3;\n         ImageView imageView4 = (ImageView) findViewById(2131231003);\n         ((SearchView) this).x = imageView4;\n         ImageView imageView5 = (ImageView) findViewById(2131231000);\n         ((SearchView) this).E = imageView5;\n         Drawable g = x0Var.g(10);\n         WeakHashMap weakHashMap = l.a;\n         findViewById2.setBackground(g);\n         findViewById3.setBackground(x0Var.g(14));\n         imageView.setImageDrawable(x0Var.g(13));\n         imageView2.setImageDrawable(x0Var.g(7));\n         imageView3.setImageDrawable(x0Var.g(4));\n         imageView4.setImageDrawable(x0Var.g(16));\n         imageView5.setImageDrawable(x0Var.g(13));\n         ((SearchView) this).F = x0Var.g(12);\n         a.f(imageView, getResources().getString(2131623957));\n         ((SearchView) this).G = x0Var.l(15, 2131427352);\n         ((SearchView) this).H = x0Var.l(5, 0);\n         imageView.setOnClickListener(fVar);\n         imageView3.setOnClickListener(fVar);\n         imageView2.setOnClickListener(fVar);\n         imageView4.setOnClickListener(fVar);\n         findViewById.setOnClickListener(fVar);\n         findViewById.addTextChangedListener(((SearchView) this).q0);\n         findViewById.setOnEditorActionListener(hVar);\n         findViewById.setOnItemClickListener(iVar);\n         findViewById.setOnItemSelectedListener(jVar);\n         findViewById.setOnKeyListener(((SearchView) this).m0);\n         findViewById.setOnFocusChangeListener(new SearchView.d(this));\n         setIconifiedByDefault(x0Var.a(8, true));\n         int f = x0Var.f(1, -1);\n         if (f != -1) {\n             setMaxWidth(f);\n         }\n         ((SearchView) this).K = x0Var.n(6);\n         ((SearchView) this).U = x0Var.n(11);\n         int j = x0Var.j(3, -1);\n         if (j != -1) {\n             setImeOptions(j);\n         }\n         int j2 = x0Var.j(2, -1);\n         if (j2 != -1) {\n             setInputType(j2);\n         }\n         setFocusable(x0Var.a(0, true));\n         x0Var.b.recycle();\n         Intent intent = new Intent(\"android.speech.action.WEB_SEARCH\");\n         ((SearchView) this).I = intent;\n         intent.addFlags(268435456);\n         intent.putExtra(\"android.speech.extra.LANGUAGE_MODEL\", \"web_search\");\n         Intent intent2 = new Intent(\"android.speech.action.RECOGNIZE_SPEECH\");\n         ((SearchView) this).J = intent2;\n         intent2.addFlags(268435456);\n         View findViewById4 = findViewById(findViewById.getDropDownAnchor());\n         ((SearchView) this).y = findViewById4;\n         if (findViewById4 != null) {\n             findViewById4.addOnLayoutChangeListener(new SearchView.e(this));\n         }\n         G(((SearchView) this).Q);\n         D();\n     }",
              "vulnerability_id": "5540a4d2-db3a-417c-a329-a74043a52e85",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                611
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:57.099-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            },
            {
              "id": "3c4ce7ed-3f1a-48bf-a70c-396b33ad433e",
              "value": "public final Intent q(String str, Uri uri, String str2, String str3, int i, String str4) {\n         Intent intent = new Intent(str);\n         intent.addFlags(268435456);\n         if (uri != null) {\n             intent.setData(uri);\n         }\n         intent.putExtra(\"user_query\", ((SearchView) this).d0);\n         if (str3 != null) {\n             intent.putExtra(\"query\", str3);\n         }\n         if (str2 != null) {\n             intent.putExtra(\"intent_extra_data_key\", str2);\n         }\n         Bundle bundle = ((SearchView) this).h0;\n         if (bundle != null) {\n             intent.putExtra(\"app_data\", bundle);\n         }\n         if (i != 0) {\n             intent.putExtra(\"action_key\", i);\n             intent.putExtra(\"action_msg\", str4);\n         }\n         intent.setComponent(((SearchView) this).g0.getSearchActivity());\n         return intent;\n     }",
              "vulnerability_id": "5540a4d2-db3a-417c-a329-a74043a52e85",
              "vulnerability_evidence_types_id": 1,
              "file_path": "/androidx/appcompat/widget/SearchView.java",
              "file_line": [
                1790
              ],
              "extra": "java",
              "file": null,
              "created_at": "2025-06-14T20:54:57.158-03:00",
              "is_false_positive": false,
              "isFalsePositive": false
            }
          ],
          "status": "1",
          "scanner_id": 1
        }
      ],
      "severityDistribution": {
        "high": 16.67,
        "info": 33.33,
        "medium": 33.33,
        "low": 16.67
      },
      "severityCount": {
        "info": 2,
        "medium": 2,
        "high": 1,
        "low": 1
      },
      "properties": {
        "MIN_SDK": 23,
        "MD5": "114343dcb07ed6f1e33981ff677132f2",
        "SHA1": "32202c0188857f709cb4ccae3a9c915371af8878",
        "SHA256": "695597159537d6e750b4647739aa8cb37cfab3f6f95b1d848773039597ed5a49",
        "VERSION": "1.0.0",
        "MAIN_ACTIVITY": "com.just.mobile.sec.challenge1.SplashActivity",
        "ANDROID_VERSION_CODE": "1.0.0",
        "FRAMEWORK": "Native (Java / Kotlin)",
        "BINARY_PROTECTIONS": null
      },
      "permissions": [
        "android.permission.WRITE_EXTERNAL_STORAGE",
        "android.permission.READ_EXTERNAL_STORAGE"
      ],
      "components": [
        {
          "name": "com.just.mobile.sec.challenge1.SplashActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": true
        },
        {
          "name": "com.just.mobile.sec.challenge1.MainActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "com.just.mobile.sec.challenge1.ExternalStorageActivity",
          "type": "A",
          "is_browseable": false,
          "is_exported": false
        },
        {
          "name": "androidx.room.MultiInstanceInvalidationService",
          "type": "S",
          "is_browseable": false,
          "is_exported": false
        }
      ],
      "protections": [
        {
          "type": "anti_vm",
          "name": "Emulation Detection",
          "category": [
            "MASVS-RESILIENCE-1"
          ],
          "protectors": [
            {
              "name": "Build.FINGERPRINT",
              "files": [
                "classes.dex"
              ]
            },
            {
              "name": "Build.MANUFACTURER",
              "files": [
                "classes.dex"
              ]
            }
          ]
        }
      ]
    }
  ]
}